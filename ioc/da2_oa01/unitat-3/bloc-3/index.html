---
layout: bloc
title: "Bloc 3: Formularis reactius i validacions"
description: "FormGroup, FormControl, FormBuilder i validadors integrats per gestió avançada de formularis"
keywords: "formularis reactius, FormBuilder, validacions, reactive forms, FormGroup"
unitat: 3
bloc: 3
bloc_numero: 3
---

<!-- SECCIÓ 1: Formularis reactius: grups i controls -->
<div class="section" id="Unitat3_Bloc3_Seccio1">
  <h2 id="Unitat3_Bloc3_Seccio1">1. Formularis reactius: grups i controls</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=3 seccio=1 %}


  {% include objectius.html llista="Crear formularis reactius amb FormGroup, FormControl i FormBuilder, configurant la seva estructura completament des de TypeScript per obtenir control programàtic total|Aplicar validadors integrats (Validators.required, minLength, pattern, etc.) i gestionar missatges d'error reactius que es mostrin dinàmicament segons l'estat del formulari|Comparar formularis template-driven i reactius per decidir quin enfocament utilitzar segons la complexitat i els requisits del projecte" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 1</strong> — Defineix models de dades i estructures adequades al cas d'ús." %}

  {% capture section_point_1_1 %}
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Unitat 2 completa:</strong> Formularis template-driven funcionals amb <code>[(ngModel)]</code> i validacions bàsiques.</li>
<li><strong>Lectures 3.1.x–3.2.x:</strong> <code>ElementService</code> amb signals operatiu, components reactius funcionals.</li>
<li><strong>Projecte actualitzat:</strong> <code>cataleg-elements</code> amb <code>git status</code> net, sense canvis pendents.</li>
<li><strong>VS Code obert:</strong> Terminal integrada disponible per executar comandes Angular CLI.</li>
<li><strong>Documentació:</strong> Fitxer <code>docs/formularis.md</code> existent de la Unitat 2.</li>
</ul>
<p><strong>Verificació ràpida:</strong></p>
{% capture code_392 %}cd ~/workspace/cataleg-elements
ng serve --port 4300
# Verificar http://localhost:4300 accessible amb catàleg funcional{% endcapture %}
{% include code-block.html lang="bash" code=code_392 %}
<p><strong>Punt d'autocomprovació:</strong> Servidor operatiu, catàleg visible al navegador, formularis template-driven de la Unitat 2 funcionals.</p>
  {% endcapture %}
  {% include section-point.html numero="1.1" titol="Prerequisits" contingut=section_point_1_1 %}

  {% capture section_point_1_2 %}
<h4>1.2.1. Què són els formularis reactius</h4>
<p>Els <strong>formularis reactius</strong> (reactive forms) són un enfocament de gestió de formularis en Angular on l'estructura, validacions i lògica es defineixen completament a la classe TypeScript del component, i la plantilla HTML només reflecteix aquesta configuració. Proporcionen control programàtic total sobre l'estat del formulari, permetent validacions dinàmiques, transformacions de dades i gestió complexa d'esdeveniments.</p>
<p><strong>Diferència clau:</strong></p>
<ul>
<li><strong>Template-driven:</strong> Configuració al HTML amb directives (<code>ngModel</code>, <code>required</code>, etc.)</li>
<li><strong>Reactius:</strong> Configuració al TypeScript amb <code>FormGroup</code>, <code>FormControl</code>, <code>Validators</code></li>
</ul>
<h4>1.2.2. Problema amb formularis template-driven</h4>
<p>Els formularis template-driven són suficients per casos simples, però presenten limitacions quan la complexitat augmenta.</p>
<p><strong>Situació amb template-driven:</strong></p>
{% capture code_393 %}export class FormulariComponent {
  element = {
    titol: '',
    categoria: '',
    valoracio: 0
  };
  onSubmit(): void {
    console.log(this.element);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_393 %}
{% capture code_394 %}<form #formulari="ngForm" (ngSubmit)="onSubmit()">
<label>
Títol
<input type="text" name="titol" [(ngModel)]="element.titol" required minlength="4" #titol="ngModel">
</label>
<div *ngIf="titol.touched && titol.invalid">
<p *ngIf="titol.errors?.['required']">El títol és obligatori.</p>
<p *ngIf="titol.errors?.['minlength']">Cal almenys 4 caràcters.</p>
</div>
<label>
Categoria
<select name="categoria" [(ngModel)]="element.categoria" required>
<option value="">Selecciona...</option>
<option value="UI">Components UI</option>
<option value="Backend">Backend</option>
</select>
</label>
<label>
Valoració (0-5)
<input type="number" name="valoracio" [(ngModel)]="element.valoracio" required min="0" max="5">
</label>
<button type="submit" [disabled]="formulari.invalid">Guardar</button>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_394 %}
<p><strong>Problemes que genera:</strong></p>
<p><strong>1. Validacions dinàmiques impossibles</strong></p>
<p>Afegir o eliminar validacions segons altres camps requereix lògica complexa al template amb múltiples <code>*ngIf</code>. Exemple: "Si categoria = 'Backend', el camp 'tecnologia' és obligatori". Amb template-driven, cal mantenir sincronitzat estat entre template i component. Codi fràgil i difícil de mantenir quan hi ha 10+ camps interdependents.</p>
<p><strong>2. Testing extremadament difícil</strong></p>
<p>Provar formulari template-driven requereix simular DOM complet, crear instàncies de directives Angular (<code>ngModel</code>, <code>ngForm</code>) i esperar detecció de canvis. Tests lents (100-300ms per test), fràgils (canviar HTML trenca tests) i acoblats a implementació. Impossible fer tests unitaris purs sense integració.</p>
<p><strong>3. Lògica dispersa entre template i component</strong></p>
<p>Validacions al HTML (<code>required</code>, <code>minlength</code>), gestió d'errors al template (<code>*ngIf</code>), transformacions al component. Quan teniu 15 camps amb validacions personalitzades, cal buscar codi a 3 llocs diferents. Manteniment caòtic. Difícil entendre flux complet.</p>
<p><strong>4. Reutilització limitada</strong></p>
<p>Voleu el mateix formulari amb validacions diferents? Cal duplicar HTML complet. Voleu validacions compartides entre 5 formularis? Cal copiar directives a cada template. Zero reutilització de lògica de validació.</p>
<p><strong>5. Control programàtic mínim</strong></p>
<p>Deshabilitar camp segons resposta API? Complicat amb template-driven. Omplir formulari amb dades carregades asíncronament? Sincronització manual propensa a errors. Subscriure's a canvis d'un camp per actualitzar un altre? Lògica enrevessada amb <code>@ViewChild</code> i esdeveniments.</p>
<h4>1.2.3. Solució amb formularis reactius</h4>
<p>Angular proporciona API programàtica amb control total des de TypeScript.</p>
<p><strong>Situació amb formularis reactius:</strong></p>
{% capture code_395 %}import { Component, OnInit, inject } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
@Component({
  selector: 'app-formulari-reactiu',
  standalone: true,
  imports: [ReactiveFormsModule, CommonModule],
  templateUrl: './formulari-reactiu.component.html'
})
export class FormulariReactiuComponent implements OnInit {
  private readonly fb = inject(FormBuilder);
  formulari!: FormGroup;
  ngOnInit(): void {
    this.formulari = this.fb.group({
      titol: ['', [Validators.required, Validators.minLength(4)]],
      categoria: ['', Validators.required],
      valoracio: [0, [Validators.required, Validators.min(0), Validators.max(5)]],
      descripcio: ['', Validators.maxLength(200)]
    });
    this.formulari.get('categoria')?.valueChanges.subscribe(categoria => {
      if (categoria === 'Backend') {
        this.formulari.get('descripcio')?.setValidators([Validators.required, Validators.minLength(20)]);
      } else {
        this.formulari.get('descripcio')?.setValidators([Validators.maxLength(200)]);
      }
      this.formulari.get('descripcio')?.updateValueAndValidity();
    });
  }
  onSubmit(): void {
    if (this.formulari.valid) {
      console.log(this.formulari.value);
    }
  }
  get titolControl() {
    return this.formulari.get('titol');
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_395 %}
{% capture code_396 %}{% raw %}<form [formGroup]="formulari" (ngSubmit)="onSubmit()">
<label>
Títol
<input type="text" formControlName="titol">
</label>
<div *ngIf="titolControl?.touched && titolControl?.invalid" class="error">
<p *ngIf="titolControl?.hasError('required')">El títol és obligatori.</p>
<p *ngIf="titolControl?.hasError('minlength')">
Cal almenys {{ titolControl?.errors?.['minlength'].requiredLength }} caràcters.
</p>
</div>
<label>
Categoria
<select formControlName="categoria">
<option value="">Selecciona...</option>
<option value="UI">Components UI</option>
<option value="Backend">Backend</option>
</select>
</label>
<label>
Valoració (0-5)
<input type="number" formControlName="valoracio">
</label>
<label>
Descripció
<textarea formControlName="descripcio"></textarea>
</label>
<button type="submit" [disabled]="formulari.invalid">Guardar</button>
</form>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_396 %}
<p><strong>Avantatges específics:</strong></p>
<ul>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Validacions dinàmiques fàcils:</strong> Afegir/eliminar validadors programàticament amb <code>.setValidators()</code>. Exemple implementat: quan categoria = "Backend", descripció es torna obligatòria. Codi net i localitzat.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Testing unitari pur:</strong> Provar FormGroup sense DOM. Test exemple: <code>expect(formulari.get('titol')?.hasError('required')).toBe(true)</code>. Tests ràpids (5-10ms), desacoblats de HTML, mantenibles.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Lògica centralitzada:</strong> Totes les validacions al <code>ngOnInit()</code>. Codi fàcil de trobar, modificar i revisar. Un cop entès el component TypeScript, tens tota la lògica del formulari.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Reutilització senzilla:</strong> Crear funció <code>crearFormulariElement()</code> retornant FormGroup. Reutilitzar validadors personalitzats entre múltiples formularis. Validador compartit: 1 funció vs 10 templates amb directives duplicades.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Control programàtic total:</strong> Deshabilitar camps: <code>.disable()</code>. Omplir formulari: <code>.setValue()</code>. Subscriure's a canvis: <code>.valueChanges.subscribe()</code>. API potent i flexible.</li>
</ul>
<h4>1.2.4. Exemple real complet</h4>
<p><strong>Situació:</strong> Formulari d'element amb validació dinàmica: si categoria = "Backend", descripció obligatòria (min 20 caràcters); si no, opcional (max 200).</p>
<p><strong>Amb template-driven (complex):</strong></p>
{% capture code_397 %}<textarea name="descripcio" [(ngModel)]="element.descripcio" [required]="element.categoria === 'Backend'" [minlength]="element.categoria === 'Backend' ? 20 : 0" [maxlength]="element.categoria !== 'Backend' ? 200 : 9999">
</textarea>
<div *ngIf="descripcio.touched && descripcio.invalid">
<p *ngIf="descripcio.errors?.['required'] && element.categoria === 'Backend'">
Descripció obligatòria per Backend.
</p>
<p *ngIf="descripcio.errors?.['minlength'] && element.categoria === 'Backend'">
Cal almenys 20 caràcters per Backend.
</p>
<p *ngIf="descripcio.errors?.['maxlength'] && element.categoria !== 'Backend'">
Màxim 200 caràcters.
</p>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_397 %}
<p><strong>Amb reactius (clar i mantenible):</strong></p>
{% capture code_398 %}ngOnInit(): void {
  this.formulari = this.fb.group({
    categoria: ['', Validators.required],
    descripcio: ['', Validators.maxLength(200)]
  });
  this.formulari.get('categoria')?.valueChanges.subscribe(categoria => {
    const descripcioControl = this.formulari.get('descripcio');
    if (categoria === 'Backend') {
      descripcioControl?.setValidators([
        Validators.required,
        Validators.minLength(20)
      ]);
    } else {
      descripcioControl?.setValidators([Validators.maxLength(200)]);
    }
    descripcioControl?.updateValueAndValidity();
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_398 %}
{% capture code_399 %}<select formControlName="categoria">...</select>
<textarea formControlName="descripcio"></textarea>
<div *ngIf="descripcioControl?.touched && descripcioControl?.invalid">
<p *ngIf="descripcioControl?.hasError('required')">
Descripció obligatòria per Backend.
</p>
<p *ngIf="descripcioControl?.hasError('minlength')">
Cal almenys 20 caràcters.
</p>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_399 %}
<h4>1.2.5. Comparativa visual</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Template-driven</th>
<th>Reactius</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Definició</strong></td>
<td>HTML (directives <code>ngModel</code>)</td>
<td>TypeScript (<code>FormGroup</code>, <code>FormControl</code>)</td>
</tr>
<tr>
<td><strong>Validacions</strong></td>
<td>Directives HTML (<code>required</code>, <code>minlength</code>)</td>
<td>Validators programàtics (<code>Validators.required</code>)</td>
</tr>
<tr>
<td><strong>Validacions dinàmiques</strong></td>
<td>Difícil (lògica al template amb <code>*ngIf</code>)</td>
<td>Fàcil (<code>.setValidators()</code> programàtic)</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>Requereix DOM complet</td>
<td>Tests unitaris purs sense DOM</td>
</tr>
<tr>
<td><strong>Temps test</strong></td>
<td>100-300ms per test</td>
<td>5-10ms per test</td>
</tr>
<tr>
<td><strong>Reutilització</strong></td>
<td>Baixa (duplicar HTML)</td>
<td>Alta (funcions retornant FormGroup)</td>
</tr>
<tr>
<td><strong>Control programàtic</strong></td>
<td>Limitat (<code>@ViewChild</code>, esdeveniments)</td>
<td>Total (API completa <code>.disable()</code>, <code>.setValue()</code>)</td>
</tr>
<tr>
<td><strong>Complexitat inicial</strong></td>
<td>Baixa (casos simples)</td>
<td>Mitjana (configuració TypeScript)</td>
</tr>
<tr>
<td><strong>Escalabilitat</strong></td>
<td>Difícil (formularis complexos)</td>
<td>Excel·lent (estructura clara)</td>
</tr>
<tr>
<td><strong>Accessibilitat a dades</strong></td>
<td>Via <code>ngModel</code> (bidireccional)</td>
<td>Via <code>.value</code> (unidireccional)</td>
</tr>
<tr>
<td><strong>Subscripció a canvis</strong></td>
<td>Complexa (<code>@ViewChild</code> + events)</td>
<td>Nativa (<code>.valueChanges</code> observable)</td>
</tr>
</tbody>
</table>
<h4>1.2.6. Conceptes clau</h4>
<table>
<thead>
<tr>
<th>Concepte</th>
<th>Definició</th>
<th>Sintaxi</th>
<th>Quan usar</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FormGroup</strong></td>
<td>Contenidor de FormControls relacionats</td>
<td><code>fb.group({ camp: [...] })</code></td>
<td>Agrupar camps d'un formulari</td>
</tr>
<tr>
<td><strong>FormControl</strong></td>
<td>Control individual amb valor i validadors</td>
<td><code>new FormControl('', Validators.required)</code></td>
<td>Crear camp únic</td>
</tr>
<tr>
<td><strong>FormBuilder</strong></td>
<td>Servei per crear FormGroups amb sintaxi simplificada</td>
<td><code>fb.group(...)</code></td>
<td>Simplificar creació de formularis</td>
</tr>
<tr>
<td><strong>Validators</strong></td>
<td>Classe amb validadors integrats</td>
<td><code>Validators.required</code>, <code>Validators.email</code></td>
<td>Aplicar validacions comunes</td>
</tr>
<tr>
<td><strong>valueChanges</strong></td>
<td>Observable que emet cada canvi de valor</td>
<td><code>control.valueChanges.subscribe(...)</code></td>
<td>Reaccionar a canvis de camps</td>
</tr>
<tr>
<td><strong>statusChanges</strong></td>
<td>Observable que emet cada canvi d'estat</td>
<td><code>control.statusChanges.subscribe(...)</code></td>
<td>Reaccionar a canvis de validació</td>
</tr>
</tbody>
</table>
<h4>1.2.7. Quan usar cada enfocament</h4>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar template-driven quan:</strong></p>
<ul>
<li>Formulari molt simple (3-5 camps, validacions bàsiques)</li>
<li>Aplicació petita sense requisits de testing</li>
<li>Equip poc familiaritzat amb programació reactiva</li>
<li>Prototipatge ràpid sense manteniment a llarg termini</li>
</ul>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar reactius quan:</strong></p>
<ul>
<li>Formulari complex (10+ camps, validacions interdependents)</li>
<li>Validacions dinàmiques (camps canvien segons altres camps)</li>
<li>Testing prioritari (tests unitaris ràpids)</li>
<li>Formularis reutilitzables entre múltiples components</li>
<li>Integració amb APIs asíncrones (autocompletar, validacions remotes)</li>
<li>Aplicació escalable amb manteniment a llarg termini</li>
</ul>
<p><strong>Recomanació general:</strong> Per aplicacions professionals, usar formularis reactius per defecte. Template-driven només per casos molt simples on el desenvolupament ràpid és prioritari sobre mantenibilitat.</p>
<h4>1.2.8. Característiques principals</h4>
<p><strong>Control programàtic</strong></p>
<p>Accés complet a l'estat del formulari des de TypeScript: <code>.valid</code>, <code>.invalid</code>, <code>.touched</code>, <code>.dirty</code>, <code>.pristine</code>. Modificació de valors: <code>.setValue()</code>, <code>.patchValue()</code>. Gestió de validadors: <code>.setValidators()</code>, <code>.clearValidators()</code>.</p>
<p><strong>Reactivitat amb observables</strong></p>
<p><code>.valueChanges</code> emet cada cop que canvia el valor. <code>.statusChanges</code> emet quan canvia l'estat de validació. Subscriure's permet implementar lògica reactiva complexa (autoguardat, validacions asíncrones, actualitzacions en cascada).</p>
<p><strong>Composició de formularis</strong></p>
<p>FormGroup pot contenir altres FormGroups (formularis niuats). FormArray permet llistes dinàmiques de controls. Estructura jeràrquica per formularis complexos.</p>
<p><strong>Validació explícita</strong></p>
<p>Validadors aplicats a la creació del control. Validacions sincronitzades (Validators.required) i asíncrones (validar amb API). Missatges d'error accessibles via <code>.hasError('validador')</code>.</p>
<h4>1.2.9. Integració amb el flux de treball</h4>
<p>Els formularis reactius s'integren amb:</p>
<ul>
<li><strong>Signals:</strong> Combinar FormGroup amb signals per reactivitat optimitzada</li>
<li><strong>Services:</strong> Carregar/guardar dades de formularis via serveis HTTP</li>
<li><strong>Routing:</strong> Resolvers per precarregar dades abans de mostrar formulari</li>
<li><strong>RxJS:</strong> Operadors per transformar, filtrar i combinar streams de dades</li>
</ul>
<p>En les pròximes lectures aprendreu:</p>
<ul>
<li>Validacions personalitzades (custom validators)</li>
<li>Validacions asíncrones (comprovar API)</li>
<li>FormArray per llistes dinàmiques</li>
<li>Formularis niuats complexos</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="1.2" titol="Marc conceptual" contingut=section_point_1_2 %}

  {% capture section_point_1_3 %}
<h4>1.3.1. Flux de formulari reactiu</h4>
{% capture code_400 %}Component TypeScript
  ↓ FormBuilder.group()
FormGroup creat en memòria
  ↓ conté FormControls
Validadors aplicats a cada control
  ↓ [formGroup]="formulari"
Template HTML vinculat
  ↓ formControlName="camp"
Input de l'usuari
  ↓ .valueChanges observable
Subscripció reactiva (opcional)
  ↓ Validators executats
Estat del formulari actualitzat
  ↓ .valid / .invalid
Change detection Angular
  ↓ {{ formulari.value }}
DOM actualitzat{% endcapture %}
{% include code-block.html lang="text" code=code_400 %}
<h4>1.3.2. Estructura jeràrquica</h4>
{% capture code_401 %}FormGroup (formulari)
  ├── FormControl (titol) + [Validators.required, Validators.minLength(4)]
  ├── FormControl (categoria) + [Validators.required]
  ├── FormControl (valoracio) + [Validators.min(0), Validators.max(5)]
  └── FormControl (descripcio) + [Validators.maxLength(200)]{% endcapture %}
{% include code-block.html lang="text" code=code_401 %}
<p><strong>Regla mnemotècnica:</strong></p>
<ul>
<li>FormGroup = Contenidor d'objecte <code>{ titol: '...', categoria: '...' }</code></li>
<li>FormControl = Propietat individual amb validadors</li>
<li>FormBuilder = Factoria per crear FormGroups amb sintaxi curta</li>
</ul>
<h4>1.3.3. Relació TypeScript ↔ Template</h4>
{% capture code_402 %}this.formulari = this.fb.group({
  titol: ['', Validators.required]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_402 %}
{% capture code_403 %}<form [formGroup]="formulari">
<input formControlName="titol">
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_403 %}
<h4>1.3.4. Analogia útil</h4>
<p><strong>Formulari reactiu = Full de càlcul programable</strong></p>
<ul>
<li>FormGroup = Full amb múltiples cel·les</li>
<li>FormControl = Cel·la individual amb valor i fórmules (validadors)</li>
<li>Validators = Regles de validació de dades (> 0, text obligatori)</li>
<li>.valueChanges = Event que es dispara quan canvia una cel·la</li>
<li>.valid / .invalid = Estat global del full (totes fórmules complides?)</li>
</ul>
<p><strong>Error comú a evitar:</strong></p>
<p><i class="bi bi-x-circle" aria-hidden="true"></i> Pensar que FormControl és com ngModel (bidireccional)</p>
<p><i class="bi bi-check-circle" aria-hidden="true"></i> FormControl és unidireccional: TypeScript → Template</p>
<p><strong>Per què unidireccional?</strong></p>
<p>Template NO pot modificar FormControl directament. Usuari escriu input → Angular actualitza FormControl → Change detection → Template mostra valor actualitzat. Flux controlat i predictible.</p>
  {% endcapture %}
  {% include section-point.html numero="1.3" titol="Model mental" contingut=section_point_1_3 %}

  {% capture section_point_1_4 %}
<h4>1.4.1. Objectiu</h4>
<p>Entendre les diferències fonamentals entre els dos enfocaments i decidir quan usar cada un.</p>
<h4>1.4.2. Template-driven</h4>
<ul>
<li>Configuració basada en directives HTML: <code>[(ngModel)]</code>, <code>required</code>, <code>minlength</code></li>
<li>Lògica de validació al template amb <code>*ngIf</code> i variables de plantilla</li>
<li>Adequat per formularis simples amb validacions estàtiques</li>
<li>Menys codi TypeScript, més codi HTML</li>
</ul>
<p><strong>Exemple template-driven:</strong></p>
{% capture code_404 %}<form #f="ngForm">
<input name="titol" [(ngModel)]="titol" required minlength="4">
<div *ngIf="f.controls['titol']?.invalid">Error</div>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_404 %}
<h4>1.4.3. Reactius</h4>
<ul>
<li>Configuració basada en codi TypeScript: <code>FormGroup</code>, <code>FormControl</code>, <code>Validators</code></li>
<li>Lògica de validació al component amb API programàtica</li>
<li>Adequat per formularis complexos amb validacions dinàmiques</li>
<li>Més codi TypeScript, menys codi HTML</li>
</ul>
<p><strong>Exemple reactiu:</strong></p>
{% capture code_405 %}formulari = this.fb.group({
  titol: ['', [Validators.required, Validators.minLength(4)]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_405 %}
{% capture code_406 %}<form [formGroup]="formulari">
<input formControlName="titol">
<div *ngIf="formulari.get('titol')?.invalid">Error</div>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_406 %}
<h4>1.4.4. Criteri de decisió</h4>
<ul>
<li>Formulari &lt; 5 camps, validacions estàtiques → Template-driven</li>
<li>Formulari &gt; 5 camps, validacions dinàmiques → Reactius</li>
<li>Aplicació professional amb testing → Reactius</li>
<li>Prototipatge ràpid → Template-driven</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> Template-driven = simplicitat per casos bàsics. Reactius = control i escalabilitat per casos complexos." %}
<h4>1.4.5. Resultat esperat</h4>
<p>Compreneu quan usar cada enfocament segons els requisits del projecte.</p>
  {% endcapture %}
  {% include section-point.html numero="1.4" titol="Formularis template-driven vs reactius: comparativa" contingut=section_point_1_4 %}

  {% capture section_point_1_5 %}
<h4>1.5.1. Objectiu</h4>
<p>Aprendre a crear formularis reactius manualment amb <code>FormGroup</code> i <code>FormControl</code>.</p>
<h4>1.5.2. Sintaxi bàsica sense FormBuilder</h4>
{% capture code_407 %}import { FormGroup, FormControl, Validators } from '@angular/forms';
export class FormulariComponent {
  formulari = new FormGroup({
    titol: new FormControl('', Validators.required),
    categoria: new FormControl('UI'),
    valoracio: new FormControl(0, [Validators.min(0), Validators.max(5)])
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_407 %}
<p><strong>Estructura:</strong></p>
<ul>
<li><code>FormGroup</code>: contenidor de múltiples FormControls</li>
<li><code>FormControl(valorInicial, validadors)</code>: control individual</li>
<li>Validadors: poden ser un únic validador o array de validadors</li>
</ul>
<h4>1.5.3. Accés a controls</h4>
{% capture code_408 %}const titolControl = this.formulari.get('titol');
if (titolControl?.invalid) {
  console.log('Títol invàlid');
}
if (titolControl?.hasError('required')) {
  console.log('Títol obligatori');
}
const valorTitol = titolControl?.value;{% endcapture %}
{% include code-block.html lang="typescript" code=code_408 %}
<h4>1.5.4. Modificar valors</h4>
{% capture code_409 %}this.formulari.setValue({
  titol: 'Nou element',
  categoria: 'Backend',
  valoracio: 4
});
this.formulari.patchValue({
  titol: 'Títol modificat'
});
this.formulari.get('titol')?.setValue('Altre títol');{% endcapture %}
{% include code-block.html lang="typescript" code=code_409 %}
{% include success_box.html contingut="<strong>Clau:</strong> FormGroup agrupa FormControls. Accediu a controls amb <code>.get('nom')</code> per comprovar estat i modificar valors." %}
<h4>1.5.5. Resultat esperat</h4>
<p>Sabeu crear FormGroup manualment i accedir a controls individualment.</p>
  {% endcapture %}
  {% include section-point.html numero="1.5" titol="Crear FormGroup i FormControls bàsics" contingut=section_point_1_5 %}

  {% capture section_point_1_6 %}
<h4>1.6.1. Objectiu</h4>
<p>Usar FormBuilder per crear formularis amb sintaxi més concisa i llegible.</p>
<h4>1.6.2. FormBuilder vs creació manual</h4>
{% capture code_410 %}formulari = new FormGroup({
  titol: new FormControl('', [Validators.required, Validators.minLength(4)]),
  categoria: new FormControl('', Validators.required),
  valoracio: new FormControl(0, [Validators.min(0), Validators.max(5)])
});
formulari = this.fb.group({
  titol: ['', [Validators.required, Validators.minLength(4)]],
  categoria: ['', Validators.required],
  valoracio: [0, [Validators.min(0), Validators.max(5)]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_410 %}
<h4>1.6.3. Injectar FormBuilder</h4>
{% capture code_411 %}import { Component, inject } from '@angular/core';
import { FormBuilder, Validators } from '@angular/forms';
export class FormulariComponent {
  private readonly fb = inject(FormBuilder);
  formulari = this.fb.group({
    titol: ['', Validators.required],
    categoria: ['UI'],
    valoracio: [0]
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_411 %}
<h4>1.6.4. Sintaxi FormBuilder</h4>
{% capture code_412 %}this.fb.group({
  camp: [valorInicial],
  camp: [valorInicial, validador],
  camp: [valorInicial, [valid1, valid2]],
  camp: [valorInicial, [valid1], [validAsync]]
}){% endcapture %}
{% include code-block.html lang="typescript" code=code_412 %}
<h4>1.6.5. Formulari complet d'exemple</h4>
{% capture code_413 %}formulari = this.fb.group({
  titol: ['', [Validators.required, Validators.minLength(4), Validators.maxLength(50)]],
  categoria: ['', Validators.required],
  preu: [0, [Validators.required, Validators.min(0)]],
  descripcio: ['', Validators.maxLength(200)],
  actiu: [true],
  dataCreacio: [new Date().toISOString().split('T')[0]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_413 %}
<p><strong>Avantatges FormBuilder:</strong></p>
<ul>
<li>Sintaxi més curta i llegible</li>
<li>Menys repetició de <code>new FormControl</code></li>
<li>Estàndard de la comunitat Angular</li>
<li>Més fàcil de mantenir</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> FormBuilder simplifica creació de formularis amb sintaxi d'array: <code>[valor, [validadors]]</code>." %}
<h4>1.6.6. Resultat esperat</h4>
<p>Preferiu FormBuilder sobre creació manual per codi més net i mantenible.</p>
  {% endcapture %}
  {% include section-point.html numero="1.6" titol="Configurar FormBuilder per simplificar creació" contingut=section_point_1_6 %}

  {% capture section_point_1_7 %}
<h4>1.7.1. Objectiu</h4>
<p>Dominar els validadors integrats d'Angular i aplicar-los correctament.</p>
<h4>1.7.2. Validadors integrats disponibles</h4>
<table>
<thead>
<tr>
<th>Validador</th>
<th>Descripció</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Validators.required</code></td>
<td>Camp obligatori</td>
<td><code>['', Validators.required]</code></td>
</tr>
<tr>
<td><code>Validators.minLength(n)</code></td>
<td>Mínim n caràcters</td>
<td><code>['', Validators.minLength(4)]</code></td>
</tr>
<tr>
<td><code>Validators.maxLength(n)</code></td>
<td>Màxim n caràcters</td>
<td><code>['', Validators.maxLength(50)]</code></td>
</tr>
<tr>
<td><code>Validators.min(n)</code></td>
<td>Valor mínim numèric</td>
<td><code>[0, Validators.min(0)]</code></td>
</tr>
<tr>
<td><code>Validators.max(n)</code></td>
<td>Valor màxim numèric</td>
<td><code>[100, Validators.max(100)]</code></td>
</tr>
<tr>
<td><code>Validators.email</code></td>
<td>Format email vàlid</td>
<td><code>['', Validators.email]</code></td>
</tr>
<tr>
<td><code>Validators.pattern(regex)</code></td>
<td>Expressió regular</td>
<td><code>['', Validators.pattern(/^[A-Z]/)]</code></td>
</tr>
</tbody>
</table>
<h4>1.7.3. Aplicar múltiples validadors</h4>
{% capture code_414 %}formulari = this.fb.group({
  titol: ['', [
    Validators.required,
    Validators.minLength(4),
    Validators.maxLength(50),
    Validators.pattern(/^[A-Z]/)
  ]],
  email: ['', [
    Validators.required,
    Validators.email
  ]],
  telefon: ['', [
    Validators.required,
    Validators.pattern(/^[0-9]{9}$/)
  ]],
  edat: [0, [
    Validators.required,
    Validators.min(18),
    Validators.max(120)
  ]],
  descripcio: ['', Validators.maxLength(200)]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_414 %}
<h4>1.7.4. Comprovar errors específics</h4>
{% capture code_415 %}const titolControl = this.formulari.get('titol');
if (titolControl?.hasError('required')) {
  console.log('Camp obligatori');
}
if (titolControl?.hasError('minlength')) {
  const minLength = titolControl?.errors?.['minlength'].requiredLength;
  console.log(`Cal almenys ${minLength} caràcters`);
}
if (titolControl?.hasError('pattern')) {
  console.log('Format incorrecte');
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_415 %}
<h4>1.7.5. Pattern per casos comuns</h4>
{% capture code_416 %}Validators.pattern(/^[a-zA-ZÀ-ÿ\s]+$/)
Validators.pattern(/^[0-9]+$/)
Validators.pattern(/^[6-9][0-9]{8}$/)
Validators.pattern(/^[0-9]{5}$/)
Validators.pattern(/^https?:\/\/.+/)
Validators.pattern(/^[0-9]{8}[A-Z]$/){% endcapture %}
{% include code-block.html lang="typescript" code=code_416 %}
<h4>1.7.6. Validadors opcionals</h4>
{% capture code_417 %}descripcio: ['', [
  Validators.maxLength(200)
]]
comentari: ['', [
  Validators.minLength(10)
]]{% endcapture %}
{% include code-block.html lang="typescript" code=code_417 %}
{% include success_box.html contingut="<strong>Clau:</strong> Combineu múltiples validadors per assegurar qualitat de dades. Useu <code>.hasError()</code> per missatges específics." %}
<h4>1.7.7. Resultat esperat</h4>
<p>Sabeu aplicar validadors integrats i comprovar errors específics per mostrar missatges contextuals.</p>
  {% endcapture %}
  {% include section-point.html numero="1.7" titol="Aplicar validadors integrats (required, minLength, etc.)" contingut=section_point_1_7 %}

  {% capture section_point_1_8 %}
<h4>1.8.1. Objectiu</h4>
<p>Connectar el FormGroup definit a TypeScript amb la plantilla HTML.</p>
<h4>1.8.2. Estructura bàsica de vinculació</h4>
{% capture code_418 %}<form [formGroup]="formulari" (ngSubmit)="onSubmit()">
<label>
Títol
<input type="text" formControlName="titol">
</label>
<label>
Categoria
<select formControlName="categoria">
<option value="">Selecciona...</option>
<option value="UI">Components UI</option>
<option value="Backend">Backend</option>
<option value="Data">Data Science</option>
</select>
</label>
<label>
Valoració (0-5)
<input type="number" formControlName="valoracio">
</label>
<label>
Descripció
<textarea formControlName="descripcio" rows="4"></textarea>
</label>
<button type="submit" [disabled]="formulari.invalid">
Guardar
</button>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_418 %}
<h4>1.8.3. Importar ReactiveFormsModule</h4>
{% capture code_419 %}import { Component, inject } from '@angular/core';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-formulari-element',
  standalone: true,
  imports: [ReactiveFormsModule, CommonModule],
  templateUrl: './formulari-element.component.html'
})
export class FormulariElementComponent {
  private readonly fb = inject(FormBuilder);
  formulari = this.fb.group({
    titol: ['', [Validators.required, Validators.minLength(4)]],
    categoria: ['', Validators.required],
    valoracio: [0, [Validators.min(0), Validators.max(5)]],
    descripcio: ['', Validators.maxLength(200)]
  });
  onSubmit(): void {
    if (this.formulari.valid) {
      console.log('Dades del formulari:', this.formulari.value);
    }
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_419 %}
<h4>1.8.4. Checkbox i radio buttons</h4>
{% capture code_420 %}<label>
<input type="checkbox" formControlName="actiu">
Element actiu
</label>
<fieldset>
<legend>Prioritat</legend>
<label>
<input type="radio" formControlName="prioritat" value="baixa">
Baixa
</label>
<label>
<input type="radio" formControlName="prioritat" value="mitjana">
Mitjana
</label>
<label>
<input type="radio" formControlName="prioritat" value="alta">
Alta
</label>
</fieldset>{% endcapture %}
{% include code-block.html lang="html" code=code_420 %}
<h4>1.8.5. Accedir a estat del formulari al template</h4>
{% capture code_421 %}<p>Formulari vàlid: {{ formulari.valid }}</p>
<p>Modificat: {{ formulari.dirty }}</p>
<p>Tocat: {{ formulari.touched }}</p>
<pre>{{ formulari.value | json }}</pre>{% endcapture %}
{% include code-block.html lang="html" code=code_421 %}
{% include success_box.html contingut="<strong>Clau:</strong> <code>[formGroup]</code> al <code>&lt;form&gt;</code>, <code>formControlName</code> a cada input. ReactiveFormsModule obligatori a imports." %}
<h4>1.8.6. Resultat esperat</h4>
<p>Formulari TypeScript vinculat a template, inputs sincronitzats automàticament.</p>
  {% endcapture %}
  {% include section-point.html numero="1.8" titol="Vincular formulari a plantilla amb formControlName" contingut=section_point_1_8 %}

  {% capture section_point_1_9 %}
<h4>1.9.1. Objectiu</h4>
<p>Implementar missatges d'error contextuals que es mostrin només quan correspon.</p>
<h4>1.9.2. Patró de missatges d'error</h4>
{% capture code_422 %}{% raw %}<label>
Títol
<input type="text" formControlName="titol">
</label>
<div *ngIf="formulari.get('titol')?.touched && formulari.get('titol')?.invalid" class="error">
<p *ngIf="formulari.get('titol')?.hasError('required')">
El títol és obligatori.
</p>
<p *ngIf="formulari.get('titol')?.hasError('minlength')">
Cal almenys
{{ formulari.get('titol')?.errors?.['minlength'].requiredLength }}
caràcters.
</p>
<p *ngIf="formulari.get('titol')?.hasError('maxlength')">
Màxim
{{ formulari.get('titol')?.errors?.['maxlength'].requiredLength }}
caràcters.
</p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_422 %}
<h4>1.9.3. Simplificar amb getter</h4>
{% capture code_423 %}get titolControl() {
  return this.formulari.get('titol');
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_423 %}
{% capture code_424 %}{% raw %}<div *ngIf="titolControl?.touched && titolControl?.invalid" class="error">
<p *ngIf="titolControl?.hasError('required')">
El títol és obligatori.
</p>
<p *ngIf="titolControl?.hasError('minlength')">
Cal almenys {{ titolControl?.errors?.['minlength'].requiredLength }} caràcters.
</p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_424 %}
<h4>1.9.4. Estils per missatges d'error</h4>
{% capture code_425 %}.error {
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 4px;
  padding: 0.5rem;
  margin-top: 0.25rem;
  p {
    margin: 0.25rem 0;
    color: #c33;
    font-size: 0.875rem;
  }
}
input.ng-touched.ng-invalid,
select.ng-touched.ng-invalid,
textarea.ng-touched.ng-invalid {
  border-color: #c33;
  background: #fff5f5;
}{% endcapture %}
{% include code-block.html lang="scss" code=code_425 %}
<h4>1.9.5. Missatges per altres validadors</h4>
{% capture code_426 %}{% raw %}<div *ngIf="emailControl?.touched && emailControl?.invalid" class="error">
<p *ngIf="emailControl?.hasError('required')">
L'email és obligatori.
</p>
<p *ngIf="emailControl?.hasError('email')">
Format d'email incorrecte.
</p>
</div>
<div *ngIf="telefonControl?.touched && telefonControl?.invalid" class="error">
<p *ngIf="telefonControl?.hasError('required')">
El telèfon és obligatori.
</p>
<p *ngIf="telefonControl?.hasError('pattern')">
El telèfon ha de tenir 9 dígits.
</p>
</div>
<div *ngIf="edatControl?.touched && edatControl?.invalid" class="error">
<p *ngIf="edatControl?.hasError('min')">
Edat mínima: {{ edatControl?.errors?.['min'].min }}.
</p>
<p *ngIf="edatControl?.hasError('max')">
Edat màxima: {{ edatControl?.errors?.['max'].max }}.
</p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_426 %}
{% include success_box.html contingut="<strong>Clau:</strong> Condició <code>.touched && .invalid</code> evita mostrar errors abans que l'usuari interactuï. <code>.hasError()</code> per missatges específics." %}
<h4>1.9.6. Resultat esperat</h4>
<p>Missatges d'error contextuals que apareixen només quan l'usuari toca el camp i té errors.</p>
  {% endcapture %}
  {% include section-point.html numero="1.9" titol="Mostrar missatges d'error reactius" contingut=section_point_1_9 %}

  {% capture section_point_1_10 %}
<h4>1.10.1. Objectiu</h4>
<p>Implementar gestió de l'enviament del formulari i accés a les dades validades.</p>
<h4>1.10.2. Gestió d'enviament bàsica</h4>
{% capture code_427 %}onSubmit(): void {
  if (this.formulari.invalid) {
    console.warn('Formulari invàlid');
    return;
  }
  const dades = this.formulari.value;
  console.log('Dades del formulari:', dades);
  this.elementService.crearElement(dades).subscribe({
    next: () => {
      console.log('Element creat correctament');
      this.formulari.reset();
    },
    error: (err) => {
      console.error('Error en crear element:', err);
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_427 %}
<h4>1.10.3. Marcar tots els camps com a tocats</h4>
{% capture code_428 %}onSubmit(): void {
  this.formulari.markAllAsTouched();
  if (this.formulari.invalid) {
    console.warn('Formulari invàlid. Revisa els camps.');
    return;
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_428 %}
<h4>1.10.4. Accedir a valors individuals</h4>
{% capture code_429 %}const titol = this.formulari.get('titol')?.value;
const categoria = this.formulari.get('categoria')?.value;
console.log(`Títol: ${titol}, Categoria: ${categoria}`);{% endcapture %}
{% include code-block.html lang="typescript" code=code_429 %}
<h4>1.10.5. Establir valors per defecte o des d'API</h4>
{% capture code_430 %}ngOnInit(): void {
  this.elementService.obtenirElement(this.elementId).subscribe(element => {
    this.formulari.patchValue({
      titol: element.titol,
      categoria: element.categoria,
      valoracio: element.valoracio,
      descripcio: element.descripcio
    });
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_430 %}
<h4>1.10.6. Resetear formulari</h4>
{% capture code_431 %}this.formulari.reset();
this.formulari.reset({
  titol: '',
  categoria: 'UI',
  valoracio: 0,
  descripcio: ''
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_431 %}
<h4>1.10.7. Deshabilitar formulari durant enviament</h4>
{% capture code_432 %}isEnviant = false;
onSubmit(): void {
  if (this.formulari.invalid) return;
  this.isEnviant = true;
  this.formulari.disable();
  this.elementService.crearElement(this.formulari.value).subscribe({
    next: () => {
      console.log('Element creat');
      this.formulari.enable();
      this.formulari.reset();
      this.isEnviant = false;
    },
    error: (err) => {
      console.error('Error:', err);
      this.formulari.enable();
      this.isEnviant = false;
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_432 %}
{% capture code_433 %}{% raw %}<button type="submit" [disabled]="formulari.invalid || isEnviant">
{{ isEnviant ? 'Enviant...' : 'Guardar' }}
</button>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_433 %}
{% include success_box.html contingut="<strong>Clau:</strong> Validar amb <code>.invalid</code> abans d'enviar. Usar <code>.markAllAsTouched()</code> per mostrar tots els errors. <code>.disable()</code> durant enviament." %}
<h4>1.10.8. Resultat esperat</h4>
<p>Gestió completa de l'enviament amb validació, feedback visual i gestió d'errors.</p>
  {% endcapture %}
  {% include section-point.html numero="1.10" titol="Gestionar enviament i accés a valors" contingut=section_point_1_10 %}

  {% capture section_point_1_11 %}
<h4>1.11.1. Objectiu</h4>
<p>Registrar la configuració del formulari i les proves realitzades al dossier tècnic.</p>
<h4>1.11.2. Actualitzar docs/formularis.md</h4>
{% capture code_434 %}## Formularis reactius
### Configuració
**Component:** `FormulariElementComponent`
**Tipus:** Formulari reactiu amb FormBuilder
### Camps i validacions
| Camp | Tipus | Validacions | Valor per defecte |
|------|-------|-------------|-------------------|
| titol | text | required, minLength(4), maxLength(50) | '' |
| categoria | select | required | '' |
| valoracio | number | required, min(0), max(5) | 0 |
| descripcio | textarea | maxLength(200) | '' |
### Missatges d'error
| Camp | Error | Missatge |
|------|-------|----------|
| titol | required | "El títol és obligatori." |
| titol | minlength | "Cal almenys 4 caràcters." |
| titol | maxlength | "Màxim 50 caràcters." |
| categoria | required | "La categoria és obligatòria." |
| valoracio | min | "Valoració mínima: 0." |
| valoracio | max | "Valoració màxima: 5." |
| descripcio | maxlength | "Màxim 200 caràcters." |
### Gestió d'enviament
1. Validar formulari amb `.invalid`
2. Marcar camps com a tocats amb `.markAllAsTouched()`
3. Deshabilitar formulari amb `.disable()` durant enviament
4. Enviar dades a `ElementService.crearElement()`
5. Gestionar èxit/error
6. Resetear formulari amb `.reset()` si èxit
### Proves realitzades
- Validació required funciona
- Validació minLength mostra missatge correcte
- Validació min/max per valoració
- Botó submit deshabilitat quan formulari invàlid
- Formulari es reseteja després d'enviar
- Missatges d'error només apareixen després de tocar camps
### Decisions de disseny
**Per què formularis reactius vs template-driven:**
- Validacions dinàmiques necessàries (futur: descripció obligatòria per Backend)
- Testing unitari prioritari
- Reutilització de validadors entre múltiples formularis
- Control programàtic total per integracions futures
**Futures millores:**
- Validacions asíncrones (comprovar títol duplicat a API)
- FormArray per afegir múltiples imatges
- Validadors personalitzats (ex: categoria específica segons regles negoci){% endcapture %}
{% include code-block.html lang="markdown" code=code_434 %}
{% include success_box.html contingut="<strong>Clau:</strong> Documentar camps, validacions, missatges i decisions de disseny facilita manteniment i onboarding." %}
<h4>1.11.3. Resultat esperat</h4>
<p>Dossier actualitzat amb especificació completa del formulari reactiu.</p>
  {% endcapture %}
  {% include section-point.html numero="1.11" titol="Documentar configuració i proves" contingut=section_point_1_11 %}

  {% capture section_point_1_12 %}
<h4>1.12.1. Objectiu</h4>
<p>Consolidar el flux complet: FormBuilder, validadors, vinculació template, missatges d'error, enviament.</p>
<h4>1.12.2. Passos</h4>
<p><strong>1. Generar component (5'):</strong></p>
{% capture code_435 %}ng generate component components/formulari-element --standalone{% endcapture %}
{% include code-block.html lang="bash" code=code_435 %}
<p><strong>2. Configurar FormBuilder (10'):</strong></p>
{% capture code_436 %}import { Component, inject } from '@angular/core';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-formulari-element',
  standalone: true,
  imports: [ReactiveFormsModule, CommonModule],
  templateUrl: './formulari-element.component.html',
  styleUrls: ['./formulari-element.component.scss']
})
export class FormulariElementComponent {
  private readonly fb = inject(FormBuilder);
  formulari = this.fb.group({
    titol: ['', [Validators.required, Validators.minLength(4)]],
    categoria: ['', Validators.required],
    valoracio: [0, [Validators.required, Validators.min(0), Validators.max(5)]],
    descripcio: ['', Validators.maxLength(200)]
  });
  get titolControl() {
    return this.formulari.get('titol');
  }
  onSubmit(): void {
    this.formulari.markAllAsTouched();
    if (this.formulari.invalid) {
      console.warn('Formulari invàlid');
      return;
    }
    console.log('Dades:', this.formulari.value);
    this.formulari.reset();
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_436 %}
<p><strong>3. Crear plantilla (15'):</strong></p>
{% capture code_437 %}<form [formGroup]="formulari" (ngSubmit)="onSubmit()">
<label>
Títol
<input type="text" formControlName="titol">
</label>
<div *ngIf="titolControl?.touched && titolControl?.invalid" class="error">
<p *ngIf="titolControl?.hasError('required')">El títol és obligatori.</p>
<p *ngIf="titolControl?.hasError('minlength')">Cal almenys 4 caràcters.</p>
</div>
<label>
Categoria
<select formControlName="categoria">
<option value="">Selecciona...</option>
<option value="UI">Components UI</option>
<option value="Backend">Backend</option>
</select>
</label>
<label>
Valoració (0-5)
<input type="number" formControlName="valoracio">
</label>
<label>
Descripció
<textarea formControlName="descripcio"></textarea>
</label>
<button type="submit" [disabled]="formulari.invalid">Guardar</button>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_437 %}
<p><strong>4. Afegir estils (10'):</strong></p>
{% capture code_438 %}form {
  max-width: 600px;
  margin: 2rem auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
label {
  display: block;
  margin-bottom: 1rem;
  font-weight: 500;
  input, select, textarea {
    display: block;
    width: 100%;
    margin-top: 0.25rem;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-family: inherit;
    &.ng-touched.ng-invalid {
      border-color: #c33;
      background: #fff5f5;
    }
  }
}
.error {
  background: #fee;
  border: 1px solid #fcc;
  padding: 0.5rem;
  border-radius: 4px;
  margin-top: 0.25rem;
  p {
    margin: 0.25rem 0;
    color: #c33;
    font-size: 0.875rem;
  }
}
button[type="submit"] {
  padding: 0.75rem 2rem;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  cursor: pointer;
  &:hover:not(:disabled) {
    background: #2980b9;
  }
  &:disabled {
    background: #bbb;
    cursor: not-allowed;
  }
}{% endcapture %}
{% include code-block.html lang="scss" code=code_438 %}
<p><strong>5. Provar funcionalitat (10'):</strong></p>
{% capture code_439 %}ng serve --port 4300{% endcapture %}
{% include code-block.html lang="bash" code=code_439 %}
<p><strong>6. Documentar (10'):</strong></p>
{% capture code_440 %}# Actualitzar docs/formularis.md amb configuració
# Afegir taula de camps i validacions
# Registrar proves realitzades{% endcapture %}
{% include code-block.html lang="bash" code=code_440 %}
<p><strong>7. Executar tests (5'):</strong></p>
{% capture code_441 %}npm run lint
npm run test -- --watch=false{% endcapture %}
{% include code-block.html lang="bash" code=code_441 %}
<h4>1.12.3. Resultat esperat</h4>
<p>Formulari reactiu complet funcional amb validacions, missatges d'error contextuals, gestió d'enviament i documentació actualitzada.</p>
  {% endcapture %}
  {% include section-point.html numero="1.12" titol="Mini exemple pràctic" contingut=section_point_1_12 %}

  {% capture section_point_1_13 %}
<h4>1.13.1. Taula de resolució</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Solució Windows</th>
<th>Solució macOS/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>Formulari sempre invàlid</td>
<td>Comprovar amb <code>console.log(formulari.value, formulari.errors)</code></td>
<td>Comprovar amb <code>console.log(formulari.value, formulari.errors)</code></td>
</tr>
<tr>
<td>Missatges d'error no apareixen</td>
<td>Verificar sintaxi: <code>control?.touched && control?.invalid</code></td>
<td>Verificar sintaxi: <code>control?.touched && control?.invalid</code></td>
</tr>
<tr>
<td>Inputs no responen</td>
<td>Afegir <code>imports: [ReactiveFormsModule]</code> al component</td>
<td>Afegir <code>imports: [ReactiveFormsModule]</code> al component</td>
</tr>
<tr>
<td><code>.value</code> retorna undefined</td>
<td>Verificar nom exacte a FormGroup i formControlName</td>
<td>Verificar nom exacte a FormGroup i formControlName</td>
</tr>
<tr>
<td>Botó submit no es deshabilita</td>
<td>Usar <code>[disabled]="formulari.invalid"</code></td>
<td>Usar <code>[disabled]="formulari.invalid"</code></td>
</tr>
<tr>
<td><code>Cannot find module '@angular/forms'</code></td>
<td><code>npm install @angular/forms --save</code></td>
<td><code>npm install @angular/forms --save</code></td>
</tr>
<tr>
<td><code>FormBuilder is not defined</code></td>
<td><code>import { FormBuilder } from '@angular/forms';</code></td>
<td><code>import { FormBuilder } from '@angular/forms';</code></td>
</tr>
<tr>
<td><code>Can't bind to 'formGroup'</code></td>
<td>Afegir a <code>imports: [ReactiveFormsModule]</code></td>
<td>Afegir a <code>imports: [ReactiveFormsModule]</code></td>
</tr>
<tr>
<td><code>No provider for FormBuilder</code></td>
<td><code>private fb = inject(FormBuilder)</code> o constructor</td>
<td><code>private fb = inject(FormBuilder)</code> o constructor</td>
</tr>
<tr>
<td><code>formControlName must be used with parent formGroup</code></td>
<td>Assegurar <code>&lt;form [formGroup]="formulari"&gt;</code> envolta inputs</td>
<td>Assegurar <code>&lt;form [formGroup]="formulari"&gt;</code> envolta inputs</td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="1.13" titol="Resolució de problemes (Win/macOS/Linux)" contingut=section_point_1_13 %}

  {% capture section_point_1_14 %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en formularis Angular. <strong>Context:</strong> Estic aprenent a usar formularis reactius per primera vegada. <strong>Tasca:</strong> Compara en 5 punts clau formularis template-driven i formularis reactius a Angular, incloent casos d'ús recomanats per cada enfocament amb exemples concrets. <strong>Format:</strong> Taula comparativa amb columnes: Característica, Template-driven, Reactius, Quan usar cadascun." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Dissenyador de formularis Angular. <strong>Context:</strong> Necessito crear un formulari d'usuari complet amb validacions. <strong>Tasca:</strong> Genera una taula amb camps típics d'un formulari d'usuari (nom, email, telèfon, adreça completa) amb validacions Angular adequades i missatges d'error contextuals en català per cada cas d'error possible. <strong>Format:</strong> Taula amb columnes: Camp, Validacions aplicades, Missatge d'error per cada validador." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de validacions dinàmiques. <strong>Context:</strong> Estic implementant un formulari on alguns camps canvien de validacions segons el valor d'altres camps. <strong>Tasca:</strong> Explica detalladament amb codi complet com implementar validació dinàmica: si el camp 'tipus' és 'empresa', el camp 'NIF' passa a ser obligatori amb pattern específic; si és 'particular', el 'DNI' és obligatori. Inclou gestió amb valueChanges i setValidators. <strong>Format:</strong> Exemple de codi TypeScript comentat pas a pas." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en FormBuilder. <strong>Context:</strong> Necessito veure un exemple complet i realista de formulari reactiu. <strong>Tasca:</strong> Crea un exemple complet de FormBuilder amb 8 camps diferents utilitzant TOTS els validadors integrats disponibles (required, email, pattern, min, max, minLength, maxLength) aplicats de manera realista. Inclou camp text, email, telèfon, edat, descripció, checkbox, radio i select. <strong>Format:</strong> Codi TypeScript amb comentaris explicatius per cada validador." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Especialista en UX de formularis. <strong>Context:</strong> Vull implementar la millor experiència d'usuari en l'enviament de formularis reactius. <strong>Tasca:</strong> Descriu tres estratègies diferents per gestionar l'enviament de formularis reactius: 1) Validació prèvia amb markAllAsTouched, 2) Deshabilitar formulari durant enviament amb disable/enable, i 3) Feedback visual d'errors progressiu. Per cada estratègia proporciona codi complet, avantatges, inconvenients i millors pràctiques. <strong>Format:</strong> Guia amb seccions separades per cada estratègia amb exemples de codi." %}
  {% endcapture %}
  {% include section-point.html numero="1.14" titol="Prompts d'IA" contingut=section_point_1_14 %}

  {% capture section_point_1_15 %}
<h4>Conceptes teòrics</h4>
{% include checklist.html elements="Comprenc la diferència entre formularis template-driven i reactius|Entenc el paper de FormGroup, FormControl i FormBuilder|Sé quan usar validadors síncrons vs asíncrons|Comprenc el flux unidireccional TypeScript → Template" %}
<h4>Habilitats pràctiques</h4>
{% capture checklist_practiques %}Puc crear FormGroup manualment amb new FormGroup()|Sé usar FormBuilder per sintaxi simplificada fb.group({})|Puc aplicar múltiples validadors integrats a un FormControl|Sé vincular FormGroup a template amb [formGroup] i formControlName|Puc crear getters per simplificar accés a controls des del template|Sé mostrar missatges d'error contextuals amb .hasError()|Puc gestionar enviament amb validació prèvia i markAllAsTouched()|Sé deshabilitar/habilitar formularis durant enviament amb disable/enable{% endcapture %}
{% include checklist.html elements=checklist_practiques %}
<h4>Resolució de problemes</h4>
{% include checklist.html elements="Sé diagnosticar per què un formulari està sempre invàlid|Puc solucionar errors d'importació de ReactiveFormsModule|Entenc com depurar validacions que no funcionen correctament" %}
  {% endcapture %}
  {% include section-point.html numero="1.15" titol="Autoavaluació" contingut=section_point_1_15 %}

  {% capture section_point_1_16 %}
<p>
Disposeu d'un formulari reactiu completament funcional amb control programàtic des de TypeScript, validacions integrades i missatges d'error contextuals que milloren l'experiència d'usuari. El projecte inclou FormBuilder configurat amb servei injectat per crear formularis amb sintaxi concisa reduint codi repetitiu i millorant llegibilitat, validadors integrats aplicats combinant múltiples validadors (required, minLength, maxLength, min, max) per assegurar qualitat de dades abans d'enviar, vinculació template reactiva amb plantilla HTML connectada a FormGroup mitjançant [formGroup] i formControlName amb sincronització automàtica bidireccional, missatges d'error contextuals proporcionant feedback visual només quan l'usuari ha tocat els camps (.touched) amb missatges específics segons tipus d'error (.hasError), gestió d'enviament robusta amb validació prèvia (.invalid), marcar camps (.markAllAsTouched) i deshabilitar durant enviament (.disable), i documentació completa amb taula de camps amb validacions i missatges, decisions de disseny registrades i comparativa template-driven vs reactius documentada. La base de formularis reactius establerta serveix com a fonament per funcionalitats avançades a la Lectura 3.3.2 incloent validacions personalitzades (custom validators), validacions asíncrones (consultar API), validacions dinàmiques avançades i FormArray per llistes dinàmiques.
</p>
  {% endcapture %}
  {% include section-point.html numero="1.16" titol="Síntesi" contingut=section_point_1_16 %}

  {% capture section_point_1_17 %}
{% include definicio.html terme="FormGroup" definicio="Contenidor de múltiples FormControls relacionats que agrupa camps d'un formulari amb sintaxi <code>fb.group({ camp: [...] })</code>." %}
{% include definicio.html terme="FormControl" definicio="Control individual amb valor i validadors que representa un camp únic del formulari amb sintaxi <code>new FormControl('', Validators.required)</code>." %}
{% include definicio.html terme="FormBuilder" definicio="Servei per crear FormGroups amb sintaxi simplificada <code>fb.group(...)</code> reduint repetició de codi." %}
{% include definicio.html terme="Validators" definicio="Classe amb validadors integrats (required, minLength, maxLength, min, max, email, pattern) per aplicar validacions comunes." %}
{% include definicio.html terme="valueChanges" definicio="Observable que emet cada canvi de valor d'un control amb sintaxi <code>control.valueChanges.subscribe(...)</code>." %}
{% include definicio.html terme="statusChanges" definicio="Observable que emet cada canvi d'estat de validació amb sintaxi <code>control.statusChanges.subscribe(...)</code>." %}
{% include definicio.html terme="[formGroup]" definicio="Directiva per vincular FormGroup al <code>&lt;form&gt;</code> al template HTML." %}
{% include definicio.html terme="formControlName" definicio="Directiva per vincular input a un FormControl específic dins del FormGroup." %}
{% include definicio.html terme="ReactiveFormsModule" definicio="Mòdul Angular obligatori per usar formularis reactius que s'ha d'importar al component standalone." %}
{% include definicio.html terme=".touched" definicio="Propietat booleana que indica si l'usuari ha tocat (focus + blur) el camp del formulari." %}
{% include definicio.html terme=".invalid" definicio="Propietat booleana que indica si el camp no compleix les validacions aplicades." %}
{% include definicio.html terme=".hasError()" definicio="Mètode per comprovar error específic amb sintaxi <code>control?.hasError('required')</code>." %}
{% include definicio.html terme=".setValue()" definicio="Mètode per establir TOTS els valors del formulari requerint objecte complet." %}
{% include definicio.html terme=".patchValue()" definicio="Mètode per establir valors PARCIALS del formulari permetent actualitzar només alguns camps." %}
{% include definicio.html terme=".reset()" definicio="Mètode per resetear formulari a valors inicials netejant dades i estat de validació." %}
{% include definicio.html terme=".markAllAsTouched()" definicio="Mètode per marcar tots els controls com a tocats mostrant tots els missatges d'error de validació." %}
{% include definicio.html terme=".disable()" definicio="Mètode per deshabilitar tots els camps del formulari impedint edició de l'usuari." %}
{% include definicio.html terme=".enable()" definicio="Mètode per habilitar tots els camps del formulari permetent edició de l'usuari després de disable." %}
  {% endcapture %}
  {% include section-point.html numero="1.17" titol="Repàs de conceptes" contingut=section_point_1_17 %}
</div>

<!-- SECCIÓ 2: Validacions personalitzades i asíncrones -->
<div class="section" id="Unitat3_Bloc3_Seccio2">
  <h2 id="Unitat3_Bloc3_Seccio2">2. Validacions personalitzades i asíncrones</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=3 seccio=2 %}


  {% include objectius.html llista="Crear validadors personalitzats síncrons per implementar regles de negoci específiques que els validadors integrats no cobreixen (formats interns, dependències entre camps, rangs personalitzats)|Implementar validacions asíncrones que consulten fonts externes (APIs, bases de dades mock) amb indicadors visuals de validació en curs per millorar l'experiència d'usuari|Organitzar validadors en fitxers reutilitzables amb nomenclatura consistent, documentant la política de validació per facilitar manteniment i escalabilitat" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 1</strong> — Defineix models de dades i estructures adequades al cas d'ús." %}

  {% capture section_point_2_1 %}
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Lectura 3.3.1 completa:</strong> Formulari reactiu amb <code>FormBuilder</code>, validadors integrats (<code>required</code>, <code>minLength</code>, etc.) i missatges d'error contextuals funcionals</li>
<li><strong>json-server instal·lat globalment:</strong> Per crear API mock de validació asíncrona</li>
<li><strong>API mock configurada:</strong> Fitxer <code>tools/api/cataleg.json</code> amb dades de prova</li>
<li><strong>Projecte actualitzat:</strong> <code>cataleg-elements</code> amb <code>git status</code> net</li>
<li><strong>VS Code obert:</strong> Terminal integrada disponible per executar múltiples servidors</li>
</ul>
<p><strong>Verificació ràpida:</strong></p>
{% capture code_442 %}cd ~/workspace/cataleg-elements
json-server --version
# Si no està instal·lat
npm install -g json-server
# Crear estructura API mock
mkdir -p tools/api{% endcapture %}
{% include code-block.html lang="bash" code=code_442 %}
<p><strong>Crear fitxer de dades mock:</strong></p>
{% capture code_443 %}cat > tools/api/cataleg.json << 'EOF'
{
  "codisExistents": [
    "CAT-2024-001",
    "CAT-2024-002",
    "CAT-2024-003"
  ],
  "usuarisExistents": [
    "admin",
    "editor",
    "viewer"
  ]
}
EOF{% endcapture %}
{% include code-block.html lang="bash" code=code_443 %}
<p><strong>Executar ambdós servidors:</strong></p>
{% capture code_444 %}# Terminal 1: Angular
ng serve --port 4300
# Terminal 2: json-server
json-server --watch tools/api/cataleg.json --port 4301{% endcapture %}
{% include code-block.html lang="bash" code=code_444 %}
<p><strong>Punt d'autocomprovació:</strong> Ambdós servidors operatius, formulari base accessible a http://localhost:4300, API mock a http://localhost:4301/codisExistents.</p>
  {% endcapture %}
  {% include section-point.html numero="2.1" titol="Prerequisits" contingut=section_point_2_1 %}

  {% capture section_point_2_2 %}
<h4>2.2.1. Què són les validacions personalitzades</h4>
<p>Les <strong>validacions personalitzades</strong> són funcions pures que implementen regles de negoci específiques no cobertes pels validadors integrats d'Angular. Mentre <code>Validators.required</code> o <code>Validators.email</code> cobreixen casos generals, les validacions personalitzades permeten implementar formats interns de l'empresa, dependències complexes entre camps o comprovacions contra fonts externes.</p>
<p><strong>Diferència clau:</strong></p>
<ul>
<li><strong>Validadors integrats:</strong> Regles genèriques reutilitzables entre projectes (<code>email</code>, <code>minLength</code>)</li>
<li><strong>Validadors personalitzats:</strong> Regles específiques del domini (<code>codiInternValid</code>, <code>dataFinPosteriorDataInici</code>)</li>
</ul>
<h4>2.2.2. Problema sense validacions personalitzades</h4>
<p>Els validadors integrats són suficients per casos estàndard, però fallen quan hi ha requisits específics del projecte.</p>
<p><strong>Situació sense validadors personalitzats:</strong></p>
{% capture code_445 %}// component.ts - Intentant validar format intern "CAT-YYYY-NNN"
formulari = this.fb.group({
  codi: ['', [
    Validators.required,
    Validators.pattern(/^CAT-\d{4}-\d{3}$/)  // Patró complex i poc llegible
  ]],
  dataInici: ['', Validators.required],
  dataFi: ['', Validators.required]
  // NO podem validar que dataFi > dataInici amb validadors integrats
});
onSubmit(): void {
  // Validació manual al submit - tard i fràgil
  const inici = new Date(this.formulari.get('dataInici')?.value);
  const fi = new Date(this.formulari.get('dataFi')?.value);
  if (fi <= inici) {
    alert('Data fi ha de ser posterior a data inici');
    return;
  }
  // Aquesta validació no es mostra als missatges d'error del formulari
  // No es pot reutilitzar en altres formularis
  // Testing difícil (acoblat al component)
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_445 %}
{% capture code_446 %}<div *ngIf="formulari.get('codi')?.hasError('pattern')">
  Format incorrecte.
</div>
<!-- No hi ha validació reactiva per dates -->
<!-- L'usuari omple tot el formulari i descobreix l'error al final -->{% endcapture %}
{% include code-block.html lang="html" code=code_446 %}
<p><strong>Problemes que genera:</strong></p>
<p><strong>1. Validacions de negoci impossibles amb integrats</strong></p>
<p>Regles com "El camp 'pressupost' ha de ser múltiple de 100" o "El camp 'email' ha de tenir domini '@empresa.com'" no tenen validador integrat equivalent. Cal implementar lògica manual al component, dispersant validacions entre TypeScript i template. Codi difícil de mantenir quan teniu 20+ camps amb regles específiques.</p>
<p><strong>2. Dependències entre camps no validables</strong></p>
<p>Validar que "dataFi > dataInici" o "Si tipus='empresa', NIF obligatori" requereix accés a múltiples controls. Validadors integrats només veuen un FormControl. Implementar validacions manuals al <code>onSubmit()</code> genera experiència d'usuari deficient: l'usuari omple tot el formulari, clica submit i llavors descobreix errors. Frustrant i ineficient.</p>
<p><strong>3. Validacions contra API impossibles</strong></p>
<p>Comprovar si username ja existeix, verificar codi de descompte vàlid o validar IBAN contra base de dades requereix peticions HTTP asíncrones. Validadors integrats són síncrons. Implementar lògica manual amb <code>subscribe()</code> genera codi desorganitzat, subscripcions no gestionades (fuites de memòria) i feedback visual inconsistent.</p>
<p><strong>4. Missatges d'error poc informatius</strong></p>
<p><code>Validators.pattern()</code> retorna error genèric <code>{ pattern: true }</code>. Missatge "Format incorrecte" no ajuda l'usuari. Cal context: "El codi ha de tenir format CAT-YYYY-NNN (exemple: CAT-2024-001)". Sense validadors personalitzats, els missatges són genèrics i poc útils.</p>
<p><strong>5. Reutilització zero entre formularis</strong></p>
<p>Lògica de validació dispersa entre components (<code>.ts</code>), templates (<code>.html</code>) i mètodes (<code>onSubmit()</code>). Voleu el mateix format de codi en 5 formularis diferents? Cal copiar-pegar regex, lògica de validació i missatges. Manteniment caòtic: canviar format requereix modificar 5 components.</p>
<h4>2.2.3. Solució amb validacions personalitzades</h4>
<p>Angular permet crear funcions validators reutilitzables que encapsulen regles de negoci.</p>
<p><strong>Situació amb validadors personalitzats:</strong></p>
{% capture code_447 %}// src/app/validacions/element.validators.ts - Validadors reutilitzables
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
/**
 * Valida format de codi intern: CAT-YYYY-NNN
 * Exemple vàlid: CAT-2024-001
 */
export function codiInternValid(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const valor = String(control.value || '').trim();
    if (!valor) return null; // Si buit, required s'encarrega
    const pattern = /^CAT-\d{4}-\d{3}$/;
    if (!pattern.test(valor)) {
      return {
        codiInternInvalid: {
          formatEsperat: 'CAT-YYYY-NNN',
          exemple: 'CAT-2024-001',
          valorRebut: valor
        }
      };
    }
    return null;
  };
}
/**
 * Valida que dataFi sigui posterior a dataInici
 * Ús: aplicar a FormGroup, no a FormControl individual
 */
export function dataFiPosteriorDataInici(): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const inici = group.get('dataInici')?.value;
    const fi = group.get('dataFi')?.value;
    if (!inici || !fi) return null; // Required s'encarrega
    const dataInici = new Date(inici);
    const dataFi = new Date(fi);
    if (dataFi <= dataInici) {
      return {
        dataFiNoPosteriror: {
          dataInici: inici,
          dataFi: fi,
          missatge: 'La data de finalització ha de ser posterior a la data d\'inici'
        }
      };
    }
    return null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_447 %}
{% capture code_448 %}// component.ts - Aplicar validadors personalitzats
import { codiInternValid, dataFiPosteriorDataInici } from '../../validacions/element.validators';
formulari = this.fb.group({
  codi: ['', [Validators.required, codiInternValid()]],
  dataInici: ['', Validators.required],
  dataFi: ['', Validators.required]
}, {
  validators: [dataFiPosteriorDataInici()]  // Validador a nivell de grup
});
get codiControl() {
  return this.formulari.get('codi');
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_448 %}
{% capture code_449 %}{% raw %}<label>
  Codi intern
  <input type="text" formControlName="codi">
</label>
<div *ngIf="codiControl?.touched && codiControl?.invalid" class="error">
  <p *ngIf="codiControl?.hasError('required')">
    El codi és obligatori.
  </p>
  <p *ngIf="codiControl?.hasError('codiInternInvalid')">
    El codi ha de tenir format {{ codiControl?.errors?.['codiInternInvalid'].formatEsperat }}.
    Exemple: {{ codiControl?.errors?.['codiInternInvalid'].exemple }}.
  </p>
</div>
<!-- Validació de grup -->
<div *ngIf="formulari.hasError('dataFiNoPosteriror') && formulari.get('dataFi')?.touched" class="error">
  <p>{{ formulari.errors?.['dataFiNoPosteriror'].missatge }}</p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_449 %}
<p><strong>Validador asíncron per comprovar disponibilitat:</strong></p>
{% capture code_450 %}// element.validators.ts - Validador asíncron
import { HttpClient } from '@angular/common/http';
import { Observable, of, timer } from 'rxjs';
import { map, switchMap, catchError } from 'rxjs/operators';
/**
 * Valida que el codi no existeixi ja a la base de dades
 * Retorna Observable per permetre validació asíncrona
 */
export function codiDisponible(http: HttpClient, apiUrl: string): ValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    const valor = String(control.value || '').trim();
    // Si buit o format incorrecte, altres validadors s'encarreguen
    if (!valor || !/^CAT-\d{4}-\d{3}$/.test(valor)) {
      return of(null);
    }
    // Debounce de 500ms per no saturar API
    return timer(500).pipe(
      switchMap(() =>
        http.get<string[]>(`${apiUrl}/codisExistents`).pipe(
          map(codis => {
            const existeix = codis.includes(valor);
            return existeix ? { codiDuplicat: { valor } } : null;
          }),
          catchError(() => of(null))  // Si error API, no bloquejar formulari
        )
      )
    );
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_450 %}
{% capture code_451 %}// component.ts - Aplicar validador asíncron
import { HttpClient } from '@angular/common/http';
import { codiDisponible } from '../../validacions/element.validators';
constructor(private readonly fb: FormBuilder, private readonly http: HttpClient) {}
formulari = this.fb.group({
  codi: ['',
    [Validators.required, codiInternValid()],  // Validadors síncrons
    [codiDisponible(this.http, 'http://localhost:4301')]  // Validadors asíncrons
  ]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_451 %}
{% capture code_452 %}{% raw %}<label>
  Codi intern
  <input type="text" formControlName="codi">
</label>
<!-- Indicador durant validació asíncrona -->
<div *ngIf="codiControl?.pending" class="info">
  <span class="spinner"></span>
  Comprovant disponibilitat del codi...
</div>
<div *ngIf="codiControl?.touched && codiControl?.invalid" class="error">
  <p *ngIf="codiControl?.hasError('codiDuplicat')">
    El codi {{ codiControl?.errors?.['codiDuplicat'].valor }} ja existeix.
    Trieu un altre.
  </p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_452 %}
<p><strong>Avantatges específics:</strong></p>
<ul>
<li><strong>Regles de negoci implementables:</strong> Qualsevol lògica de validació encapsulada en funció pura. Exemple implementat: format intern CAT-YYYY-NNN, dates interdependents, disponibilitat contra API.</li>
<li><strong>Missatges contextuals:</strong> Errors retornen objectes amb metadades. Missatge "Format CAT-YYYY-NNN (exemple: CAT-2024-001)" vs genèric "Format incorrecte". Millor experiència d'usuari.</li>
<li><strong>Reutilització total:</strong> Exportar validador, importar a qualsevol component. 1 validador <code>codiInternValid()</code> reutilitzat en 10 formularis. Canviar format: modificar 1 funció vs 10 components.</li>
<li><strong>Testing senzill:</strong> Provar funció pura sense component ni DOM. Test: <code>expect(codiInternValid()(controlMock)).toEqual({ codiInternInvalid: {...} })</code>. Tests ràpids (1-5ms), desacoblats.</li>
<li><strong>Validacions asíncrones natives:</strong> Framework suporta retornar <code>Observable&lt;ValidationErrors | null&gt;</code>. Feedback automàtic: <code>control.pending</code> durant validació, després <code>valid</code> o <code>invalid</code>. Zero gestió manual de subscripcions.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="2.2" titol="Marc conceptual" contingut=section_point_2_2 %}

  {% capture section_point_2_3 %}
<h4>2.3.1. Flux de validador síncron</h4>
{% capture code_453 %}Usuari escriu al FormControl
  ↓ .valueChanges emet
Angular executa validadors síncrons
  ↓ validador(control)
Funció pura avalua valor
  ↓ comprova condicions
Retorna ValidationErrors | null
  ↓ si error !== null
control.errors actualitzat
  ↓ control.status = 'INVALID'
Template mostra missatge d'error
  ↓ .hasError('clauError')
Usuari veu feedback immediat{% endcapture %}
{% include code-block.html lang="text" code=code_453 %}
<p><strong>Temps d'execució:</strong> &lt; 1ms (síncron)</p>
<h4>2.3.2. Flux de validador asíncron</h4>
{% capture code_454 %}Usuari escriu al FormControl
  ↓ .valueChanges emet
Validadors síncrons executen primer
  ↓ Si síncrons passen
control.status = 'PENDING'
  ↓ Template mostra spinner
Angular executa validadors asíncrons
  ↓ validador(control)
Funció retorna Observable
  ↓ HttpClient.get() o Promise
Espera resposta asíncrona (500ms-2s)
  ↓ Observable emet
ValidationErrors | null rebut
  ↓ control.status = 'VALID' | 'INVALID'
Template actualitza UI
  ↓ Mostra error o oculta spinner{% endcapture %}
{% include code-block.html lang="text" code=code_454 %}
<p><strong>Temps d'execució:</strong> 500ms-3s (depèn d'API)</p>
<h4>2.3.3. Jerarquia de validació</h4>
{% capture code_455 %}FormGroup (formulari)
  ├── Validadors de grup (dataFiPosteriorDataInici)
  │     ↓ Accés a múltiples FormControls
  │     ↓ Validar relacions entre camps
  │
  ├── FormControl (codi)
  │     ├── Validadors síncrons
  │     │     ├── Validators.required
  │     │     └── codiInternValid()
  │     └── Validadors asíncrons
  │           └── codiDisponible()
  │
  └── FormControl (email)
        ├── Validadors síncrons
        │     ├── Validators.required
        │     └── Validators.email
        └── Validadors asíncrons
              └── emailDisponible(){% endcapture %}
{% include code-block.html lang="text" code=code_455 %}
<h4>2.3.4. Analogia útil</h4>
<p><strong>Validador síncron = Inspector de documents immediat</strong></p>
<ul>
<li>Comprova document en 1 segon</li>
<li>Regles clares: "Format incorrecte", "Falta camp obligatori"</li>
<li>Resultat instantani: <i class="bi bi-check-circle-fill text-success"></i> OK o <i class="bi bi-x-circle-fill text-danger"></i> Error</li>
<li>Exemple: Comprovar que DNI té 9 caràcters</li>
</ul>
<p><strong>Validador asíncron = Inspector que consulta registre central</strong></p>
<ul>
<li>Triga 2-3 segons mentre consulta base de dades</li>
<li>Mentre comprova, mostra "Comprovant..."</li>
<li>Després retorna: <i class="bi bi-check-circle-fill text-success"></i> Disponible o <i class="bi bi-x-circle-fill text-danger"></i> Ja existeix</li>
<li>Exemple: Comprovar que username no està registrat</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> Validadors asíncrons només s'executen si validadors síncrons passen. Per eficiència: No té sentit comprovar disponibilitat d'username si el format és invàlid. Síncrons ràpids (&lt; 1ms) filtren errors bàsics abans de peticions costoses (500ms-2s)." %}
  {% endcapture %}
  {% include section-point.html numero="2.3" titol="Model mental" contingut=section_point_2_3 %}

  {% capture section_point_2_4 %}
<h4>2.4.1. Validadors integrats disponibles</h4>
<ul>
<li><code>Validators.required</code>, <code>minLength</code>, <code>maxLength</code></li>
<li><code>Validators.min</code>, <code>max</code> (numèrics)</li>
<li><code>Validators.email</code></li>
<li><code>Validators.pattern(regex)</code></li>
</ul>
<h4>2.4.2. Limitacions identificades</h4>
<p><strong>1. Formats específics del projecte</strong></p>
<p>Voleu validar codi intern <code>CAT-YYYY-NNN</code>? <code>Validators.pattern(/^CAT-\d{4}-\d{3}$/)</code> funciona però:</p>
<ul>
<li>Missatge d'error genèric: <code>{ pattern: true }</code></li>
<li>No indica format esperat a l'usuari</li>
<li>No reutilitzable amb nom descriptiu</li>
</ul>
<p><strong>2. Dependències entre camps</strong></p>
<p>Com validar "Data fi posterior a data inici"? Validadors integrats només veuen un FormControl. No poden comparar múltiples camps. Solució: validador personalitzat a nivell FormGroup.</p>
<p><strong>3. Regles de negoci complexes</strong></p>
<p>"Pressupost múltiple de 100€", "Email amb domini '@empresa.com'", "CIF espanyol vàlid". Cap validador integrat cobreix aquests casos. Cal crear validadors personalitzats.</p>
<p><strong>4. Validacions contra font externa</strong></p>
<p>"Username disponible?", "Codi descompte vàlid?", "IBAN existeix al banc?". Requereix petició HTTP asíncrona. Validadors integrats són síncrons.</p>
<p><strong>Exemple de limitació:</strong></p>
{% capture code_456 %}// Intentant validar amb integrats - no suficient
formulari = this.fb.group({
  email: ['', [Validators.required, Validators.email]],
  // No puc validar que sigui @empresa.com
  pressupost: [0, [Validators.required, Validators.min(100)]],
  // No puc validar que sigui múltiple de 100
  dataInici: ['', Validators.required],
  dataFi: ['', Validators.required]
  // No puc validar que dataFi > dataInici
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_456 %}
{% include warning_box.html contingut="<strong>Clau:</strong> Validadors integrats cobreixen casos genèrics. Per regles específiques, cal crear validadors personalitzats." %}
  {% endcapture %}
  {% include section-point.html numero="2.4" titol="Limitacions dels validadors integrats (0-15')" contingut=section_point_2_4 %}

  {% capture section_point_2_5 %}
<h4>2.5.1. Signatura d'un validador síncron</h4>
{% capture code_457 %}type ValidatorFn = (control: AbstractControl) => ValidationErrors | null;{% endcapture %}
{% include code-block.html lang="typescript" code=code_457 %}
<h4>2.5.2. Validador bàsic</h4>
{% capture code_458 %}// src/app/validacions/element.validators.ts
import { AbstractControl, ValidationErrors } from '@angular/forms';
/**
 * Valida que el pressupost sigui múltiple de 100
 */
export function pressupostMultipleCent(control: AbstractControl): ValidationErrors | null {
  const valor = Number(control.value);
  // Si buit o no numèric, altres validadors s'encarreguen
  if (Number.isNaN(valor) || valor === 0) {
    return null;
  }
  // Comprovar si és múltiple de 100
  if (valor % 100 !== 0) {
    return {
      noMultipleCent: {
        valorRebut: valor,
        multiplesPropers: [
          Math.floor(valor / 100) * 100,
          Math.ceil(valor / 100) * 100
        ]
      }
    };
  }
  return null;  // Validació passa
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_458 %}
<h4>2.5.3. Aplicar al formulari</h4>
{% capture code_459 %}// component.ts
import { pressupostMultipleCent } from '../../validacions/element.validators';
formulari = this.fb.group({
  pressupost: [0, [
    Validators.required,
    Validators.min(100),
    pressupostMultipleCent  // Validador personalitzat
  ]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_459 %}
<h4>2.5.4. Mostrar missatge</h4>
{% capture code_460 %}{% raw %}<div *ngIf="pressupostControl?.touched && pressupostControl?.invalid" class="error">
  <p *ngIf="pressupostControl?.hasError('noMultipleCent')">
    El pressupost ha de ser múltiple de 100€.
    Valors propers:
    {{ pressupostControl?.errors?.['noMultipleCent'].multiplesPropers[0] }}€ o
    {{ pressupostControl?.errors?.['noMultipleCent'].multiplesPropers[1] }}€.
  </p>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_460 %}
<h4>2.5.5. Validador per format específic</h4>
{% capture code_461 %}/**
 * Valida format codi intern: CAT-YYYY-NNN
 */
export function codiInternValid(control: AbstractControl): ValidationErrors | null {
  const valor = String(control.value || '').trim();
  if (!valor) return null;  // Required s'encarrega
  const pattern = /^CAT-\d{4}-\d{3}$/;
  if (!pattern.test(valor)) {
    return {
      codiInternInvalid: {
        formatEsperat: 'CAT-YYYY-NNN',
        exemple: 'CAT-2024-001',
        valorRebut: valor
      }
    };
  }
  return null;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_461 %}
{% include info_box.html contingut="<strong>Clau:</strong> Validadors personalitzats són funcions que retornen <code>ValidationErrors | null</code>. Retornar objectes amb metadades per missatges contextuals." %}
  {% endcapture %}
  {% include section-point.html numero="2.5" titol="Crear validadors síncrons personalitzats (15-30')" contingut=section_point_2_5 %}

  {% capture section_point_2_6 %}
<h4>2.6.1. Problema amb validadors sense paràmetres</h4>
{% capture code_462 %}// Validador específic, no reutilitzable
export function pressupostMultipleCent(control: AbstractControl): ValidationErrors | null {
  return control.value % 100 === 0 ? null : { error: true };
}
// Cal crear un validador per cada múltiple?
export function pressupostMultipleCinquanta(...) { ... }
export function pressupostMultipleDeu(...) { ... }{% endcapture %}
{% include code-block.html lang="typescript" code=code_462 %}
<h4>2.6.2. Solució: validador amb paràmetres (factory pattern)</h4>
{% capture code_463 %}/**
 * Valida que el valor sigui múltiple d'un número
 * @param multipli - Número del qual ha de ser múltiple
 * @returns ValidatorFn
 */
export function multipliDe(multipli: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const valor = Number(control.value);
    if (Number.isNaN(valor) || valor === 0) {
      return null;
    }
    if (valor % multipli !== 0) {
      return {
        noMultipli: {
          multipli,
          valorRebut: valor,
          multiplesPropers: [
            Math.floor(valor / multipli) * multipli,
            Math.ceil(valor / multipli) * multipli
          ]
        }
      };
    }
    return null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_463 %}
<h4>2.6.3. Ús amb diferents paràmetres</h4>
{% capture code_464 %}formulari = this.fb.group({
  pressupost: [0, [multipliDe(100)]],      // Múltiple de 100
  quantitat: [0, [multipliDe(10)]],        // Múltiple de 10
  paquets: [0, [multipliDe(6)]]            // Múltiple de 6 (packs)
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_464 %}
<h4>2.6.4. Validador per paraula prohibida</h4>
{% capture code_465 %}/**
 * Valida que el text no contingui una paraula prohibida
 * @param paraula - Paraula a evitar (case-insensitive)
 */
export function senseParaulaProhibida(paraula: string): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const text = String(control.value || '').toLowerCase();
    const paraulaLower = paraula.toLowerCase();
    if (text.includes(paraulaLower)) {
      return {
        paraulaProhibida: {
          paraula,
          textRebut: control.value
        }
      };
    }
    return null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_465 %}
<h4>2.6.5. Aplicar múltiples paraules prohibides</h4>
{% capture code_466 %}formulari = this.fb.group({
  titol: ['', [
    Validators.required,
    senseParaulaProhibida('spam'),
    senseParaulaProhibida('oferta'),
    senseParaulaProhibida('gratis')
  ]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_466 %}
{% include success_box.html contingut="<strong>Clau:</strong> Factory pattern (funció que retorna ValidatorFn) permet validadors configurables i reutilitzables." %}
  {% endcapture %}
  {% include section-point.html numero="2.6" titol="Validadors amb paràmetres configurables (30-50')" contingut=section_point_2_6 %}

  {% capture section_point_2_7 %}
<h4>2.7.1. Diferència síncron vs asíncron</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Aspecte</th>
<th>Síncron</th>
<th>Asíncron</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execució</td>
<td>Immediata (&lt; 1ms)</td>
<td>Diferida (500ms-3s)</td>
</tr>
<tr>
<td>Retorn</td>
<td><code>ValidationErrors | null</code></td>
<td><code>Observable&lt;ValidationErrors | null&gt;</code></td>
</tr>
<tr>
<td>Casos d'ús</td>
<td>Formats, rangs, càlculs</td>
<td>API, DB, serveis externs</td>
</tr>
<tr>
<td>Estat</td>
<td><code>valid</code> o <code>invalid</code></td>
<td><code>pending</code> → <code>valid</code> | <code>invalid</code></td>
</tr>
<tr>
<td>Feedback UI</td>
<td>Immediat</td>
<td>Spinner durant validació</td>
</tr>
</tbody>
</table>
<h4>2.7.2. Per què necessitem validacions asíncrones</h4>
<p><strong>1. Comprovar disponibilitat</strong></p>
<p>Username, email, codi intern ja existeixen? Cal consultar base de dades o API.</p>
<p><strong>2. Validar amb servei extern</strong></p>
<p>IBAN vàlid segons banc, CIF/NIF vàlid segons Agencia Tributaria, codi postal existeix segons servei postal.</p>
<p><strong>3. Regles de negoci asíncrones</strong></p>
<p>Descompte vàlid?, producte disponible en stock?, límit de crèdit suficient?</p>
<h4>2.7.3. Cas d'ús pràctic: comprovar codi disponible</h4>
<p><strong>Context:</strong> Aplicació permet crear elements amb codi únic. Cal validar que el codi no existeixi ja a la base de dades abans de permetre crear l'element.</p>
<p><strong>Flux desitjat:</strong></p>
<ol>
<li>Usuari escriu codi: <code>CAT-2024-001</code></li>
<li>Template mostra: "Comprovant disponibilitat..." (spinner)</li>
<li>Validador consulta API: <code>GET /codisExistents</code></li>
<li>API respon: <code>["CAT-2024-001", "CAT-2024-002"]</code></li>
<li>Validador comprova: codi existeix a la llista</li>
<li>Retorna error: <code>{ codiDuplicat: true }</code></li>
<li>Template mostra: "Aquest codi ja existeix. Trieu un altre."</li>
</ol>
<h4>2.7.4. Estats del control durant validació</h4>
{% capture code_467 %}Usuari escriu → control.status = 'PENDING'
                ↓
             Consulta API (1-2s)
                ↓
    API respon → control.status = 'VALID' o 'INVALID'{% endcapture %}
{% include code-block.html lang="text" code=code_467 %}
<h4>2.7.5. Indicador visual</h4>
{% capture code_468 %}<div *ngIf="codiControl?.pending">
  Comprovant disponibilitat...
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_468 %}
{% include info_box.html contingut="<strong>Clau:</strong> Validacions asíncrones retornen Observable, Angular gestiona estats <code>pending</code> → <code>valid</code>/<code>invalid</code> automàticament." %}
  {% endcapture %}
  {% include section-point.html numero="2.7" titol="Introduir validacions asíncrones: concepte i cas d'ús (50-70')" contingut=section_point_2_7 %}

  {% capture section_point_2_8 %}
<h4>2.8.1. Preparar API mock</h4>
{% capture code_469 %}{
  "codisExistents": [
    "CAT-2024-001",
    "CAT-2024-002",
    "CAT-2024-003"
  ]
}{% endcapture %}
{% include code-block.html lang="json" code=code_469 %}
{% capture code_470 %}json-server --watch tools/api/cataleg.json --port 4301
# Verificar
curl http://localhost:4301/codisExistents{% endcapture %}
{% include code-block.html lang="bash" code=code_470 %}
<h4>2.8.2. Validador asíncron complet</h4>
{% capture code_471 %}// src/app/validacions/element.validators.ts
import { HttpClient } from '@angular/common/http';
import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of, timer } from 'rxjs';
import { map, switchMap, catchError } from 'rxjs/operators';
/**
 * Valida que el codi no existeixi ja a la base de dades
 * @param http - HttpClient per fer peticions
 * @param apiUrl - URL base de l'API
 * @returns AsyncValidatorFn
 */
export function codiDisponible(http: HttpClient, apiUrl: string): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    const valor = String(control.value || '').trim();
    // Si buit o format incorrecte, altres validadors s'encarreguen
    if (!valor || !/^CAT-\d{4}-\d{3}$/.test(valor)) {
      return of(null);  // Observable que emet null immediatament
    }
    // Debounce de 500ms: esperar que l'usuari deixi d'escriure
    return timer(500).pipe(
      switchMap(() =>
        http.get<string[]>(`${apiUrl}/codisExistents`).pipe(
          map(codis => {
            const existeix = codis.includes(valor);
            console.log(`[codiDisponible] Valor: ${valor}, Existeix: ${existeix}`);
            return existeix ? {
              codiDuplicat: {
                valor,
                missatge: 'Aquest codi ja existeix a la base de dades'
              }
            } : null;
          }),
          catchError(error => {
            console.error('[codiDisponible] Error API:', error);
            // Si error API, no bloquejar formulari
            return of(null);
          })
        )
      )
    );
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_471 %}
<h4>2.8.3. Aplicar al formulari</h4>
{% capture code_472 %}// component.ts
import { HttpClient } from '@angular/common/http';
import { codiDisponible, codiInternValid } from '../../validacions/element.validators';
constructor(
  private readonly fb: FormBuilder,
  private readonly http: HttpClient
) {}
formulari = this.fb.group({
  codi: ['',
    // Validadors síncrons (primer array)
    [Validators.required, codiInternValid],
    // Validadors asíncrons (segon array)
    [codiDisponible(this.http, 'http://localhost:4301')]
  ]
});
get codiControl() {
  return this.formulari.get('codi');
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_472 %}
<h4>2.8.4. Explicació del flux</h4>
<ol>
<li><strong>Usuari escriu:</strong> <code>CAT-2024-001</code></li>
<li><strong>Validadors síncrons executen:</strong> <code>required</code> <i class="bi bi-check-circle-fill text-success"></i>, <code>codiInternValid</code> <i class="bi bi-check-circle-fill text-success"></i></li>
<li><strong>Control passa a PENDING:</strong> <code>control.status = 'PENDING'</code></li>
<li><strong>timer(500):</strong> Espera 500ms (debounce)</li>
<li><strong>HttpClient.get():</strong> Consulta API <code>GET /codisExistents</code></li>
<li><strong>map():</strong> Comprova si valor existeix a l'array</li>
<li><strong>Retorna error o null:</strong> <code>{ codiDuplicat: {...} }</code> si existeix, <code>null</code> si disponible</li>
<li><strong>Control actualitza estat:</strong> <code>VALID</code> o <code>INVALID</code></li>
</ol>
{% include success_box.html contingut="<strong>Clau:</strong> <code>timer()</code> per debounce, <code>switchMap()</code> per cancel·lar peticions anteriors, <code>catchError()</code> per no bloquejar si API falla." %}
  {% endcapture %}
  {% include section-point.html numero="2.8" titol="Implementar validador asíncron amb API mock (70-90')" contingut=section_point_2_8 %}

  {% capture section_point_2_9 %}
<h4>2.9.1. Estats del FormControl</h4>
{% capture code_473 %}control.status: 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED'
control.pending: boolean  // true durant validació asíncrona{% endcapture %}
{% include code-block.html lang="typescript" code=code_473 %}
<h4>2.9.2. Template amb indicador pending</h4>
{% capture code_474 %}{% raw %}<label>
  Codi intern
  <input
    type="text"
    formControlName="codi"
    placeholder="CAT-2024-001">
</label>
<!-- Indicador durant validació asíncrona -->
<div *ngIf="codiControl?.pending" class="info">
  <span class="spinner"></span>
  <span>Comprovant disponibilitat del codi...</span>
</div>
<!-- Missatges d'error -->
<div *ngIf="codiControl?.touched && codiControl?.invalid" class="error">
  <p *ngIf="codiControl?.hasError('required')">
    El codi és obligatori.
  </p>
  <p *ngIf="codiControl?.hasError('codiInternInvalid')">
    Format incorrecte. Esperat:
    {{ codiControl?.errors?.['codiInternInvalid'].formatEsperat }}
  </p>
  <p *ngIf="codiControl?.hasError('codiDuplicat')">
    {{ codiControl?.errors?.['codiDuplicat'].missatge }}
  </p>
</div>
<!-- Indicador d'èxit -->
<div *ngIf="codiControl?.valid && codiControl?.value" class="success">
  <span><i class="bi bi-check-circle-fill"></i></span> Codi disponible
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_474 %}
<h4>2.9.3. Estils per indicadors</h4>
{% capture code_475 %}.info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  background: #e3f2fd;
  border: 1px solid #90caf9;
  border-radius: 4px;
  color: #1976d2;
  font-size: 0.875rem;
  margin-top: 0.25rem;
  .spinner {
    display: inline-block;
    width: 1rem;
    height: 1rem;
    border: 2px solid #90caf9;
    border-top-color: #1976d2;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
}
.success {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  background: #e8f5e9;
  border: 1px solid #81c784;
  border-radius: 4px;
  color: #388e3c;
  font-size: 0.875rem;
  margin-top: 0.25rem;
  span {
    font-weight: bold;
  }
}
@keyframes spin {
  to { transform: rotate(360deg); }
}{% endcapture %}
{% include code-block.html lang="scss" code=code_475 %}
<h4>2.9.4. Deshabilitar botó durant pending</h4>
{% capture code_476 %}{% raw %}<button
  type="submit"
  [disabled]="formulari.invalid || formulari.pending">
  {{ formulari.pending ? 'Validant...' : 'Guardar' }}
</button>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_476 %}
{% include info_box.html contingut="<strong>Clau:</strong> Usar <code>.pending</code> per mostrar spinners durant validació. Deshabilitar submit fins que totes les validacions compleixin." %}
  {% endcapture %}
  {% include section-point.html numero="2.9" titol="Mostrar indicadors de validació pending (90-105')" contingut=section_point_2_9 %}

  {% capture section_point_2_10 %}
<h4>2.10.1. Estructura de directoris</h4>
{% capture code_477 %}src/app/
├── validacions/
│   ├── element.validators.ts       # Validadors específics d'elements
│   ├── usuari.validators.ts        # Validadors d'usuaris
│   ├── comuns.validators.ts        # Validadors genèrics reutilitzables
│   └── index.ts                    # Barrel export{% endcapture %}
{% include code-block.html lang="text" code=code_477 %}
<h4>2.10.2. Validadors comuns reutilitzables</h4>
{% capture code_478 %}// src/app/validacions/comuns.validators.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
/**
 * Valida que el valor sigui múltiple d'un número
 */
export function multipliDe(multipli: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const valor = Number(control.value);
    if (Number.isNaN(valor) || valor === 0) return null;
    return valor % multipli === 0 ? null : {
      noMultipli: { multipli, valorRebut: valor }
    };
  };
}
/**
 * Valida que el text no contingui paraula prohibida
 */
export function senseParaula(paraula: string): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const text = String(control.value || '').toLowerCase();
    return text.includes(paraula.toLowerCase()) ?
      { paraulaProhibida: { paraula } } : null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_478 %}
<h4>2.10.3. Validadors específics d'elements</h4>
{% capture code_479 %}// src/app/validacions/element.validators.ts
import { AbstractControl, ValidationErrors, ValidatorFn, AsyncValidatorFn } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { Observable, of, timer } from 'rxjs';
import { map, switchMap, catchError } from 'rxjs/operators';
/**
 * Valida format de codi intern d'element: CAT-YYYY-NNN
 */
export function codiElementValid(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const valor = String(control.value || '').trim();
    if (!valor) return null;
    const pattern = /^CAT-\d{4}-\d{3}$/;
    return pattern.test(valor) ? null : {
      codiInternInvalid: {
        formatEsperat: 'CAT-YYYY-NNN',
        exemple: 'CAT-2024-001'
      }
    };
  };
}
/**
 * Valida disponibilitat de codi d'element contra API
 */
export function codiElementDisponible(http: HttpClient, apiUrl: string): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    const valor = String(control.value || '').trim();
    if (!valor || !/^CAT-\d{4}-\d{3}$/.test(valor)) {
      return of(null);
    }
    return timer(500).pipe(
      switchMap(() =>
        http.get<string[]>(`${apiUrl}/codisExistents`).pipe(
          map(codis => codis.includes(valor) ? { codiDuplicat: { valor } } : null),
          catchError(() => of(null))
        )
      )
    );
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_479 %}
<h4>2.10.4. Barrel export per imports nets</h4>
{% capture code_480 %}// src/app/validacions/index.ts
export * from './comuns.validators';
export * from './element.validators';
export * from './usuari.validators';{% endcapture %}
{% include code-block.html lang="typescript" code=code_480 %}
<h4>2.10.5. Imports nets al component</h4>
{% capture code_481 %}// component.ts - Import net
import {
  codiElementValid,
  codiElementDisponible,
  multipliDe
} from '../../validacions';
formulari = this.fb.group({
  codi: ['',
    [Validators.required, codiElementValid()],
    [codiElementDisponible(this.http, apiUrl)]
  ],
  pressupost: [0, [Validators.required, multipliDe(100)]]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_481 %}
{% include success_box.html contingut="<strong>Clau:</strong> Organitzar validadors per domini (element, usuari, comuns). Usar barrel exports per imports nets." %}
  {% endcapture %}
  {% include section-point.html numero="2.10" titol="Organitzar validadors en fitxers reutilitzables (105-115')" contingut=section_point_2_10 %}

  {% capture section_point_2_11 %}
<p>Actualitzeu el fitxer <code>docs/formularis.md</code> amb la documentació completa de validadors personalitzats:</p>
<h4>2.11.1. Validadors síncrons</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Validador</th>
<th>Tipus</th>
<th>Descripció</th>
<th>Exemple ús</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>codiElementValid()</code></td>
<td>Síncron</td>
<td>Format CAT-YYYY-NNN</td>
<td><code>[codiElementValid()]</code></td>
</tr>
<tr>
<td><code>multipliDe(n)</code></td>
<td>Síncron</td>
<td>Valor múltiple de n</td>
<td><code>[multipliDe(100)]</code></td>
</tr>
<tr>
<td><code>senseParaula(p)</code></td>
<td>Síncron</td>
<td>Text sense paraula p</td>
<td><code>[senseParaula('spam')]</code></td>
</tr>
</tbody>
</table>
<h4>2.11.2. Validadors asíncrons</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Validador</th>
<th>Descripció</th>
<th>Temps resposta</th>
<th>Exemple ús</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>codiElementDisponible(http, url)</code></td>
<td>Comprova codi no duplicat a API</td>
<td>500ms-2s</td>
<td><code>[codiElementDisponible(http, apiUrl)]</code></td>
</tr>
<tr>
<td><code>usernameDisponible(http, url)</code></td>
<td>Comprova username lliure</td>
<td>500ms-2s</td>
<td><code>[usernameDisponible(http, apiUrl)]</code></td>
</tr>
</tbody>
</table>
<h4>2.11.3. Missatges d'error</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Clau error</th>
<th>Missatge</th>
<th>Metadades disponibles</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>codiInternInvalid</code></td>
<td>"Format incorrecte. Esperat: CAT-YYYY-NNN"</td>
<td><code>formatEsperat</code>, <code>exemple</code>, <code>valorRebut</code></td>
</tr>
<tr>
<td><code>codiDuplicat</code></td>
<td>"Aquest codi ja existeix"</td>
<td><code>valor</code>, <code>missatge</code></td>
</tr>
<tr>
<td><code>noMultipli</code></td>
<td>"El valor ha de ser múltiple de {multipli}"</td>
<td><code>multipli</code>, <code>valorRebut</code>, <code>multiplesPropers</code></td>
</tr>
</tbody>
</table>
<h4>2.11.4. Configuració API mock</h4>
<p><strong>Endpoint:</strong> <code>http://localhost:4301</code></p>
<p><strong>Recursos:</strong></p>
<ul>
<li><code>GET /codisExistents</code> → Array de codis existents</li>
<li><code>GET /usuarisExistents</code> → Array d'usernames registrats</li>
</ul>
<p><strong>Fitxer:</strong> <code>tools/api/cataleg.json</code></p>
<p><strong>Executar:</strong></p>
{% capture code_482 %}json-server --watch tools/api/cataleg.json --port 4301{% endcapture %}
{% include code-block.html lang="bash" code=code_482 %}
{% include info_box.html contingut="<strong>Clau:</strong> Documentar validadors, missatges, configuració API i proves facilita manteniment i onboarding." %}
  {% endcapture %}
  {% include section-point.html numero="2.11" titol="Documentar política de validacions (115-120')" contingut=section_point_2_11 %}

  {% capture section_point_2_12 %}
<p>Consolideu el flux complet amb aquest mini exemple que inclou validadors síncrons, asíncrons, indicadors pending i documentació.</p>
<h4>2.12.1. Crear directori de validacions</h4>
{% capture code_483 %}mkdir -p src/app/validacions{% endcapture %}
{% include code-block.html lang="bash" code=code_483 %}
<h4>2.12.2. Configurar API mock</h4>
{% capture code_484 %}{ "codisExistents": ["CAT-2024-001", "CAT-2024-002"] }
json-server --watch tools/api/cataleg.json --port 4301{% endcapture %}
{% include code-block.html lang="bash" code=code_484 %}
<h4>2.12.3. Aplicar validadors al formulari</h4>
{% capture code_485 %}formulari = this.fb.group({
  codi: ['',
    [Validators.required, codiElementValid()],
    [codiElementDisponible(this.http, 'http://localhost:4301')]
  ],
  pressupost: [0, [multipliDe(100)]],
  dataInici: ['', Validators.required],
  dataFi: ['', Validators.required]
}, {
  validators: [dataFiPosterior()]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_485 %}
<h4>2.12.4. Implementar template amb indicadors</h4>
{% capture code_486 %}<div *ngIf="codiControl?.pending" class="info">
  <span class="spinner"></span> Comprovant...
</div>
<div *ngIf="codiControl?.touched && codiControl?.invalid" class="error">
  <p *ngIf="codiControl?.hasError('codiDuplicat')">
    Codi ja existeix
  </p>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_486 %}
<h4>2.12.5. Provar funcionalitat</h4>
{% capture code_487 %}ng serve --port 4300
# Provar: CAT-2024-001 (duplicat), CAT-2024-999 (disponible)
# Verificar spinner apareix
# Verificar missatges contextuals
npm run lint
npm run test -- --watch=false{% endcapture %}
{% include code-block.html lang="bash" code=code_487 %}
{% include success_box.html contingut="Formulari complet amb validacions síncrones i asíncrones, indicadors visuals, missatges contextuals i documentació tècnica actualitzada." %}
  {% endcapture %}
  {% include section-point.html numero="2.12" titol="Mini exemple pràctic" contingut=section_point_2_12 %}

  {% capture section_point_2_13 %}
<h4>2.13.1. Problemes transversals</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Símptoma</th>
<th>Possible causa</th>
<th>Solució ràpida</th>
</tr>
</thead>
<tbody>
<tr>
<td>Validador asíncron sempre pending</td>
<td>Observable no completa</td>
<td>Verificar que observable emet i completa amb <code>of()</code> o <code>map()</code></td>
</tr>
<tr>
<td>Missatges d'error no apareixen</td>
<td>Clau error incorrecta</td>
<td>Comprovar <code>.hasError('clauCorrecta')</code> coincideix amb el retornat</td>
</tr>
<tr>
<td>Validador asíncron no s'executa</td>
<td>Validadors síncrons fallen</td>
<td>Validadors asíncrons només executen si síncrons passen</td>
</tr>
<tr>
<td>Múltiples peticions API</td>
<td>Falta debounce</td>
<td>Afegir <code>timer(500)</code> abans de <code>switchMap()</code></td>
</tr>
<tr>
<td>Formulari bloquejat per error API</td>
<td>catchError no implementat</td>
<td>Afegir <code>.pipe(catchError(() => of(null)))</code></td>
</tr>
</tbody>
</table>
<h4>2.13.2. Errors de configuració (Win/Linux/macOS)</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Error</th>
<th>Solució Windows</th>
<th>Solució Linux/macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AsyncValidator must return Observable</code></td>
<td>Wrapejar amb <code>of()</code>: <code>return of(null)</code></td>
<td>Wrapejar amb <code>of()</code>: <code>return of(null)</code></td>
</tr>
<tr>
<td><code>json-server: command not found</code></td>
<td><code>npm install -g json-server</code></td>
<td><code>npm install -g json-server</code></td>
</tr>
<tr>
<td><code>Cannot find name 'ValidatorFn'</code></td>
<td><code>import { ValidatorFn } from '@angular/forms';</code></td>
<td><code>import { ValidatorFn } from '@angular/forms';</code></td>
</tr>
<tr>
<td><code>HttpClient not provided</code></td>
<td>Afegir a <code>app.config.ts</code>: <code>provideHttpClient()</code></td>
<td>Afegir a <code>app.config.ts</code>: <code>provideHttpClient()</code></td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="2.13" titol="Resolució de problemes (Win/macOS/Linux)" contingut=section_point_2_13 %}

  {% capture section_point_2_14 %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en validacions Angular. <strong>Context:</strong> Necessito generar validadors personalitzats per un formulari d'ecommerce. <strong>Tasca:</strong> Genera una taula amb 10 validadors personalitzats per formularis d'ecommerce (codi descompte, targeta crèdit, codi postal, etc.) amb missatges d'error contextuals. <strong>Format:</strong> Taula amb columnes: Nom validador, Règim validació, Exemple regex/lògica, Missatge error, Metadades retornades." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de validacions asíncrones. <strong>Context:</strong> Vull implementar un validador asíncron robust per comprovar disponibilitat d'email. <strong>Tasca:</strong> Explica en 10 punts com implementar un validador asíncron per comprovar disponibilitat d'email amb debounce, cancel·lació de peticions anteriors i gestió d'errors. Inclou codi TypeScript complet amb comentaris detallats. <strong>Format:</strong> Llista numerada amb exemples de codi per cada punt." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Especialista en patrons de validació. <strong>Context:</strong> Estic creant un validador de contrasenyes amb múltiples requisits. <strong>Tasca:</strong> Crea un validador personalitzat que comprovi que un camp 'password' contingui almenys 1 majúscula, 1 número i 1 caràcter especial, retornant metadades detallades per cada requisit incomplert. Mostra com usar aquestes metadades al template per feedback específic. <strong>Format:</strong> Codi TypeScript del validador + exemple template HTML amb missatges específics." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Analista de rendiment Angular. <strong>Context:</strong> Necessito entendre les diferències de rendiment entre validadors síncrons i asíncrons. <strong>Tasca:</strong> Compara validadors síncrons vs asíncrons en Angular en una taula: temps d'execució típic, casos d'ús recomanats, signatura TypeScript, gestió d'errors, millors pràctiques per optimització. Afegeix 3 exemples concrets on cal escollir entre un o altre. <strong>Format:</strong> Taula comparativa + 3 casos d'ús amb justificació." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en formularis reactius. <strong>Context:</strong> Vull veure un exemple complet de FormGroup amb validacions complexes. <strong>Tasca:</strong> Genera un exemple complet de FormGroup amb 5 camps que utilitzin validadors síncrons personalitzats, 2 validadors asíncrons i 1 validador de grup, amb template HTML complet amb indicadors pending, missatges d'error contextuals i estils SCSS. <strong>Format:</strong> 3 blocs de codi: TypeScript component, HTML template, SCSS styles." %}
  {% endcapture %}
  {% include section-point.html numero="2.14" titol="Prompts d'IA" contingut=section_point_2_14 %}

  {% capture section_point_2_15 %}
<h4>Conceptes teòrics</h4>
{% include checklist.html elements="Comprenc la diferència entre validadors integrats i personalitzats|Entenc quan usar validadors síncrons vs asíncrons|Sé què és el factory pattern per validadors amb paràmetres|Comprenc el flux pending → valid/invalid en validacions asíncrones|Entenc com retornar objectes amb metadades per missatges contextuals" %}
<h4>Habilitats pràctiques</h4>
{% capture checklist_practiques %}Puc crear validadors síncrons personalitzats amb signatura correcta|Sé implementar factory pattern per validadors amb paràmetres configurables|Puc crear validadors asíncrons que consulten APIs amb HttpClient|Sé usar timer() per debounce i switchMap() per cancel·lar peticions|Puc mostrar indicadors pending durant validacions asíncrones|Sé organitzar validadors en fitxers reutilitzables per domini|Puc aplicar validadors de grup per dependències entre camps|Sé documentar validadors amb JSDoc i taules de referència{% endcapture %}
{% include checklist.html elements=checklist_practiques %}
<h4>Resolució de problemes</h4>
{% include checklist.html elements="Sé diagnosticar per què un validador asíncron està sempre pending|Puc solucionar problemes de múltiples peticions API amb debounce|Entenc com gestionar errors API sense bloquejar formulari" %}
  {% endcapture %}
  {% include section-point.html numero="2.15" titol="Autoavaluació" contingut=section_point_2_15 %}

  {% capture section_point_2_16 %}
<p>Disposeu de <strong>validacions personalitzades completes</strong> que extenen les capacitats dels validadors integrats amb regles de negoci específiques i comprovacions asíncrones contra fonts externes. El projecte inclou validadors síncrons personalitzats com funcions reutilitzables per formats interns (CAT-YYYY-NNN), múltiples (multipliDe), paraules prohibides i dependències entre camps (dates), validadors amb paràmetres utilitzant factory pattern per configurar validadors reutilitzables en diferents contextos sense duplicar codi, validació asíncrona funcional que comprova disponibilitat de codi contra API mock amb debounce de 500ms cancel·lació de peticions anteriors amb switchMap i gestió d'errors amb catchError, indicadors pending avançats proporcionant feedback visual durant validacions asíncrones amb spinners missatges contextuals i indicadors d'èxit/error, organització mantenible amb validadors estructurats en directori dedicat amb separació per domini (comuns element usuari) i barrel exports per imports nets, i documentació tècnica completa amb taules de validadors descripcions exemples d'ús missatges d'error amb metadades configuració API mock i proves realitzades registrades a docs/formularis.md. La base de validacions personalitzades establerta serveix com a fonament per aplicar-les a estructures de formularis més complexes amb FormArray i formularis niuats.</p>
  {% endcapture %}
  {% include section-point.html numero="2.16" titol="Síntesi" contingut=section_point_2_16 %}

  {% capture section_point_2_17 %}
{% include definicio.html terme="ValidatorFn" definicio="Funció pura que rep <code>AbstractControl</code> i retorna <code>ValidationErrors | null</code> per validacions síncrones." %}
{% include definicio.html terme="AsyncValidatorFn" definicio="Funció que retorna <code>Observable&lt;ValidationErrors | null&gt;</code> per validacions contra API/DB." %}
{% include definicio.html terme="ValidationErrors" definicio="Objecte amb claus d'error i metadades: <code>{ clauError: { meta1: valor1 } }</code>." %}
{% include definicio.html terme="AbstractControl" definicio="Classe base per FormControl/FormGroup que proporciona accés a <code>.value</code>, <code>.errors</code>, <code>.parent</code>." %}
{% include definicio.html terme="Factory pattern" definicio="Funció que retorna ValidatorFn per crear validadors amb paràmetres configurables: <code>(param) => ValidatorFn</code>." %}
{% include definicio.html terme=".pending" definicio="Estat booleà durant validació asíncrona: <code>control.pending: boolean</code>." %}
{% include definicio.html terme="timer()" definicio="Operador RxJS per debounce: <code>timer(500)</code> espera 500ms abans d'executar." %}
{% include definicio.html terme="switchMap()" definicio="Operador RxJS que cancel·la peticions anteriors quan arriba nou valor." %}
{% include definicio.html terme="catchError()" definicio="Operador RxJS per gestionar errors sense bloquejar: <code>catchError(() => of(null))</code>." %}
{% include definicio.html terme="of()" definicio="Funció RxJS que crea Observable que emet valor immediatament: <code>of(null)</code>." %}
{% include definicio.html terme="Validador de grup" definicio="Validador aplicat a FormGroup per validar relacions entre múltiples camps." %}
{% include definicio.html terme="Barrel export" definicio="Fitxer <code>index.ts</code> que exporta tots els validadors: <code>export * from './validators'</code>." %}
  {% endcapture %}
  {% include section-point.html numero="2.17" titol="Repàs de conceptes" contingut=section_point_2_17 %}
</div>

<!-- SECCIÓ 3: Formularis complexos i camps dinàmics -->
<div class="section" id="Unitat3_Bloc3_Seccio3">
  <h2 id="Unitat3_Bloc3_Seccio3">3. Formularis complexos i camps dinàmics</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=3 seccio=3 %}


  {% include objectius.html llista="Construir formularis reactius amb estructures niuades (FormGroup dins FormGroup) per organitzar camps relacionats lògicament (adreça, contacte, configuració)|Utilitzar FormArray per gestionar col·leccions dinàmiques de controls que l'usuari pot afegir o eliminar en temps d'execució (telèfons, adreces, variants de producte)|Dominar les diferències entre setValue(), patchValue() i reset() per gestionar valors del formulari de forma precisa segons les necessitats de cada situació" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 1</strong> — Defineix models de dades i estructures adequades al cas d'ús." %}

  {% capture section_point_3_1 %}
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Lectures 3.3.1 i 3.3.2 completes:</strong> Formulari reactiu amb FormBuilder, validadors integrats, validadors personalitzats i asíncrons funcionals</li>
<li><strong>Conceptes consolidats:</strong> FormGroup, FormControl, Validators, validadors personalitzats</li>
<li><strong>Projecte actualitzat:</strong> <code>cataleg-elements</code> amb <code>git status</code> net</li>
<li><strong>VS Code obert:</strong> Terminal integrada disponible</li>
</ul>
<p><strong>Verificació ràpida:</strong></p>
{% capture code_488 %}cd ~/workspace/cataleg-elements
ng serve --port 4300
# Verificar formularis anteriors funcionals{% endcapture %}
{% include code-block.html lang="bash" code=code_488 %}
<p><strong>Punt d'autocomprovació:</strong> Servidor operatiu, formularis de lectures 3.3.1 i 3.3.2 accessibles i funcionals.</p>
  {% endcapture %}
  {% include section-point.html numero="3.1" titol="Prerequisits" contingut=section_point_3_1 %}

  {% capture section_point_3_2 %}
<h4>3.2.1. Què són els formularis complexos</h4>
<p>Els <strong>formularis complexos</strong> són aquells que contenen estructures jeràrquiques (formularis dins de formularis) o col·leccions dinàmiques de camps que l'usuari pot afegir o eliminar segons les seves necessitats. Mentre un formulari bàsic té camps estàtics predefinits, un formulari complex s'adapta dinàmicament al context.</p>
<p><strong>Diferència clau:</strong></p>
<ul>
<li><strong>Formulari bàsic:</strong> Camps fixos predefinits (nom, email, telèfon)</li>
<li><strong>Formulari complex:</strong> Camps dinàmics (múltiples telèfons, adreces, variants) + estructures niuades (adreça amb 5 camps agrupats)</li>
</ul>
<h4>3.2.2. Problema sense FormArray i formularis niuats</h4>
<p>Els formularis amb només FormGroups plans presenten limitacions quan necessitem camps dinàmics o agrupacions lògiques.</p>
<p><strong>Situació sense FormArray (camps fixos):</strong></p>
{% capture code_489 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  telefon1: ['', Validators.pattern(/^[0-9]{9}$/)],
  telefon2: ['', Validators.pattern(/^[0-9]{9}$/)],
  telefon3: ['', Validators.pattern(/^[0-9]{9}$/)],
  carrer: ['', Validators.required],
  ciutat: ['', Validators.required],
  codiPostal: ['', Validators.required],
  provincia: ['', Validators.required],
  pais: ['', Validators.required]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_489 %}
{% capture code_490 %}<label>
Telèfon 1
<input formControlName="telefon1">
</label>
<div *ngIf="formulari.get('telefon1')?.hasError('pattern')">
Format incorrecte
</div>
<label>
Telèfon 2
<input formControlName="telefon2">
</label>
<div *ngIf="formulari.get('telefon2')?.hasError('pattern')">
Format incorrecte
</div>
<label>
Telèfon 3
<input formControlName="telefon3">
</label>
<div *ngIf="formulari.get('telefon3')?.hasError('pattern')">
Format incorrecte
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_490 %}
<p><strong>Problemes que genera:</strong></p>
<p><strong>1. Camps limitats i rígids</strong></p>
<p>Definiu 3 camps de telèfon però l'usuari necessita 5? Cal modificar codi TypeScript (afegir <code>telefon4</code>, <code>telefon5</code>) i HTML (duplicar template). Usuari només necessita 1 telèfon? Els altres 2 queden buits al formulari, confós visualment. Impossible adaptar formulari a necessitats reals sense modificar codi.</p>
<p><strong>2. Duplicació massiva de codi</strong></p>
<p>Cada camp repetit (telefon1, telefon2, telefon3) requereix: definició a FormGroup, getter al component, HTML amb label+input+validació, SCSS per estils. Per 3 telèfons: 3×10 línies = 30 línies duplicades. Canviar validació de telèfon: modificar 3 llocs. Error en 1, inconsistència total. Manteniment caòtic.</p>
<p><strong>3. Estructura plana sense agrupacions lògiques</strong></p>
<p>Adreça amb 5 camps (carrer, ciutat, CP, província, país) dispersos al FormGroup principal entre altres camps. Accés: <code>formulari.get('carrer')</code>, <code>formulari.get('ciutat')</code>. Impossible tractar adreça com a entitat lògica. Validacions interdependents (ex: CP depèn de província) difícils d'implementar.</p>
<p><strong>4. Impossibilitat d'operacions col·lectives</strong></p>
<p>Voleu validar tots els telèfons com a grup? Impossible amb FormControls independents. Voleu netejar tots els telèfons alhora? Cal fer <code>setValue()</code> a <code>telefon1</code>, <code>telefon2</code>, <code>telefon3</code> individualment. Voleu comptar telèfons vàlids? Codi manual complicat.</p>
<p><strong>5. Experiència d'usuari deficient</strong></p>
<p>Usuari veu 3 camps de telèfon sempre, encara que només necessiti 1. No pot afegir més telèfons si en necessita. Formulari sembla rígid i poc adaptat a necessitats reals. Frustrant i poc professional.</p>
<h4>3.2.3. Solució amb FormArray i FormGroup niuats</h4>
<p>Angular proporciona <code>FormArray</code> per col·leccions dinàmiques i permet niuar <code>FormGroup</code> per organitzar camps.</p>
<p><strong>Situació amb FormArray i niuació:</strong></p>
{% capture code_491 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  telefons: this.fb.array([
    this.crearTelefon()
  ]),
  adreca: this.fb.group({
    carrer: ['', Validators.required],
    ciutat: ['', Validators.required],
    codiPostal: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]],
    provincia: ['', Validators.required],
    pais: ['Espanya', Validators.required]
  })
});
get telefons(): FormArray {
  return this.formulari.get('telefons') as FormArray;
}
crearTelefon(): FormGroup {
  return this.fb.group({
    numero: ['', [Validators.required, Validators.pattern(/^[0-9]{9}$/)]],
    tipus: ['mobil', Validators.required]
  });
}
afegirTelefon(): void {
  this.telefons.push(this.crearTelefon());
}
eliminarTelefon(index: number): void {
  this.telefons.removeAt(index);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_491 %}
{% capture code_492 %}<section>
<h3>Telèfons</h3>
<button type="button" (click)="afegirTelefon()">
Afegir telèfon
</button>
<div formArrayName="telefons">
<div *ngFor="let telefon of telefons.controls; let i = index" [formGroupName]="i" class="telefon-item">
<label>
Número
<input formControlName="numero" placeholder="612345678">
</label>
<label>
Tipus
<select formControlName="tipus">
<option value="mobil">Mòbil</option>
<option value="fix">Fix</option>
<option value="treball">Treball</option>
</select>
</label>
<button type="button" (click)="eliminarTelefon(i)">
Eliminar
</button>
<div *ngIf="telefon.get('numero')?.hasError('pattern')" class="error">
Format incorrecte (9 dígits)
</div>
</div>
</div>
</section>
<section formGroupName="adreca">
<h3>Adreça</h3>
<label>
Carrer
<input formControlName="carrer">
</label>
<label>
Ciutat
<input formControlName="ciutat">
</label>
<label>
Codi postal
<input formControlName="codiPostal">
</label>
</section>{% endcapture %}
{% include code-block.html lang="html" code=code_492 %}
<p><strong>Avantatges específics:</strong></p>
<ul>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Flexibilitat total:</strong> Usuari afegeix 1, 5 o 10 telèfons segons necessitat. Botó "Afegir" crea nou FormGroup automàticament. Botó "Eliminar" esborra telèfon específic. Adaptació dinàmica perfecta.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Zero duplicació de codi:</strong> 1 mètode <code>crearTelefon()</code> reutilitzat per tots els telèfons. 1 bloc HTML amb <code>*ngFor</code> renderitza tots. Canviar validació: modificar 1 lloc vs 3-10 llocs. Manteniment simple.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Organització lògica:</strong> Adreça agrupada amb <code>formGroupName="adreca"</code>. Accés net: <code>formulari.get('adreca.ciutat')</code>. Validacions interdependents fàcils (CP depèn de província). Estructura clara i mantenible.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Operacions col·lectives:</strong> Validar tots telèfons: <code>telefons.valid</code>. Comptar telèfons: <code>telefons.length</code>. Netejar tots: <code>telefons.clear()</code>. API potent per col·leccions.</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <strong>Experiència d'usuari excel·lent:</strong> Usuari controla formulari: afegeix camps quan cal, elimina els que sobren. Formulari adaptat a cas real. Professional i intuïtiu.</li>
</ul>
<h4>3.2.4. Exemple real complet</h4>
<p><strong>Situació:</strong> Formulari d'element de catàleg amb variants dinàmiques (color + estoc) i adreça de distribució niuada.</p>
<p><strong>Sense FormArray (limitat a 3 variants):</strong></p>
{% capture code_493 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  variant1Color: [''],
  variant1Estoc: [0],
  variant2Color: [''],
  variant2Estoc: [0],
  variant3Color: [''],
  variant3Estoc: [0],
  distribucioCarrer: [''],
  distribucioCiutat: [''],
  distribucioCP: ['']
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_493 %}
<p><strong>Amb FormArray i niuació (flexible i organitzat):</strong></p>
{% capture code_494 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  variants: this.fb.array([
    this.crearVariant()
  ]),
  distribucio: this.fb.group({
    carrer: ['', Validators.required],
    ciutat: ['', Validators.required],
    codiPostal: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]]
  })
});
crearVariant(): FormGroup {
  return this.fb.group({
    color: ['', Validators.required],
    estoc: [0, [Validators.required, Validators.min(0)]],
    preu: [0, [Validators.required, Validators.min(0)]]
  });
}
afegirVariant(): void {
  this.variants.push(this.crearVariant());
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_494 %}
<h4>3.2.5. Comparativa visual</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Aspecte</th>
<th>FormGroup pla</th>
<th>FormArray + FormGroup niat</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Camps dinàmics</strong></td>
<td>Impossibles (cal predefinir)</td>
<td>Natiu (push/removeAt)</td>
</tr>
<tr>
<td><strong>Límit de camps</strong></td>
<td>Fix (telefon1, telefon2, telefon3)</td>
<td>Il·limitat (usuari controla)</td>
</tr>
<tr>
<td><strong>Duplicació de codi</strong></td>
<td>Alta (repetir per cada camp)</td>
<td>Baixa (1 mètode + *ngFor)</td>
</tr>
<tr>
<td><strong>Organització lògica</strong></td>
<td>Plana (tots camps al mateix nivell)</td>
<td>Jeràrquica (FormGroups niuats)</td>
</tr>
<tr>
<td><strong>Accés a camps</strong></td>
<td><code>formulari.get('telefon1')</code></td>
<td><code>telefons.at(0).get('numero')</code></td>
</tr>
<tr>
<td><strong>Validacions col·lectives</strong></td>
<td>Impossible</td>
<td>Fàcil (<code>telefons.valid</code>)</td>
</tr>
<tr>
<td><strong>Experiència usuari</strong></td>
<td>Rígida (camps fixos)</td>
<td>Flexible (afegir/eliminar)</td>
</tr>
<tr>
<td><strong>Mantenibilitat</strong></td>
<td>Baixa (canviar 3+ llocs)</td>
<td>Alta (canviar 1 mètode)</td>
</tr>
<tr>
<td><strong>Escalabilitat</strong></td>
<td>Limitada (redessenys constants)</td>
<td>Excel·lent (adapta automàticament)</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>Complex (molts casos)</td>
<td>Senzill (testejar mètode factory)</td>
</tr>
</tbody>
</table>
<h4>3.2.6. Conceptes clau</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Concepte</th>
<th>Definició</th>
<th>Sintaxi</th>
<th>Quan usar</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FormArray</strong></td>
<td>Col·lecció dinàmica de FormControls o FormGroups</td>
<td><code>fb.array([control1, control2])</code></td>
<td>Múltiples camps similars (telèfons, adreces)</td>
</tr>
<tr>
<td><strong>FormGroup niat</strong></td>
<td>FormGroup dins d'un altre FormGroup</td>
<td><code>fb.group({ adreca: fb.group({...}) })</code></td>
<td>Agrupar camps relacionats lògicament</td>
</tr>
<tr>
<td><strong>.push()</strong></td>
<td>Afegir control al final del FormArray</td>
<td><code>formArray.push(nouControl)</code></td>
<td>Afegir camp dinàmic</td>
</tr>
<tr>
<td><strong>.removeAt(i)</strong></td>
<td>Eliminar control a l'índex i</td>
<td><code>formArray.removeAt(2)</code></td>
<td>Eliminar camp específic</td>
</tr>
<tr>
<td><strong>.at(i)</strong></td>
<td>Accedir a control a l'índex i</td>
<td><code>formArray.at(0)</code></td>
<td>Llegir/modificar control específic</td>
</tr>
<tr>
<td><strong>.clear()</strong></td>
<td>Buidar FormArray completament</td>
<td><code>formArray.clear()</code></td>
<td>Netejar tots els camps dinàmics</td>
</tr>
<tr>
<td><strong>.setValue()</strong></td>
<td>Assignar TOTS els valors</td>
<td><code>form.setValue({...})</code></td>
<td>Carregar formulari complet</td>
</tr>
<tr>
<td><strong>.patchValue()</strong></td>
<td>Assignar ALGUNS valors</td>
<td><code>form.patchValue({...})</code></td>
<td>Actualitzar camps parcials</td>
</tr>
<tr>
<td><strong>.reset()</strong></td>
<td>Reiniciar amb valors opcionals</td>
<td><code>form.reset({...})</code></td>
<td>Netejar formulari</td>
</tr>
</tbody>
</table>
<h4>3.2.7. Quan usar cada estructura</h4>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar FormArray quan:</strong></p>
<ul>
<li>Múltiples camps del mateix tipus (telèfons, emails, adreces)</li>
<li>Nombre de camps variable segons usuari</li>
<li>Necessiteu operacions col·lectives (comptar vàlids, netejar tots)</li>
<li>Voleu afegir/eliminar camps dinàmicament</li>
</ul>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar FormGroup niat quan:</strong></p>
<ul>
<li>Agrupar camps relacionats lògicament (adreça = carrer+ciutat+CP)</li>
<li>Reutilitzar estructura entre formularis (adreça en perfil, comanda, enviament)</li>
<li>Validacions interdependents entre camps del grup</li>
<li>Millorar organització i lectura del codi</li>
</ul>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar FormGroup pla quan:</strong></p>
<ul>
<li>Formulari simple amb pocs camps (&lt;10)</li>
<li>Camps heterogenis sense agrupació lògica</li>
<li>Cap necessitat de camps dinàmics</li>
</ul>
<p><strong>Recomanació general:</strong> Per aplicacions professionals, preferir FormArray per col·leccions i FormGroup niat per agrupacions. Només usar FormGroup pla per formularis molt simples.</p>
<h4>3.2.8. Característiques principals</h4>
<p><strong>Col·leccions tipades</strong></p>
<p>FormArray és genèric: <code>FormArray&lt;FormGroup&gt;</code>, <code>FormArray&lt;FormControl&gt;</code>. TypeScript proporciona type safety. Compilador detecta errors d'accés.</p>
<p><strong>Índexs dinàmics</strong></p>
<p>Accés per índex: <code>.at(i)</code>. Iteració fàcil amb <code>*ngFor</code>. Gestió d'índexs automàtica (eliminar actualitza índexs restants).</p>
<p><strong>Validacions globals i individuals</strong></p>
<p>Validar FormArray complet: <code>formArray.valid</code>. Validar control individual: <code>formArray.at(i).valid</code>. Comptar vàlids: <code>formArray.controls.filter(c => c.valid).length</code>.</p>
<p><strong>Composició il·limitada</strong></p>
<p>FormArray dins FormGroup, FormGroup dins FormArray, niuacions múltiples nivells. Estructures complexes possibles: llista de comandes, cada comanda amb llista de productes.</p>
<h4>3.2.9. Integració amb el flux de treball</h4>
<p>Els formularis complexos s'integren amb:</p>
<ul>
<li><strong>Services:</strong> Carregar/guardar estructures niuades via API</li>
<li><strong>Routing:</strong> Resolvers per precarregar dades abans de mostrar formulari</li>
<li><strong>State management:</strong> Signals/observables per sincronitzar dades complexes</li>
<li><strong>Testing:</strong> Tests unitaris per mètodes factory de controls</li>
</ul>
<p>En futurs projectes aprendreu:</p>
<ul>
<li>Formularis amb niuació profunda (3+ nivells)</li>
<li>Drag & drop per reordenar FormArray</li>
<li>Validacions asíncrones en FormArrays</li>
<li>Performance optimization per FormArrays grans (&gt;100 controls)</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="3.2" titol="Marc conceptual" contingut=section_point_3_2 %}

  {% capture section_point_3_3 %}
<h4>3.3.1. Jerarquia de formularis complexos</h4>
{% capture code_495 %}FormGroup (formulari principal)
  ├── FormControl (nom)
  ├── FormControl (email)
  │
  ├── FormArray (telefons)
  │     ├── FormGroup [0]
  │     │     ├── FormControl (numero)
  │     │     └── FormControl (tipus)
  │     ├── FormGroup [1]
  │     │     ├── FormControl (numero)
  │     │     └── FormControl (tipus)
  │     └── ... (dinàmic)
  │
  └── FormGroup (adreca) [niat]
        ├── FormControl (carrer)
        ├── FormControl (ciutat)
        ├── FormControl (codiPostal)
        └── FormControl (pais){% endcapture %}
{% include code-block.html lang="text" code=code_495 %}
<h4>3.3.2. Flux afegir/eliminar controls</h4>
{% capture code_496 %}Usuari clica "Afegir telèfon"
  ↓ (click)="afegirTelefon()"
Component executa mètode
  ↓ crearTelefon() retorna FormGroup
  ↓ telefons.push(nouFormGroup)
FormArray actualitzat
  ↓ Change detection Angular
Template re-renderitza *ngFor
  ↓ Nou camp apareix a la UI
Usuari pot omplir nou telèfon
---
Usuari clica "Eliminar" (índex 2)
  ↓ (click)="eliminarTelefon(2)"
Component executa mètode
  ↓ telefons.removeAt(2)
FormArray actualitzat (índexs recalculats)
  ↓ [0, 1, 2, 3] → [0, 1, 3]
  ↓ Índex 3 passa a ser 2
Template re-renderitza *ngFor
  ↓ Camp eliminat desapareix
Usuari veu canvi immediat{% endcapture %}
{% include code-block.html lang="text" code=code_496 %}
<h4>3.3.3. Accés a dades niuades</h4>
{% capture code_497 %}formulari.get('nom')                    → FormControl
formulari.get('adreca')                 → FormGroup
formulari.get('adreca.ciutat')          → FormControl
formulari.get('adreca')?.get('ciutat')  → FormControl
formulari.get('telefons')               → FormArray
telefons.at(0)                          → FormGroup
telefons.at(0).get('numero')            → FormControl
telefons.controls[1].value.tipus        → 'mobil'{% endcapture %}
{% include code-block.html lang="typescript" code=code_497 %}
<h4>3.3.4. Analogia útil</h4>
<p><strong>FormGroup = Objecte JavaScript</strong></p>
{% capture code_498 %}const persona = {
  nom: 'Joan',
  email: 'joan@example.com',
  adreca: {
    carrer: 'Main St',
    ciutat: 'Barcelona'
  }
}{% endcapture %}
{% include code-block.html lang="javascript" code=code_498 %}
<p><strong>FormArray = Array JavaScript</strong></p>
{% capture code_499 %}const persona = {
  nom: 'Joan',
  telefons: [
    { numero: '612345678', tipus: 'mobil' },
    { numero: '934567890', tipus: 'fix' }
  ]
}{% endcapture %}
{% include code-block.html lang="javascript" code=code_499 %}
<p><strong>Afegir/eliminar:</strong></p>
{% capture code_500 %}persona.telefons.push({ numero: '600111222', tipus: 'treball' });
persona.telefons.splice(1, 1);{% endcapture %}
{% include code-block.html lang="javascript" code=code_500 %}
<h4>3.3.5. Diferència setValue vs patchValue vs reset</h4>
{% capture code_501 %}formulari.setValue({
  nom: 'Joan',
  telefons: [...],
  adreca: {...}
});
formulari.patchValue({
  nom: 'Joan'
});
formulari.reset({
  nom: '',
  telefons: [],
  adreca: { ciutat: 'Barcelona', pais: 'Espanya' }
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_501 %}
<p><strong>Regla mnemotècnica:</strong></p>
<ul>
<li><code>setValue</code> = assignació <strong>completa</strong> (tots els camps)</li>
<li><code>patchValue</code> = actualització <strong>parcial</strong> (només alguns camps)</li>
<li><code>reset</code> = <strong>neteja</strong> amb valors inicials opcionals</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="3.3" titol="Model mental" contingut=section_point_3_3 %}

  {% capture section_point_3_4 %}
<h4>3.4.1. Objectiu</h4>
<p>Entendre les diferències entre FormArray i FormGroup, i decidir quin usar segons el cas.</p>
<h4>3.4.2. Contingut</h4>
<p><strong>FormGroup:</strong></p>
<ul>
<li>Estructura d'objecte amb claus fixes</li>
<li>Camps predefinits coneguts</li>
<li>Accés per nom: <code>.get('camp')</code></li>
<li>Exemple: <code>{ nom: '...', email: '...' }</code></li>
</ul>
<p><strong>FormArray:</strong></p>
<ul>
<li>Estructura d'array amb índexs</li>
<li>Camps dinàmics variables</li>
<li>Accés per índex: <code>.at(0)</code></li>
<li>Exemple: <code>[telefon1, telefon2, telefon3]</code></li>
</ul>
<p><strong>Taula comparativa:</strong></p>
<table class="table table-bordered">
<thead>
<tr>
<th>Criteri</th>
<th>FormGroup</th>
<th>FormArray</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Estructura</strong></td>
<td>Objecte <code>{ clau: valor }</code></td>
<td>Array <code>[item0, item1]</code></td>
</tr>
<tr>
<td><strong>Accés</strong></td>
<td>Per nom <code>.get('clau')</code></td>
<td>Per índex <code>.at(0)</code></td>
</tr>
<tr>
<td><strong>Camps</strong></td>
<td>Fixos (predefinits)</td>
<td>Dinàmics (push/removeAt)</td>
</tr>
<tr>
<td><strong>Cas d'ús</strong></td>
<td>Adreça (carrer, ciutat, CP)</td>
<td>Múltiples telèfons</td>
</tr>
<tr>
<td><strong>Iteració</strong></td>
<td>No aplicable</td>
<td>Fàcil amb *ngFor</td>
</tr>
<tr>
<td><strong>Afegir camp</strong></td>
<td>No previst (modificar codi)</td>
<td><code>.push(nouControl)</code></td>
</tr>
<tr>
<td><strong>Eliminar camp</strong></td>
<td>No aplicable</td>
<td><code>.removeAt(i)</code></td>
</tr>
</tbody>
</table>
<p><strong>Exemples de decisió:</strong></p>
<p><strong>Usar FormGroup quan:</strong></p>
<ul>
<li>Adreça: sempre té carrer, ciutat, CP → FormGroup <code>{ carrer, ciutat, CP }</code></li>
<li>Configuració: opcions fixes → FormGroup <code>{ tema, idioma, notificacions }</code></li>
</ul>
<p><strong>Usar FormArray quan:</strong></p>
<ul>
<li>Telèfons: 1, 3 o 10 segons usuari → FormArray de FormGroups</li>
<li>Ingredients: variable → FormArray de FormControls</li>
<li>Participants: afegir/eliminar → FormArray</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> FormGroup per estructura fixa coneguda. FormArray per col·leccions variables dinàmiques." %}
<h4>3.4.3. Resultat esperat</h4>
<p>Compreneu quan usar FormGroup (objectes) vs FormArray (arrays).</p>
  {% endcapture %}
  {% include section-point.html numero="3.4" titol="FormArray vs FormGroup: quan usar cada estructura" contingut=section_point_3_4 %}

  {% capture section_point_3_5 %}
<h4>3.5.1. Objectiu</h4>
<p>Aprendre a crear un FormArray bàsic amb controls dinàmics.</p>
<h4>3.5.2. Sintaxi bàsica</h4>
{% capture code_502 %}import { FormArray, FormGroup, FormControl } from '@angular/forms';
formulari = this.fb.group({
  nom: ['', Validators.required],
  telefons: this.fb.array([
    this.fb.control('', Validators.pattern(/^[0-9]{9}$/))
  ])
});
get telefons(): FormArray {
  return this.formulari.get('telefons') as FormArray;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_502 %}
<h4>3.5.3. FormArray de FormControls (simple)</h4>
{% capture code_503 %}telefons: this.fb.array([
  this.fb.control('612345678'),
  this.fb.control('934567890')
])
telefons.at(0).value{% endcapture %}
{% include code-block.html lang="typescript" code=code_503 %}
<h4>3.5.4. FormArray de FormGroups (compost)</h4>
{% capture code_504 %}telefons: this.fb.array([
  this.fb.group({
    numero: ['612345678', Validators.required],
    tipus: ['mobil']
  }),
  this.fb.group({
    numero: ['934567890', Validators.required],
    tipus: ['fix']
  })
])
telefons.at(0).get('numero')?.value{% endcapture %}
{% include code-block.html lang="typescript" code=code_504 %}
<h4>3.5.5. Template per FormArray</h4>
{% capture code_505 %}<div formArrayName="telefons">
<div *ngFor="let telefon of telefons.controls; let i = index">
<input [formControlName]="i">
<div [formGroupName]="i">
<input formControlName="numero">
<select formControlName="tipus">
<option value="mobil">Mòbil</option>
<option value="fix">Fix</option>
</select>
</div>
</div>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_505 %}
<h4>3.5.6. Exemple complet</h4>
{% capture code_506 %}export class FormulariComponent {
  private readonly fb = inject(FormBuilder);
  formulari = this.fb.group({
    emails: this.fb.array([
      this.fb.control('', [Validators.required, Validators.email])
    ])
  });
  get emails(): FormArray {
    return this.formulari.get('emails') as FormArray;
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_506 %}
{% capture code_507 %}<form [formGroup]="formulari">
<h3>Emails</h3>
<div formArrayName="emails">
<div *ngFor="let email of emails.controls; let i = index">
<input [formControlName]="i" placeholder="email@example.com">
<div *ngIf="emails.at(i).hasError('email')" class="error">
Format email incorrecte
</div>
</div>
</div>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_507 %}
{% include success_box.html contingut="<strong>Clau:</strong> FormArray es crea amb <code>fb.array([...])</code>. Accés amb <code>.at(i)</code>. Template amb <code>formArrayName</code> + <code>*ngFor</code>." %}
<h4>3.5.7. Resultat esperat</h4>
<p>Sabeu crear FormArray bàsic amb FormControls o FormGroups.</p>
  {% endcapture %}
  {% include section-point.html numero="3.5" titol="Crear FormArray bàsic per camps dinàmics" contingut=section_point_3_5 %}

  {% capture section_point_3_6 %}
<h4>3.6.1. Objectiu</h4>
<p>Implementar funcionalitat per afegir i eliminar camps dinàmicament.</p>
<h4>3.6.2. Mètode factory per crear controls</h4>
{% capture code_508 %}crearTelefon(): FormGroup {
  return this.fb.group({
    numero: ['', [Validators.required, Validators.pattern(/^[0-9]{9}$/)]],
    tipus: ['mobil', Validators.required],
    principal: [false]
  });
}
crearEmail(): FormControl {
  return this.fb.control('', [Validators.required, Validators.email]);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_508 %}
<h4>3.6.3. Afegir control al FormArray</h4>
{% capture code_509 %}afegirTelefon(): void {
  const nouTelefon = this.crearTelefon();
  this.telefons.push(nouTelefon);
}
afegirEmail(): void {
  this.emails.push(this.crearEmail());
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_509 %}
<h4>3.6.4. Eliminar control per índex</h4>
{% capture code_510 %}eliminarTelefon(index: number): void {
  this.telefons.removeAt(index);
}
eliminarEmail(index: number): void {
  if (this.emails.length > 1) {
    this.emails.removeAt(index);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_510 %}
<h4>3.6.5. Botó afegir al template</h4>
{% capture code_511 %}<button type="button" (click)="afegirTelefon()">
Afegir telèfon
</button>{% endcapture %}
{% include code-block.html lang="html" code=code_511 %}
<h4>3.6.6. Botó eliminar per cada item</h4>
{% capture code_512 %}<div formArrayName="telefons">
<div *ngFor="let telefon of telefons.controls; let i = index" [formGroupName]="i">
<input formControlName="numero">
<select formControlName="tipus"></select>
<button type="button" (click)="eliminarTelefon(i)" [disabled]="telefons.length === 1">
Eliminar
</button>
</div>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_512 %}
<h4>3.6.7. Validacions abans d'eliminar</h4>
{% capture code_513 %}eliminarTelefon(index: number): void {
  if (this.telefons.length <= 1) {
    alert('Cal almenys 1 telèfon');
    return;
  }
  const telefon = this.telefons.at(index);
  if (telefon.get('numero')?.value && !confirm('Segur?')) {
    return;
  }
  this.telefons.removeAt(index);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_513 %}
<h4>3.6.8. Altres mètodes útils</h4>
{% capture code_514 %}netejaTelefons(): void {
  this.telefons.clear();
  this.telefons.push(this.crearTelefon());
}
insertarTelefon(index: number): void {
  this.telefons.insert(index, this.crearTelefon());
}
get telefonsValids(): number {
  return this.telefons.controls.filter(c => c.valid).length;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_514 %}
{% include success_box.html contingut="<strong>Clau:</strong> <code>.push()</code> afegeix al final, <code>.removeAt(i)</code> elimina per índex, <code>.clear()</code> buida tot. Sempre validar abans d'eliminar." %}
<h4>3.6.9. Resultat esperat</h4>
<p>Sabeu afegir/eliminar controls dinàmicament amb validacions.</p>
  {% endcapture %}
  {% include section-point.html numero="3.6" titol="Afegir i eliminar controls programàticament" contingut=section_point_3_6 %}

  {% capture section_point_3_7 %}
<h4>3.7.1. Objectiu</h4>
<p>Crear estructures jeràrquiques amb FormGroups niuats per organitzar camps.</p>
<h4>3.7.2. FormGroup niat bàsic</h4>
{% capture code_515 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  adreca: this.fb.group({
    carrer: ['', Validators.required],
    numero: ['', Validators.required],
    pis: [''],
    ciutat: ['', Validators.required],
    codiPostal: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]],
    pais: ['Espanya', Validators.required]
  })
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_515 %}
<h4>3.7.3. Accedir a FormGroup niat</h4>
{% capture code_516 %}get adreca(): FormGroup {
  return this.formulari.get('adreca') as FormGroup;
}
this.adreca.get('ciutat')?.value
this.formulari.get('adreca.ciutat')?.value
this.formulari.get('adreca')?.get('ciutat')?.value{% endcapture %}
{% include code-block.html lang="typescript" code=code_516 %}
<h4>3.7.4. Template amb formGroupName</h4>
{% capture code_517 %}<form [formGroup]="formulari">
<label>
Nom
<input formControlName="nom">
</label>
<section formGroupName="adreca">
<h3>Adreça</h3>
<label>
Carrer
<input formControlName="carrer">
</label>
<label>
Número
<input formControlName="numero">
</label>
<label>
Pis (opcional)
<input formControlName="pis">
</label>
<label>
Ciutat
<input formControlName="ciutat">
</label>
<label>
Codi postal
<input formControlName="codiPostal">
</label>
<label>
País
<input formControlName="pais">
</label>
</section>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_517 %}
<h4>3.7.5. Múltiples nivells de niuació</h4>
{% capture code_518 %}formulari = this.fb.group({
  dadesPrincipals: this.fb.group({
    nom: [''],
    cognoms: ['']
  }),
  contacte: this.fb.group({
    telefon: [''],
    adreca: this.fb.group({
      carrer: [''],
      ciutat: [''],
      coordenades: this.fb.group({
        latitud: [0],
        longitud: [0]
      })
    })
  })
});
formulari.get('contacte.adreca.coordenades.latitud')?.value{% endcapture %}
{% include code-block.html lang="typescript" code=code_518 %}
<h4>3.7.6. Validacions en FormGroup niat</h4>
{% capture code_519 %}adreca: this.fb.group({
  carrer: ['', Validators.required],
  ciutat: ['', Validators.required]
}, {
  validators: [this.codiPostalValidPerCiutat()]
})
codiPostalValidPerCiutat(): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const ciutat = group.get('ciutat')?.value;
    const cp = group.get('codiPostal')?.value;
    if (ciutat === 'Barcelona' && !cp.startsWith('08')) {
      return { cpInvalidPerCiutat: true };
    }
    return null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_519 %}
{% include success_box.html contingut="<strong>Clau:</strong> FormGroup niat amb <code>fb.group()</code> dins altre grup. Template amb <code>formGroupName</code>. Accés amb notació punt." %}
<h4>3.7.7. Resultat esperat</h4>
<p>Sabeu crear formularis niuats amb múltiples nivells per organitzar camps relacionats.</p>
  {% endcapture %}
  {% include section-point.html numero="3.7" titol="Formularis niuats amb FormGroup dins FormGroup" contingut=section_point_3_7 %}

  {% capture section_point_3_8 %}
<h4>3.8.1. Objectiu</h4>
<p>Dominar les diferències entre setValue, patchValue i reset per gestionar dades.</p>
<h4>3.8.2. setValue: assignar TOTS els valors</h4>
{% capture code_520 %}formulari.setValue({
  nom: 'Joan Garcia',
  telefons: [
    { numero: '612345678', tipus: 'mobil' },
    { numero: '934567890', tipus: 'fix' }
  ],
  adreca: {
    carrer: 'Main St',
    ciutat: 'Barcelona',
    codiPostal: '08001',
    pais: 'Espanya'
  }
});
formulari.setValue({
  nom: 'Joan Garcia',
  adreca: {...}
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_520 %}
<h4>3.8.3. patchValue: assignar ALGUNS valors</h4>
{% capture code_521 %}formulari.patchValue({
  nom: 'Joan Garcia'
});
formulari.patchValue({
  adreca: {
    ciutat: 'Girona'
  }
});
formulari.patchValue({
  telefons: [
    { numero: '600111222' }
  ]
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_521 %}
<h4>3.8.4. reset: netejar amb valors opcionals</h4>
{% capture code_522 %}formulari.reset();
formulari.reset({
  nom: '',
  telefons: [
    { numero: '', tipus: 'mobil' }
  ],
  adreca: {
    carrer: '',
    ciutat: '',
    codiPostal: '',
    pais: 'Espanya'
  }
});
formulari.get('adreca')?.reset({
  carrer: '',
  ciutat: 'Barcelona',
  codiPostal: '',
  pais: 'Espanya'
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_522 %}
<h4>3.8.5. Taula comparativa</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Mètode</th>
<th>Camps requerits</th>
<th>Camps omesos</th>
<th>Cas d'ús</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setValue()</code></td>
<td>TOTS obligatoris</td>
<td><i class="bi bi-x-circle" aria-hidden="true"></i> Error</td>
<td>Carregar formulari complet des d'API</td>
</tr>
<tr>
<td><code>patchValue()</code></td>
<td>Opcional (parcial)</td>
<td><i class="bi bi-check-circle" aria-hidden="true"></i> No modifica</td>
<td>Actualitzar només alguns camps</td>
</tr>
<tr>
<td><code>reset()</code></td>
<td>Opcional (parcial)</td>
<td><i class="bi bi-check-circle" aria-hidden="true"></i> Posa null/buit</td>
<td>Netejar formulari amb valors inicials</td>
</tr>
</tbody>
</table>
<h4>3.8.6. Casos d'ús pràctics</h4>
<p><strong>Carregar dades d'API (setValue):</strong></p>
{% capture code_523 %}carregarElement(id: number): void {
  this.elementService.obtenir(id).subscribe(element => {
    this.formulari.setValue({
      nom: element.nom,
      telefons: element.telefons.map(t => ({
        numero: t.numero,
        tipus: t.tipus
      })),
      adreca: {
        carrer: element.adreca.carrer,
        ciutat: element.adreca.ciutat,
        codiPostal: element.adreca.codiPostal,
        pais: element.adreca.pais
      }
    });
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_523 %}
<p><strong>Actualitzar ciutat (patchValue):</strong></p>
{% capture code_524 %}canviarCiutat(novaCiutat: string): void {
  this.formulari.patchValue({
    adreca: { ciutat: novaCiutat }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_524 %}
<p><strong>Netejar formulari després d'enviar (reset):</strong></p>
{% capture code_525 %}onSubmit(): void {
  if (this.formulari.valid) {
    this.elementService.crear(this.formulari.value).subscribe(() => {
      this.formulari.reset({
        nom: '',
        telefons: [{ numero: '', tipus: 'mobil' }],
        adreca: { pais: 'Espanya' }
      });
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_525 %}
{% include success_box.html contingut="<strong>Clau:</strong> setValue = complet, patchValue = parcial, reset = netejar. Usar segons necessitat." %}
<h4>3.8.7. Resultat esperat</h4>
<p>Domineu setValue, patchValue i reset per gestionar valors adequadament.</p>
  {% endcapture %}
  {% include section-point.html numero="3.8" titol="Gestió de valors: setValue, patchValue, reset" contingut=section_point_3_8 %}

  {% capture section_point_3_9 %}
<h4>3.9.1. Objectiu</h4>
<p>Aplicar validacions a FormArrays i gestionar errors dinàmicament.</p>
<h4>3.9.2. Validacions per FormArray complet</h4>
{% capture code_526 %}telefons: this.fb.array(
  [this.crearTelefon()],
  [Validators.minLength(1), Validators.maxLength(5)]
)
if (this.telefons.invalid) {
  if (this.telefons.hasError('minlength')) {
    console.log('Cal almenys 1 telèfon');
  }
  if (this.telefons.hasError('maxlength')) {
    console.log('Màxim 5 telèfons');
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_526 %}
<h4>3.9.3. Validacions per cada control del FormArray</h4>
{% capture code_527 %}crearTelefon(): FormGroup {
  return this.fb.group({
    numero: ['', [
      Validators.required,
      Validators.pattern(/^[0-9]{9}$/),
      this.telefonUnic()
    ]],
    tipus: ['mobil', Validators.required]
  });
}
telefonUnic(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const numero = control.value;
    const duplicat = this.telefons?.controls.some(
      (c, i) => c.get('numero')?.value === numero &&
                c !== control.parent
    );
    return duplicat ? { telefonDuplicat: true } : null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_527 %}
<h4>3.9.4. Mostrar errors al template</h4>
{% capture code_528 %}<div formArrayName="telefons">
<div *ngIf="telefons.hasError('maxlength')" class="error">
Màxim 5 telèfons permesos
</div>
<div *ngFor="let telefon of telefons.controls; let i = index" [formGroupName]="i">
<input formControlName="numero">
<div *ngIf="telefon.get('numero')?.touched && telefon.get('numero')?.invalid" class="error">
<p *ngIf="telefon.get('numero')?.hasError('required')">
Número obligatori
</p>
<p *ngIf="telefon.get('numero')?.hasError('pattern')">
Format incorrecte (9 dígits)
</p>
<p *ngIf="telefon.get('numero')?.hasError('telefonDuplicat')">
Aquest telèfon ja existeix
</p>
</div>
</div>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_528 %}
<h4>3.9.5. Validador a nivell FormGroup dins FormArray</h4>
{% capture code_529 %}crearVariant(): FormGroup {
  return this.fb.group({
    color: ['', Validators.required],
    estoc: [0, Validators.min(0)],
    preu: [0, Validators.min(0)]
  }, {
    validators: [this.preuCoherentAmbEstoc()]
  });
}
preuCoherentAmbEstoc(): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const estoc = group.get('estoc')?.value;
    const preu = group.get('preu')?.value;
    if (estoc === 0 && preu > 0) {
      return { preuSenseEstoc: true };
    }
    return null;
  };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_529 %}
<h4>3.9.6. Deshabilitar botó afegir si límit assolit</h4>
{% capture code_530 %}<button type="button" (click)="afegirTelefon()" [disabled]="telefons.length >= 5">
Afegir telèfon ({{ telefons.length }}/5)
</button>{% endcapture %}
{% include code-block.html lang="html" code=code_530 %}
{% include success_box.html contingut="<strong>Clau:</strong> Validacions a FormArray (minLength/maxLength), a cada control individual, i a FormGroups dins FormArray." %}
<h4>3.9.7. Resultat esperat</h4>
<p>Sabeu aplicar validacions completes a FormArrays amb missatges contextuals.</p>
  {% endcapture %}
  {% include section-point.html numero="3.9" titol="Validacions en camps dinàmics" contingut=section_point_3_9 %}

  {% capture section_point_3_10 %}
<h4>3.10.1. Objectiu</h4>
<p>Gestionar índexs de FormArray de forma segura i eficient.</p>
<h4>3.10.2. Tracking per index al *ngFor</h4>
{% capture code_531 %}<div *ngFor="let telefon of telefons.controls; let i = index">
</div>
<div *ngFor="let telefon of telefons.controls; let i = index; trackBy: trackByIndex">
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_531 %}
{% capture code_532 %}trackByIndex(index: number): number {
  return index;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_532 %}
<h4>3.10.3. Guardar referència a FormGroup</h4>
{% capture code_533 %}eliminarTelefon(index: number): void {
  setTimeout(() => {
    this.telefons.removeAt(index);
  }, 2000);
}
eliminarTelefon(telefon: AbstractControl): void {
  const index = this.telefons.controls.indexOf(telefon as FormGroup);
  if (index !== -1) {
    this.telefons.removeAt(index);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_533 %}
<h4>3.10.4. Marcar control específic com a tocat</h4>
{% capture code_534 %}marcarTelefonComATocat(index: number): void {
  const telefon = this.telefons.at(index);
  telefon.markAsTouched();
  Object.keys((telefon as FormGroup).controls).forEach(key => {
    telefon.get(key)?.markAsTouched();
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_534 %}
<h4>3.10.5. Validar FormArray abans d'enviar</h4>
{% capture code_535 %}onSubmit(): void {
  this.telefons.controls.forEach(control => {
    control.markAsTouched();
    if (control instanceof FormGroup) {
      Object.keys(control.controls).forEach(key => {
        control.get(key)?.markAsTouched();
      });
    }
  });
  if (this.formulari.invalid) {
    console.warn('Formulari invàlid');
    return;
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_535 %}
<h4>3.10.6. Reordenar elements</h4>
{% capture code_536 %}moureAmunt(index: number): void {
  if (index === 0) return;
  const control = this.telefons.at(index);
  this.telefons.removeAt(index);
  this.telefons.insert(index - 1, control);
}
moureAvall(index: number): void {
  if (index === this.telefons.length - 1) return;
  const control = this.telefons.at(index);
  this.telefons.removeAt(index);
  this.telefons.insert(index + 1, control);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_536 %}
<h4>3.10.7. Getter per validacions</h4>
{% capture code_537 %}get algunaVariantAmbEstoc(): boolean {
  return this.variants.controls.some(
    v => (v as FormGroup).get('estoc')?.value > 0
  );
}
get totalEstoc(): number {
  return this.variants.controls.reduce(
    (sum, v) => sum + ((v as FormGroup).get('estoc')?.value || 0),
    0
  );
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_537 %}
{% include success_box.html contingut="<strong>Clau:</strong> Usar trackBy, guardar referències segures, marcar tocats abans d'enviar, getters per validacions agregades." %}
<h4>3.10.8. Resultat esperat</h4>
<p>Domineu patrons avançats de gestió d'índexs i operacions col·lectives.</p>
  {% endcapture %}
  {% include section-point.html numero="3.10" titol="Patrons de gestió d'índexs i referències" contingut=section_point_3_10 %}

  {% capture section_point_3_11 %}
<h4>3.11.1. Objectiu</h4>
<p>Registrar patrons, decisions i casos d'ús al dossier tècnic.</p>
<h4>3.11.2. Actualitzar docs/formularis.md</h4>
<p><strong>Estructures utilitzades:</strong></p>
<table class="table table-bordered">
<thead>
<tr>
<th>Estructura</th>
<th>Descripció</th>
<th>Cas d'ús</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>FormArray de FormControls</td>
<td>Col·lecció simple</td>
<td>Múltiples emails</td>
<td><code>emails: fb.array([fb.control('')])</code></td>
</tr>
<tr>
<td>FormArray de FormGroups</td>
<td>Col·lecció composta</td>
<td>Múltiples telèfons amb tipus</td>
<td><code>telefons: fb.array([fb.group({numero, tipus})])</code></td>
</tr>
<tr>
<td>FormGroup niat</td>
<td>Agrupació lògica</td>
<td>Adreça dins formulari</td>
<td><code>adreca: fb.group({carrer, ciutat})</code></td>
</tr>
<tr>
<td>FormGroup dins FormArray</td>
<td>Combinació complexa</td>
<td>Variants amb múltiples camps</td>
<td><code>variants: fb.array([fb.group({color, estoc, preu})])</code></td>
</tr>
</tbody>
</table>
<h4>3.11.3. Patrons implementats</h4>
<p><strong>Mètode factory:</strong></p>
{% capture code_538 %}crearTelefon(): FormGroup {
  return this.fb.group({
    numero: ['', [Validators.required, Validators.pattern(/^[0-9]{9}$/)]],
    tipus: ['mobil', Validators.required]
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_538 %}
<p><strong>Gestió de valors:</strong></p>
<table class="table table-bordered">
<thead>
<tr>
<th>Mètode</th>
<th>Quan usar</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setValue()</code></td>
<td>Carregar formulari complet des d'API</td>
<td>Edició element existent</td>
</tr>
<tr>
<td><code>patchValue()</code></td>
<td>Actualitzar només alguns camps</td>
<td>Canviar ciutat mantenir resta</td>
</tr>
<tr>
<td><code>reset()</code></td>
<td>Netejar després d'enviar</td>
<td>Nou element amb valors per defecte</td>
</tr>
</tbody>
</table>
<h4>3.11.4. Bones pràctiques</h4>
<p><strong>1. Sempre mètode factory per crear controls</strong></p>
<ul>
<li>Centralitza configuració (validacions, valors per defecte)</li>
<li>Facilita manteniment (1 lloc per canviar)</li>
<li>Testejable aïlladament</li>
</ul>
<p><strong>2. Límits mínim/màxim en FormArrays</strong></p>
<ul>
<li>Evita arrays buits o massa llargs</li>
<li>Deshabilita botons quan assoleixen límit</li>
<li>Mostra comptador: "Telèfons (3/5)"</li>
</ul>
<p><strong>3. TrackBy en *ngFor</strong></p>
<ul>
<li>Millora performance evitant recrear DOM</li>
<li>Essencial per FormArrays grans (&gt;10 elements)</li>
</ul>
<p><strong>4. Validacions abans d'eliminar</strong></p>
<ul>
<li>Confirmar si control té dades</li>
<li>Mantenir mínim controls necessaris</li>
<li>Feedback clar a l'usuari</li>
</ul>
<p><strong>5. Marcar tocats abans d'enviar</strong></p>
<ul>
<li>Mostrar tots els errors si formulari invàlid</li>
<li>Iterar FormArray i marcar cada control</li>
</ul>
<p><strong>6. Getters per accés net</strong></p>
{% capture code_539 %}get telefons(): FormArray {
  return this.formulari.get('telefons') as FormArray;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_539 %}
{% include success_box.html contingut="<strong>Clau:</strong> Documentar estructures, patrons, proves i decisions facilita manteniment i reutilització." %}
<h4>3.11.5. Resultat esperat</h4>
<p>Dossier actualitzat amb documentació completa de formularis complexos.</p>
  {% endcapture %}
  {% include section-point.html numero="3.11" titol="Documentar casos d'ús i bones pràctiques" contingut=section_point_3_11 %}

  {% capture section_point_3_12 %}
<h4>3.12.1. Objectiu</h4>
<p>Consolidar el flux complet: FormArray, FormGroup niat, afegir/eliminar, validacions, gestió valors.</p>
<h4>3.12.2. Generar component</h4>
{% capture code_540 %}ng generate component components/formulari-variants --standalone{% endcapture %}
{% include code-block.html lang="bash" code=code_540 %}
<h4>3.12.3. Crear estructura FormArray + FormGroup niat</h4>
{% capture code_541 %}formulari = this.fb.group({
  nom: ['', Validators.required],
  variants: this.fb.array([
    this.crearVariant()
  ], [Validators.minLength(1), Validators.maxLength(5)]),
  distribucio: this.fb.group({
    carrer: ['', Validators.required],
    ciutat: ['', Validators.required],
    codiPostal: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]]
  })
});
get variants(): FormArray {
  return this.formulari.get('variants') as FormArray;
}
crearVariant(): FormGroup {
  return this.fb.group({
    color: ['', Validators.required],
    estoc: [0, [Validators.required, Validators.min(0)]],
    preu: [0, [Validators.required, Validators.min(0)]]
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_541 %}
<h4>3.12.4. Implementar afegir/eliminar</h4>
{% capture code_542 %}afegirVariant(): void {
  if (this.variants.length < 5) {
    this.variants.push(this.crearVariant());
  }
}
eliminarVariant(index: number): void {
  if (this.variants.length > 1) {
    this.variants.removeAt(index);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_542 %}
<h4>3.12.5. Crear template</h4>
{% capture code_543 %}<form [formGroup]="formulari">
<label>
Nom element
<input formControlName="nom">
</label>
<section>
<h3>Variants</h3>
<button type="button" (click)="afegirVariant()" [disabled]="variants.length >= 5">
Afegir ({{ variants.length }}/5)
</button>
<div formArrayName="variants">
<div *ngFor="let variant of variants.controls; let i = index" [formGroupName]="i">
<input formControlName="color" placeholder="Color">
<input type="number" formControlName="estoc" placeholder="Estoc">
<input type="number" formControlName="preu" placeholder="Preu">
<button type="button" (click)="eliminarVariant(i)">Eliminar</button>
</div>
</div>
</section>
<section formGroupName="distribucio">
<h3>Distribució</h3>
<input formControlName="carrer" placeholder="Carrer">
<input formControlName="ciutat" placeholder="Ciutat">
<input formControlName="codiPostal" placeholder="CP">
</section>
</form>{% endcapture %}
{% include code-block.html lang="html" code=code_543 %}
<h4>3.12.6. Implementar setValue/patchValue/reset</h4>
{% capture code_544 %}carregarExemple(): void {
  this.formulari.setValue({
    nom: 'Element exemple',
    variants: [
      { color: 'Blau', estoc: 10, preu: 50 },
      { color: 'Verd', estoc: 5, preu: 45 }
    ],
    distribucio: {
      carrer: 'Main St',
      ciutat: 'Barcelona',
      codiPostal: '08001'
    }
  });
}
actualitzarCiutat(): void {
  this.formulari.patchValue({
    distribucio: { ciutat: 'Girona' }
  });
}
reiniciar(): void {
  this.formulari.reset({
    nom: '',
    variants: [{ color: '', estoc: 0, preu: 0 }],
    distribucio: { carrer: '', ciutat: '', codiPostal: '' }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_544 %}
<h4>3.12.7. Provar funcionalitat</h4>
{% capture code_545 %}ng serve --port 4300
npm run lint
npm run test -- --watch=false{% endcapture %}
{% include code-block.html lang="bash" code=code_545 %}
{% include success_box.html contingut="Formulari complet amb FormArray dinàmic, FormGroup niat, validacions, gestió de valors i documentació actualitzada." %}
  {% endcapture %}
  {% include section-point.html numero="3.12" titol="Mini exemple pràctic" contingut=section_point_3_12 %}

  {% capture section_point_3_13 %}
<h4>3.13.1. Problemes transversals</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Símptoma</th>
<th>Possible causa</th>
<th>Solució ràpida</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Cannot find control with name 'X'</code></td>
<td>formControlName fora del context correcte</td>
<td>Verificar <code>[formGroupName]</code> i <code>formArrayName</code> envolten correctament</td>
</tr>
<tr>
<td><code>setValue()</code> llança error</td>
<td>Falten camps a l'objecte passat</td>
<td>Usar <code>patchValue()</code> o assegurar que TOTS els camps hi són</td>
</tr>
<tr>
<td>Controls no es reinicien</td>
<td><code>reset()</code> sense passar objecte amb valors</td>
<td>Passar objecte amb valors inicials: <code>reset({ campo: '' })</code></td>
</tr>
<tr>
<td>Botó eliminar no funciona</td>
<td>Índex incorrecte o no actualitzat</td>
<td>Usar <code>let i = index</code> a *ngFor i passar <code>i</code> a mètode</td>
</tr>
<tr>
<td>FormArray sempre buit després d'eliminar tot</td>
<td>No es recrea FormArray després de <code>.clear()</code></td>
<td>Després de <code>.clear()</code> fer <code>.push(crearControl())</code></td>
</tr>
</tbody>
</table>
<h4>3.13.2. Errors de configuració</h4>
<table class="table table-bordered">
<thead>
<tr>
<th>Error</th>
<th>Solució Windows</th>
<th>Solució Linux/macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>formArrayName must be used with parent formGroup</code></td>
<td>Assegurar <code>&lt;form [formGroup]="formulari"&gt;</code> envolta</td>
<td>Assegurar <code>&lt;form [formGroup]="formulari"&gt;</code> envolta</td>
</tr>
<tr>
<td><code>Cannot read property 'at' of undefined</code></td>
<td>Verificar <code>get variants(): FormArray</code> retorna correctament</td>
<td>Verificar <code>get variants(): FormArray</code> retorna correctament</td>
</tr>
<tr>
<td><code>Expected validator to return Promise or Observable</code></td>
<td>FormArray no suporta validadors asíncrons nativamente</td>
<td>FormArray no suporta validadors asíncrons nativamente</td>
</tr>
<tr>
<td>TypeScript error: <code>Type 'AbstractControl' is not assignable to 'FormGroup'</code></td>
<td>Usar <code>as FormGroup</code> o <code>as FormArray</code> explícitament</td>
<td>Usar <code>as FormGroup</code> o <code>as FormArray</code> explícitament</td>
</tr>
<tr>
<td><code>removeAt() index out of range</code></td>
<td>Comprovar <code>if (index >= 0 && index &lt; array.length)</code></td>
<td>Comprovar <code>if (index >= 0 && index &lt; array.length)</code></td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="3.13" titol="Resolució de problemes (Win/macOS/Linux)" contingut=section_point_3_13 %}

  {% capture section_point_3_14 %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert Angular FormArray. <strong>Context:</strong> Estic dissenyant un formulari de comanda amb múltiples productes que es poden afegir dinàmicament. <strong>Tasca:</strong> Genera una taula comparativa completa entre FormGroup, FormArray i FormControl amb cas d'ús, sintaxi, accés a valors, validacions, quan usar cada un i exemples de codi per cada estructura. <strong>Format:</strong> Taula amb 7 columnes i exemples de codi TypeScript per cada fila." %}

{% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de formularis complexos Angular. <strong>Context:</strong> Necessito implementar un formulari d'inscripció a esdeveniment amb assistents dinàmics i preferències alimentàries. <strong>Tasca:</strong> Crea un checklist exhaustiu de 20 punts per validar que un formulari complex amb FormArrays funciona correctament abans de passar a producció, incloent: estructura correcta, validacions, gestió d'errors, límits, performance, accessibilitat i testing. <strong>Format:</strong> Llista numerada amb descripció detallada de cada punt." %}

{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en gestió d'estat Angular. <strong>Context:</strong> Tinc un formulari amb FormArray i FormGroup niat i necessito entendre com gestionar valors. <strong>Tasca:</strong> Explica amb exemples de codi detallats les diferències entre <code>setValue()</code>, <code>patchValue()</code> i <code>reset()</code>, incloent quan usar cada un, errors comuns, comportament amb FormArrays niuats i com gestionar valors parcials. Proporciona 3 casos d'ús reals per cada mètode. <strong>Format:</strong> Guia amb taula comparativa i 9 exemples de codi comentats." %}

{% include prompt-ai.html contingut="<strong>Rol:</strong> Desenvolupador Angular senior. <strong>Context:</strong> Estic creant un formulari de catàleg amb variants dinàmiques de producte. <strong>Tasca:</strong> Genera un formulari Angular complet d'inscripció a esdeveniment amb: dades personals (FormGroup niat amb nom, cognoms, email, telèfon), múltiples assistents (FormArray de FormGroups amb nom, edat, dieta), preferències alimentàries (FormArray de FormControls), validacions creuades entre camps, límits (mínim 1 assistent, màxim 10), i gestió completa amb afegir/eliminar. <strong>Format:</strong> Codi TypeScript complet del component + template HTML + validadors personalitzats." %}

{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en patrons avançats Angular. <strong>Context:</strong> Necessito optimitzar formularis amb FormArrays grans i implementar funcionalitats avançades. <strong>Tasca:</strong> Descriu 7 patrons avançats per gestionar FormArrays: 1) reordenar elements amb drag & drop, 2) validacions creuades entre elements del FormArray, 3) auto-guardat temporal a localStorage, 4) duplicar elements existents, 5) límits dinàmics segons altres camps, 6) performance optimization amb trackBy i OnPush, 7) exportar/importar FormArray com JSON. Per cada patró proporciona explicació, cas d'ús, codi TypeScript complet i avantatges/inconvenients. <strong>Format:</strong> 7 seccions amb codi executable i taula resum final." %}
  {% endcapture %}
  {% include section-point.html numero="3.14" titol="Prompts d'IA" contingut=section_point_3_14 %}

  {% capture section_point_3_15 %}
<h4>Conceptes teòrics</h4>
{% include checklist.html elements="Comprenc la diferència entre FormArray i FormGroup|Entenc quan usar FormArray (col·leccions dinàmiques) vs FormGroup (agrupació lògica)|Sé què és el mètode factory per crear controls dinàmics|Comprenc les diferències entre setValue(), patchValue() i reset()|Entenc com niuar FormGroups dins d'altres FormGroups per organització lògica" %}
<h4>Habilitats pràctiques</h4>
{% capture checklist_practiques %}Puc crear FormArray amb <code>fb.array([...])</code> de FormControls o FormGroups|Sé afegir controls amb <code>.push(nouControl)</code> dinàmicament|Puc eliminar controls amb <code>.removeAt(index)</code> i gestionar índexs|Sé accedir a controls amb <code>.at(index)</code> i iterar amb <code>.controls</code>|Puc crear FormGroups niuats per organitzar camps relacionats|Sé aplicar validacions a FormArray complet (minLength, maxLength)|Puc validar cada control dins FormArray individualment|Sé mostrar errors tant a nivell FormArray com FormControl|Puc implementar mètodes factory per crear controls consistents|Sé gestionar límits (mínim/màxim) amb botons deshabilitant|Entenc com usar trackBy per optimitzar *ngFor en FormArrays grans|Puc marcar tots els controls com a tocats abans d'enviar|Sé quan usar setValue() (TOTS els camps) vs patchValue() (ALGUNS camps)|Puc usar reset() per netejar formulari amb valors opcionals|Sé carregar formularis complexos des d'API amb setValue{% endcapture %}
{% include checklist.html elements=checklist_practiques %}
<h4>Resolució de problemes</h4>
{% include checklist.html elements="Sé diagnosticar error 'Cannot find control with name'|Puc solucionar problemes de setValue() amb camps faltants|Entenc com gestionar índexs correctament després d'eliminar controls" %}
  {% endcapture %}
  {% include section-point.html numero="3.15" titol="Autoavaluació" contingut=section_point_3_15 %}

  {% capture section_point_3_16 %}
<p>Disposeu de formularis complexos completament funcionals amb estructures jeràrquiques mitjançant FormGroups niuats per organitzar camps relacionats lògicament com adreces amb carrer ciutat i codi postal agrupats amb accés net utilitzant notació punt i validacions a nivell de grup, i col·leccions dinàmiques amb FormArrays que permeten a l'usuari afegir o eliminar controls en temps d'execució per gestionar múltiples telèfons emails o variants de producte amb límits mínim i màxim implementats i feedback visual. El projecte inclou mètodes factory com crearVariant i crearTelefon que centralitzen la configuració de controls amb validacions i valors per defecte facilitant el manteniment amb un sol lloc per canviar la lògica, gestió precisa de valors dominant setValue per càrrega completa des d'API patchValue per actualitzacions parcials de camps específics i reset per neteja amb valors inicials personalitzats segons cada necessitat, validacions completes aplicades a FormArray complet amb minLength i maxLength a controls individuals dins el FormArray i validadors custom per duplicats amb missatges contextuals per cada nivell, patrons de performance amb trackBy en ngFor per optimitzar renderitzat getters per accés eficient i marcar controls tocats abans d'enviar per mostrar tots els errors, i documentació exhaustiva amb taules d'estructures utilitzades patrons implementats bones pràctiques proves realitzades i decisions de disseny registrades al dossier tècnic. La base de formularis complexos establerta serveix com a fonament per qualsevol aplicació professional amb requisits dinàmics i adaptatius.</p>
  {% endcapture %}
  {% include section-point.html numero="3.16" titol="Síntesi" contingut=section_point_3_16 %}

  {% capture section_point_3_17 %}
{% include definicio.html terme="FormArray" definicio="Col·lecció dinàmica: <code>fb.array([control1, control2])</code>. Afegir: <code>.push(nouControl)</code>. Eliminar: <code>.removeAt(index)</code>. Accés: <code>.at(index)</code> o <code>.controls[index]</code>. Neteja: <code>.clear()</code>." %}

{% include definicio.html terme="FormGroup niat" definicio="Estructura jeràrquica: <code>fb.group({ grup: fb.group({...}) })</code>. Accés: notació punt <code>.get('grup.camp')</code> o encadenament <code>.get('grup')?.get('camp')</code>. Template: <code>formGroupName=\"nom\"</code>. Organització: agrupar camps relacionats lògicament." %}

{% include definicio.html terme="Mètodes factory" definicio="Funció que retorna FormGroup o FormControl. Centralitza configuració i validacions. Exemple: <code>crearTelefon(): FormGroup { return fb.group({...}) }</code>. Reutilitzable i testejable." %}

{% include definicio.html terme="setValue vs patchValue vs reset" definicio="setValue: assignar TOTS els camps (error si falta algun). patchValue: assignar ALGUNS camps (altres no modificats). reset: netejar amb valors opcionals inicials." %}

{% include definicio.html terme="Validacions" definicio="FormArray complet: <code>fb.array([...], [Validators.minLength(1)])</code>. Control individual: validacions a cada FormControl del factory. FormGroup dins FormArray: validadors a nivell grup." %}

{% include definicio.html terme="Template FormArray" definicio="<code>formArrayName=\"nom\"</code> al contenidor. <code>*ngFor=\"let item of items.controls; let i = index\"</code>. <code>[formGroupName]=\"i\"</code> per FormGroups dins FormArray. <code>[formControlName]=\"i\"</code> per FormControls dins FormArray." %}

{% include definicio.html terme="Patrons" definicio="TrackBy: optimitzar *ngFor amb <code>trackBy: trackByIndex</code>. Límits: deshabilitar botons quan assoleixen min/max. Marcar tocats: iterar controls abans d'enviar. Getters: accés net a FormArray i FormGroups." %}

{% include definicio.html terme=".push()" definicio="Afegir control al final del FormArray: <code>formArray.push(nouControl)</code>." %}

{% include definicio.html terme=".removeAt(i)" definicio="Eliminar control a l'índex i: <code>formArray.removeAt(2)</code>. Els índexs es recalculen automàticament." %}

{% include definicio.html terme=".at(i)" definicio="Accedir a control a l'índex i: <code>formArray.at(0)</code>. Retorna AbstractControl." %}

{% include definicio.html terme=".clear()" definicio="Buidar FormArray completament: <code>formArray.clear()</code>. Normalment seguit de <code>.push()</code> per afegir control buit." %}

{% include definicio.html terme="trackBy" definicio="Funció per optimitzar *ngFor: <code>trackBy: trackByIndex</code>. Evita recrear DOM innecessàriament." %}
  {% endcapture %}
  {% include section-point.html numero="3.17" titol="Repàs de conceptes" contingut=section_point_3_17 %}

</div>
