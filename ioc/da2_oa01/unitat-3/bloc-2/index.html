---
layout: bloc
title: "Bloc 2: Models de dades i transformació"
description: "Definició de models TypeScript, adaptadors de dades i integració reactiva"
keywords: "models, typescript, interfícies, adaptadors, transformació dades"
unitat: 3
bloc: 2
bloc_numero: 2
---

<!-- SECCIÓ 1: Definició de models amb interfícies -->
<div class="section" id="Unitat3_Bloc2_Seccio1">
  <h2 id="Unitat3_Bloc2_Seccio1">1. Definició de models amb interfícies</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=2 seccio=1 %}


  {% include objectius.html llista="Definir interfícies TypeScript que descriuen l'estructura de les dades del catàleg i respostes d'API|Diferenciar propietats obligatòries i opcionals utilitzant la sintaxi correcta|Organitzar models en carpetes coherents i tipar serveis i components per detectar errors en temps de desenvolupament" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 1</strong> — Defineix models de dades i estructures adequades al cas d'ús.<br><strong>RA3 · Criteri 5</strong> — Documenta el flux de dades i les decisions preses per garantir mantenibilitat." %}

  {% capture section_point_1_1 %}
    <p>Abans de començar, necessiteu:</p>
    <ul>
      <li><strong>Lectures 3.1.1–3.1.3 completades:</strong> Servei <code>ElementService</code> funcional amb peticions HTTP, gestió d'estats (càrrega/error) i documentació a <code>docs/serveis.md</code>.</li>
      <li><strong>Projecte Angular operatiu:</strong> Catàleg d'elements amb dades carregades des de <code>json-server</code> o API mock.</li>
      <li><strong>TypeScript configurat:</strong> Compilació sense errors (<code>ng serve</code> funciona correctament).</li>
      <li><strong>Control de versions net:</strong> <code>git status</code> mostra working directory net (sense canvis pendents).</li>
    </ul>
    <p><strong>Verificació ràpida:</strong></p>
    {% capture code_201 %}# Terminal 1: API mock
json-server --watch db.json --port 4301
# Terminal 2: Angular
ng serve --port 4300
# Navegador
# http://localhost:4300 → Catàleg es carrega correctament{% endcapture %}
    {% include code-block.html lang="bash" code=code_201 %}
    <p><strong>Punt d'autocomprovació:</strong> El catàleg mostra elements amb camps <code>id</code>, <code>nom</code>, <code>descripcio</code>, <code>categoria</code>, <code>preu</code>. Si algun camp no apareix, reviseu les dades mock abans de continuar.</p>
  {% endcapture %}
  {% include section-point.html numero="1.1" titol="Prerequisits" contingut=section_point_1_1 %}

  {% capture section_point_1_2 %}
    <h4>1.2.1. Què són les interfícies TypeScript</h4>
    <p>Les interfícies TypeScript són <strong>contractes de dades</strong> que defineixen la forma exacta que han de tenir els objectes. Actuen com un plànol arquitectònic: especifiquen quins camps existeixen, quin tipus tenen, i quins són obligatoris vs opcionals.</p>
    <p>A diferència de JavaScript pur, on els objectes poden tenir qualsevol propietat en qualsevol moment, TypeScript amb interfícies permet <strong>validar l'estructura en temps de compilació</strong>, abans que el codi s'executi al navegador.</p>
    <h4>1.2.2. Problema sense models tipats</h4>
    <p><strong>Situació abans:</strong></p>
    <p>Quan treballeu amb JavaScript pur o TypeScript sense interfícies, els objectes no tenen estructura garantida. Això genera múltiples problemes:</p>
    {% capture code_202 %}// Servei SENSE interfícies (PROBLEMÀTIC)
carregarElements(): void {
  this.http.get('http://localhost:4301/elements').subscribe({
    next: (dades: any) => {
      // "any" = qualsevol cosa, cap validació
      this.elements = dades;
      // Què passa si l'API canvia "nom" per "title"?
      // Què passa si "preu" ara és string en lloc de number?
      // NO ho sabreu fins que l'aplicació falli en producció
    }
  });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_202 %}
    {% capture code_203 %}// Component SENSE interfícies (PROBLEMÀTIC)
mostrarElement(element: any): void {
  console.log(element.nom);        // Funciona? Qui sap
  console.log(element.descripcio); // Existeix? Potser
  console.log(element.preu);       // És number o string? Misteri
  // Error tècnic comú: typo en el nom de propietat
  console.log(element.descrpicio); // TYPO! Però TypeScript no l'atrapa
  // Runtime: undefined → Error silenciós
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_203 %}
    <p><strong>Problemes que genera:</strong></p>
    <p><strong>1. Errors silenciosos en temps d'execució</strong></p>
    <p>Quan accediu a una propietat inexistent (<code>element.descrpicio</code>), JavaScript retorna <code>undefined</code> sense avisar. L'aplicació sembla funcionar però mostra dades buides o incorrectes. Aquests errors són molt difícils de detectar perquè no provoquen excepcions visibles.</p>
    {% capture code_204 %}// Exemple real d'error silenciós
const preu = element.preu * 1.21; // Si preu és undefined → NaN
console.log(`Preu amb IVA: ${preu}€`); // "Preu amb IVA: NaN€"
// L'usuari veu "NaN€" però l'aplicació no ha llançat cap error{% endcapture %}
    {% include code-block.html lang="typescript" code=code_204 %}
    <p><strong>2. Canvis al backend no detectats</strong></p>
    <p>Si l'API canvia el nom d'un camp de <code>nom</code> a <code>title</code>, el vostre codi continua compilant correctament perquè TypeScript no valida res amb <code>any</code>. L'error només apareix quan un usuari real accedeix a la pàgina i veu camps buits.</p>
    <p><strong>3. Manca d'autocompletat</strong></p>
    <p>L'IDE no pot oferir suggeriments de propietats perquè no sap quins camps té l'objecte. Heu de recordar (o buscar a la documentació) cada nom de camp exacte, incrementant el risc d'errors tipogràfics.</p>
    <p><strong>4. Refactoring impossible</strong></p>
    <p>Si voleu canviar el nom d'una propietat en tota l'aplicació, no podeu fer "Find & Replace" automàtic perquè TypeScript no sap on s'utilitza aquella propietat. Heu de buscar manualment a tots els fitxers.</p>
    <p><strong>5. Documentació inexistent</strong></p>
    <p>Quan un desenvolupador nou arriba al projecte, no té forma de saber quina estructura tenen les dades sense llegir el codi sencer o provar l'aplicació.</p>
    <h4>1.2.3. Solució amb models tipats</h4>
    <p><strong>Angular + TypeScript amb interfícies proporciona seguretat de tipus:</strong></p>
    {% capture code_205 %}// Model amb interfície (CORRECTE)
export interface ElementCataleg {
  id: number;
  nom: string;
  descripcio: string;
  categoria: string;
  preu: number;
  imatge: string;
  destacat?: boolean;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_205 %}
    {% capture code_206 %}// Servei AMB interfície (CORRECTE)
carregarElements(): void {
  this.http.get<ElementCataleg[]>('http://localhost:4301/elements')
    .subscribe({
      next: (dades: ElementCataleg[]) => {
        this.elements.set(dades);
        // TypeScript garanteix que cada element té:
        // - id (number)
        // - nom (string)
        // - descripcio (string)
        // - categoria (string)
        // - preu (number)
        // - imatge (string)
        // - destacat? (boolean opcional)
      }
    });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_206 %}
    {% capture code_207 %}// Component AMB interfície (CORRECTE)
mostrarElement(element: ElementCataleg): void {
  console.log(element.nom);        // TypeScript sap que existeix
  console.log(element.descripcio); // TypeScript sap que és string
  console.log(element.preu);       // TypeScript sap que és number
  // TYPO detectat IMMEDIATAMENT:
  console.log(element.descrpicio);
  // Error de compilació: Property 'descrpicio' does not exist on type 'ElementCataleg'
  // L'IDE marca l'error amb subratllat vermell ABANS d'executar
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_207 %}
    <p><strong>Avantatges obtinguts:</strong></p>
    <table>
      <thead>
        <tr>
          <th>Aspecte</th>
          <th>Sense interfícies</th>
          <th>AMB interfícies</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Detecció d'errors</strong></td>
          <td>Runtime (producció)</td>
          <td>Compile-time (desenvolupament)</td>
        </tr>
        <tr>
          <td><strong>Autocompletat IDE</strong></td>
          <td>Cap</td>
          <td>Complet amb documentació</td>
        </tr>
        <tr>
          <td><strong>Refactoring</strong></td>
          <td>Manual i propens a errors</td>
          <td>Automàtic i segur</td>
        </tr>
        <tr>
          <td><strong>Documentació</strong></td>
          <td>Externa (si existeix)</td>
          <td>Integrada al codi</td>
        </tr>
        <tr>
          <td><strong>Canvis backend</strong></td>
          <td>Errors silenciosos</td>
          <td>Errors de compilació immediats</td>
        </tr>
        <tr>
          <td><strong>Onboarding equip</strong></td>
          <td>Llarg i confús</td>
          <td>Ràpid amb contractes clars</td>
        </tr>
        <tr>
          <td><strong>Confiança en el codi</strong></td>
          <td>Baixa (sempre dubteu)</td>
          <td>Alta (el compilador valida)</td>
        </tr>
      </tbody>
    </table>
    <h4>1.2.4. Exemple comparat: Sense vs AMB interfície</h4>
    <p><strong>Escenari:</strong> L'API canvia <code>preu</code> de <code>number</code> a <code>string</code>.</p>
    <p><strong>SENSE interfície:</strong></p>
    {% capture code_208 %}// Codi continua compilant
const element: any = { id: 1, nom: 'Taula', preu: "99.90" };
const preuAmbIVA = element.preu * 1.21;
console.log(preuAmbIVA); // NaN (error silenciós en producció){% endcapture %}
    {% include code-block.html lang="typescript" code=code_208 %}
    <p><strong>AMB interfície:</strong></p>
    {% capture code_209 %}// Codi FALLA a compilar
interface ElementCataleg {
  id: number;
  nom: string;
  preu: number;
}
const element: ElementCataleg = { id: 1, nom: 'Taula', preu: "99.90" };
// Error TS2322: Type 'string' is not assignable to type 'number'
// L'error es detecta ABANS de desplegar a producció{% endcapture %}
    {% include code-block.html lang="typescript" code=code_209 %}
    <h4>1.2.5. Integració amb lectures anteriors</h4>
    <ul>
      <li><strong>Lectura 3.1.1 (Serveis):</strong> Els models s'utilitzen com a tipus de retorn dels mètodes del servei (<code>carregarElements(): ElementCataleg[]</code>).</li>
      <li><strong>Lectura 3.1.2 (Peticions HTTP):</strong> Les peticions HTTP es tipen amb genèrics: <code>this.http.get&lt;ElementCataleg[]&gt;(url)</code>.</li>
      <li><strong>Lectura 3.1.3 (Gestió d'errors):</strong> Els models permeten validar que les dades rebudes tenen l'estructura esperada abans de mostrar-les.</li>
      <li><strong>Lectura 2.1.1 (Components):</strong> Els <code>@Input()</code> dels components es tipen amb models per garantir que reben dades correctes.</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="1.2" titol="Marc conceptual" contingut=section_point_1_2 %}

  {% capture section_point_1_3 %}
    <p>Penseu en les interfícies TypeScript com <strong>plànols d'arquitectura</strong> per a les vostres dades:</p>
    <ul>
      <li><strong>Contracte explícit:</strong> Cada interfície és un document que diu "aquestes són les dades que accepto, ni més ni menys".</li>
      <li><strong>Validació automàtica:</strong> TypeScript actua com un inspector que verifica que cada objecte compleix el plànol.</li>
      <li><strong>Documentació viva:</strong> Quan obriu una interfície, veieu immediatament quina estructura tenen les dades, sense buscar documentació externa.</li>
    </ul>
    <p><strong>Analogia:</strong> Si les dades fossin peces de LEGO, la interfície seria el manual d'instruccions que diu quines peces necessiteu i on van. Sense manual (sense interfície), podeu intentar encaixar peces a l'atzar i potser funcionarà... o potser no.</p>
    <p><strong>Conceptes clau:</strong></p>
    <ul>
      <li><strong>Propietats obligatòries:</strong> Camps que SEMPRE han d'existir (<code>nom: string</code>).</li>
      <li><strong>Propietats opcionals:</strong> Camps que PODEN existir o no (<code>destacat?: boolean</code>).</li>
      <li><strong>Tipatge estricte:</strong> Cada propietat té un tipus concret (<code>number</code>, <code>string</code>, <code>boolean</code>).</li>
      <li><strong>Organització modular:</strong> Una interfície per fitxer, exportades i importades on calgui.</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="1.3" titol="Model mental" contingut=section_point_1_3 %}

  {% capture section_point_1_4 %}
    <h4>1.4.1. Objectiu</h4>
    <p>Comprendre per què necessitem models TypeScript tipats i quins problemes resolen al desenvolupament d'aplicacions Angular: contractes de dades explícits, autocompletat intel·ligent i detecció d'errors abans d'executar el codi.</p>
    <h4>1.4.2. Contracte de dades explícit</h4>
    <p>Un model TypeScript actua com un <strong>contracte formal</strong> entre diferents parts de l'aplicació. Quan el servei retorna <code>ElementCataleg[]</code>, el component que el consumeix sap amb certesa quina estructura tindrà.</p>
    {% capture code_210 %}// El contracte garanteix:
interface ElementCataleg {
  id: number;       // Sempre existeix, sempre és number
  nom: string;      // Sempre existeix, sempre és string
  preu: number;     // Sempre existeix, sempre és number
  destacat?: boolean; // Pot existir o no, si existeix és boolean
}
// Servei s'ajusta al contracte
obtenirElements(): ElementCataleg[] {
  return this.elements(); // TypeScript valida que coincideix
}
// Component confia en el contracte
mostrarNom(element: ElementCataleg): void {
  console.log(element.nom.toUpperCase());
  // Segur: nom existeix i és string (té .toUpperCase())
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_210 %}
    <h4>1.4.3. Autocompletat intel·ligent</h4>
    <p>Amb models tipats, l'IDE (VS Code) ofereix <strong>autocompletat precís</strong> mentre escriviu:</p>
    {% capture code_211 %}function calcularPreuFinal(element: ElementCataleg): number {
  // En escriure "element.", l'IDE mostra:
  // - id: number
  // - nom: string
  // - descripcio: string
  // - categoria: string
  // - preu: number
  // - imatge: string
  // - destacat?: boolean
  return element.preu * 1.21; // Autocompletat suggereix "preu"
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_211 %}
    <p>Sense models (<code>element: any</code>), l'IDE no pot ajudar perquè no sap quines propietats existeixen.</p>
    <h4>1.4.4. Detecció d'errors en temps de desenvolupament</h4>
    <p>Els models permeten detectar errors <strong>durant l'escriptura</strong> en lloc de descobrir-los en producció.</p>
    <p><strong>Errors detectats automàticament:</strong></p>
    {% capture code_212 %}interface ElementCataleg {
  id: number;
  nom: string;
  preu: number;
}
const element: ElementCataleg = {
  id: 1,
  nom: 'Cadira',
  preu: '49.90' // Error: Type 'string' is not assignable to type 'number'
};
function mostrar(el: ElementCataleg): void {
  console.log(el.nomm); // Error: Property 'nomm' does not exist
  console.log(el.preu.toUpperCase()); // Error: Property 'toUpperCase' does not exist on type 'number'
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_212 %}
    <h4>1.4.5. Taula comparativa: Amb vs sense models</h4>
    <table>
      <thead>
        <tr>
          <th>Situació</th>
          <th>Sense models (<code>any</code>)</th>
          <th>AMB models (<code>ElementCataleg</code>)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Typo en propietat</td>
          <td>Runtime error (producció)</td>
          <td>Compile error (desenvolupament)</td>
        </tr>
        <tr>
          <td>Tipus incorrecte</td>
          <td>Runtime error (NaN, undefined)</td>
          <td>Compile error (type mismatch)</td>
        </tr>
        <tr>
          <td>Canvi backend</td>
          <td>Error silenciós</td>
          <td>Compile error immediat</td>
        </tr>
        <tr>
          <td>Autocompletat</td>
          <td>No disponible</td>
          <td>Complet amb tipus</td>
        </tr>
        <tr>
          <td>Refactoring</td>
          <td>Manual, propens a errors</td>
          <td>Automàtic amb "Rename Symbol"</td>
        </tr>
        <tr>
          <td>Documentació</td>
          <td>Externa (si existeix)</td>
          <td>Integrada al codi</td>
        </tr>
        <tr>
          <td>Onboarding equip</td>
          <td>Lent (aprendre API de memòria)</td>
          <td>Ràpid (models auto-documentats)</td>
        </tr>
      </tbody>
    </table>
    <p><strong>Context d'integració:</strong> Els models complementen el sistema de gestió d'errors (Lectura 3.1.3) perquè permeten validar que les dades rebudes de l'API tenen l'estructura esperada.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_213 %}// Proveu de crear un objecte amb tipus incorrecte:
const test: ElementCataleg = {
  id: "abc", // TypeScript marca error immediatament
  nom: 123,  // TypeScript marca error immediatament
  preu: true // TypeScript marca error immediatament
};
// VS Code subratlla en vermell abans de compilar{% endcapture %}
    {% include code-block.html lang="typescript" code=code_213 %}
  {% endcapture %}
  {% include section-point.html numero="1.4" titol="Per què necessitem models: contracte de dades, autocomplete, detecció d'errors" contingut=section_point_1_4 %}

  {% capture section_point_1_5 %}
    <h4>1.5.1. Objectiu</h4>
    <p>Aprendre la sintaxi <code>interface</code> de TypeScript per definir l'estructura d'objectes, incloent propietats, tipus disponibles, i com exportar i importar interfícies entre fitxers.</p>
    <h4>1.5.2. Sintaxi <code>interface</code> TypeScript</h4>
    <p>Una interfície es defineix amb la paraula clau <code>interface</code> seguida del nom (en PascalCase) i un bloc amb les propietats:</p>
    {% capture code_214 %}interface NomInterficie {
  propietat1: tipus1;
  propietat2: tipus2;
  propietat3: tipus3;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_214 %}
    <p><strong>Exemple bàsic:</strong></p>
    {% capture code_215 %}interface Usuari {
  id: number;
  nom: string;
  correu: string;
  edat: number;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_215 %}
    <h4>1.5.3. Propietats i tipus disponibles</h4>
    <p>Cada propietat té un nom i un tipus. TypeScript ofereix molts tipus:</p>
    <p><strong>Tipus primitius:</strong></p>
    {% capture code_216 %}interface Exemple {
  text: string;        // Cadena de text
  nombre: number;      // Nombre (enter o decimal)
  boolea: boolean;     // true o false
  qualsevol: any;      // Qualsevol tipus (evitar!)
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_216 %}
    <p><strong>Arrays:</strong></p>
    {% capture code_217 %}interface Producte {
  etiquetes: string[];     // Array de strings
  preus: number[];         // Array de numbers
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_217 %}
    <p><strong>Objectes niats:</strong></p>
    {% capture code_218 %}interface Direccio {
  carrer: string;
  ciutat: string;
  codiPostal: string;
}
interface Usuari {
  nom: string;
  direccio: Direccio;  // Objecte niat amb altra interfície
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_218 %}
    <h4>1.5.4. Export/import d'interfícies</h4>
    <p>Per reutilitzar interfícies entre fitxers, utilitzeu <code>export</code> i <code>import</code>:</p>
    <p><strong>Fitxer: <code>src/app/models/element.model.ts</code></strong></p>
    {% capture code_219 %}export interface ElementCataleg {
  id: number;
  nom: string;
  preu: number;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_219 %}
    <p><strong>Fitxer: <code>src/app/serveis/element.service.ts</code></strong></p>
    {% capture code_220 %}import { ElementCataleg } from '../models/element.model';
@Injectable({ providedIn: 'root' })
export class ElementService {
  elements = signal<ElementCataleg[]>([]);
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_220 %}
    <h4>1.5.5. Nomenclatura i convencions</h4>
    <p><strong>Bones pràctiques:</strong></p>
    <ul>
      <li>Noms en <strong>PascalCase</strong>: <code>ElementCataleg</code>, <code>RespostaAPI</code>, <code>ConfiguracioUsuari</code></li>
      <li>Noms descriptius: <code>Usuari</code> millor que <code>U</code>, <code>ElementCataleg</code> millor que <code>Elem</code></li>
      <li>Evitar abreviatures: <code>descripcio</code> millor que <code>desc</code></li>
      <li>Fitxers amb extensió <code>.model.ts</code>: <code>element.model.ts</code>, <code>usuari.model.ts</code></li>
    </ul>
    <p><strong>Exemple complet:</strong></p>
    {% capture code_221 %}// src/app/models/element.model.ts
/**
 * Model d'un element del catàleg
 */
export interface ElementCataleg {
  /** Identificador únic de l'element */
  id: number;
  /** Nom de l'element */
  nom: string;
  /** Descripció detallada */
  descripcio: string;
  /** Categoria a la qual pertany */
  categoria: string;
  /** Preu en euros */
  preu: number;
  /** URL de la imatge principal */
  imatge: string;
  /** Indica si és un element destacat (opcional) */
  destacat?: boolean;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_221 %}
    <p><strong>Context d'integració:</strong> Les interfícies es combinen amb signals (Lectura 2.2.2) per mantenir dades reactives tipades: <code>signal&lt;ElementCataleg[]&gt;([])</code>.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_222 %}// Creeu un objecte que compleixi la interfície:
const element: ElementCataleg = {
  id: 1,
  nom: 'Taula',
  descripcio: 'Taula de fusta',
  categoria: 'Mobles',
  preu: 199.90,
  imatge: '/assets/taula.jpg'
};
// Compila correctament
// Intenteu ometre una propietat obligatòria:
const elementIncorrecte: ElementCataleg = {
  id: 2,
  nom: 'Cadira'
  // Error: Property 'descripcio' is missing
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_222 %}
  {% endcapture %}
  {% include section-point.html numero="1.5" titol="Interfícies: definició de l'estructura d'un objecte" contingut=section_point_1_5 %}

  {% capture section_point_1_6 %}
    <h4>1.6.1. Objectiu</h4>
    <p>Crear la primera interfície TypeScript per al model <code>ElementCataleg</code>, identificant camps necessaris, documentant amb JSDoc, i integrant-la al servei amb tipatge fort.</p>
    <h4>1.6.2. Identificar camps necessaris</h4>
    <p>Abans de crear la interfície, analitzeu quines dades necessiteu. Per al catàleg d'elements, els camps essencials són:</p>
    <ul>
      <li><strong>Identificador únic:</strong> <code>id</code> (número)</li>
      <li><strong>Informació bàsica:</strong> <code>nom</code>, <code>descripcio</code>, <code>categoria</code> (strings)</li>
      <li><strong>Preu:</strong> <code>preu</code> (número)</li>
      <li><strong>Visual:</strong> <code>imatge</code> (string amb URL)</li>
      <li><strong>Opcionals:</strong> <code>destacat</code>, <code>dataPublicacio</code></li>
    </ul>
    <h4>1.6.3. Creació del fitxer de model</h4>
    <p><strong>Pas 1:</strong> Crear carpeta <code>models</code> si no existeix:</p>
    {% capture code_223 %}mkdir src/app/models{% endcapture %}
    {% include code-block.html lang="bash" code=code_223 %}
    <p><strong>Pas 2:</strong> Crear fitxer <code>element.model.ts</code>:</p>
    {% capture code_224 %}ng generate interface models/element
# O manualment: touch src/app/models/element.model.ts{% endcapture %}
    {% include code-block.html lang="bash" code=code_224 %}
    <p><strong>Pas 3:</strong> Definir la interfície amb JSDoc:</p>
    {% capture code_225 %}// src/app/models/element.model.ts
/**
 * Representa un element del catàleg
 *
 * @property {number} id - Identificador únic de l'element
 * @property {string} nom - Nom descriptiu de l'element
 * @property {string} descripcio - Descripció detallada del producte
 * @property {string} categoria - Categoria a la qual pertany (ex: 'Mobles', 'Electrònica')
 * @property {number} preu - Preu en euros (sense IVA)
 * @property {string} imatge - URL relativa o absoluta de la imatge principal
 * @property {boolean} [destacat] - Indica si l'element apareix destacat (opcional)
 * @property {string} [dataPublicacio] - Data de publicació en format ISO (opcional)
 */
export interface ElementCataleg {
  id: number;
  nom: string;
  descripcio: string;
  categoria: string;
  preu: number;
  imatge: string;
  destacat?: boolean;
  dataPublicacio?: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_225 %}
    <h4>1.6.4. Documentació amb JSDoc</h4>
    <p>JSDoc permet afegir comentaris que l'IDE mostra com a tooltips quan passeu el cursor per sobre:</p>
    {% capture code_226 %}/**
 * Comentari general de la interfície
 */
export interface ElementCataleg {
  /** Comentari d'aquesta propietat concreta */
  id: number;
  /**
   * Comentari multilínia
   * amb més detall
   */
  nom: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_226 %}
    <p><strong>Beneficis:</strong></p>
    <ul>
      <li>Tooltips a l'IDE quan passeu el cursor</li>
      <li>Documentació automàtica generada amb eines com TypeDoc</li>
      <li>Explicacions contextuals per a l'equip</li>
    </ul>
    <h4>1.6.5. Utilització al servei</h4>
    <p>Importeu i utilitzeu la interfície al servei:</p>
    {% capture code_227 %}// src/app/serveis/element.service.ts
import { Injectable, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ElementCataleg } from '../models/element.model';
@Injectable({ providedIn: 'root' })
export class ElementService {
  private readonly http = inject(HttpClient);
  private readonly baseUrl = 'http://localhost:4301';
  // Signal tipat amb la interfície
  private readonly elements = signal<ElementCataleg[]>([]);
  carregarElements(): void {
    // Petició HTTP tipada amb genèric
    this.http.get<ElementCataleg[]>(`${this.baseUrl}/elements`)
      .subscribe({
        next: (dades: ElementCataleg[]) => {
          this.elements.set(dades);
          // TypeScript valida que 'dades' té l'estructura correcta
        }
      });
  }
  elements$() {
    return this.elements.asReadonly();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_227 %}
    <p><strong>Context d'integració:</strong> La interfície <code>ElementCataleg</code> es combina amb el servei HTTP (Lectura 3.1.2) per tipar les respostes de l'API.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_228 %}// Al servei, proveu d'assignar dades incorrectes:
this.elements.set([
  { id: 1, nom: 'Test', preu: "incorrecte" }
  // Error: Type 'string' is not assignable to type 'number'
]);
// VS Code marca l'error abans de compilar{% endcapture %}
    {% include code-block.html lang="typescript" code=code_228 %}
  {% endcapture %}
  {% include section-point.html numero="1.6" titol="Crear primera interfície: model d'element amb camps essencials" contingut=section_point_1_6 %}

  {% capture section_point_1_7 %}
    <h4>1.7.1. Objectiu</h4>
    <p>Diferenciar propietats obligatòries i opcionals amb la sintaxi <code>?</code>, entendre quan usar cada tipus, i gestionar propietats opcionals correctament al codi.</p>
    <h4>1.7.2. Sintaxi <code>?</code> per propietats opcionals</h4>
    <p>Afegiu <code>?</code> després del nom de la propietat per indicar que és opcional:</p>
    {% capture code_229 %}interface ElementCataleg {
  id: number;           // Obligatori
  nom: string;          // Obligatori
  destacat?: boolean;   // Opcional
}
// Objecte vàlid SENSE la propietat opcional:
const element1: ElementCataleg = {
  id: 1,
  nom: 'Taula'
  // destacat no està present - Vàlid
};
// Objecte vàlid AMB la propietat opcional:
const element2: ElementCataleg = {
  id: 2,
  nom: 'Cadira',
  destacat: true
  // destacat present - També vàlid
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_229 %}
    <h4>1.7.3. Quan usar propietats opcionals</h4>
    <p><strong>Utilitzeu propietats opcionals quan:</strong></p>
    <p><strong>1. L'API pot ometre el camp:</strong> Algunes APIs només retornen camps amb valors, ometent els <code>null</code> o <code>undefined</code>.</p>
    {% capture code_230 %}interface RespostaAPI {
  dades: string;
  error?: string; // Només present si hi ha error
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_230 %}
    <p><strong>2. El camp es calcula posteriorment:</strong> Camps que s'afegeixen després de la càrrega inicial.</p>
    {% capture code_231 %}interface Element {
  id: number;
  nom: string;
  preuAmbIVA?: number; // Es calcula després de carregar
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_231 %}
    <p><strong>3. Funcionalitats progressives:</strong> Camps d'una nova versió de l'API que no tots els clients utilitzen.</p>
    {% capture code_232 %}interface Usuari {
  nom: string;
  avatar?: string; // Afegit a versió 2.0
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_232 %}
    <h4>1.7.4. Quan usar propietats obligatòries</h4>
    <p><strong>Utilitzeu propietats obligatòries quan:</strong></p>
    <p><strong>1. El camp és essencial:</strong> Sense aquest camp, l'objecte no té sentit.</p>
    {% capture code_233 %}interface Usuari {
  id: number;      // Sempre necessari
  nom: string;     // Sempre necessari
  correu: string;  // Sempre necessari
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_233 %}
    <p><strong>2. L'API sempre el retorna:</strong> El backend garanteix que el camp existeix sempre.</p>
    <p><strong>3. El codi assumeix la seva existència:</strong> Si el codi fa <code>element.preu * 1.21</code>, <code>preu</code> ha de ser obligatori.</p>
    <h4>1.7.5. Implicacions en temps d'execució</h4>
    <p><strong>Propietats opcionals requereixen validacions:</strong></p>
    {% capture code_234 %}function mostrarDestacat(element: ElementCataleg): void {
  // Incorrecte: TypeScript no impedeix aquest codi, però falla si destacat és undefined
  if (element.destacat) {
    console.log('Element destacat!');
  }
  // Correcte: Validació explícita
  if (element.destacat === true) {
    console.log('Element destacat!');
  }
  // Correcte: Operador de coalescència nul·la
  const esDestacat = element.destacat ?? false;
  console.log(`Destacat: ${esDestacat}`);
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_234 %}
    <h4>1.7.6. Taula comparativa: Obligatòries vs opcionals</h4>
    <table>
      <thead>
        <tr>
          <th>Aspecte</th>
          <th>Propietat obligatòria</th>
          <th>Propietat opcional</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Sintaxi</strong></td>
          <td><code>nom: string</code></td>
          <td><code>nom?: string</code></td>
        </tr>
        <tr>
          <td><strong>Valor possible</strong></td>
          <td>Mai <code>undefined</code></td>
          <td>Pot ser <code>undefined</code></td>
        </tr>
        <tr>
          <td><strong>Validació codi</strong></td>
          <td>No cal validar existència</td>
          <td>Cal validar abans d'usar</td>
        </tr>
        <tr>
          <td><strong>Ús típic</strong></td>
          <td>Camps essencials (id, nom)</td>
          <td>Camps no crítics (destacat, avatar)</td>
        </tr>
        <tr>
          <td><strong>Impacte omissió</strong></td>
          <td>Error de compilació</td>
          <td><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Compila correctament</td>
        </tr>
        <tr>
          <td><strong>Experiència usuari</strong></td>
          <td>Sempre present a UI</td>
          <td>Pot no mostrar-se</td>
        </tr>
      </tbody>
    </table>
    <h4>1.7.7. Exemple pràctic complet</h4>
    {% capture code_235 %}interface ElementCataleg {
  // Obligatoris: Essencials per identificar i mostrar l'element
  id: number;
  nom: string;
  descripcio: string;
  preu: number;
  // Opcionals: Milloren experiència però no són crítics
  destacat?: boolean;
  descompte?: number;
  dataPublicacio?: string;
  etiquetes?: string[];
}
// Creació amb només obligatoris:
const basic: ElementCataleg = {
  id: 1,
  nom: 'Taula',
  descripcio: 'Taula de fusta',
  preu: 199.90
}; // Vàlid
// Creació amb alguns opcionals:
const complet: ElementCataleg = {
  id: 2,
  nom: 'Cadira',
  descripcio: 'Cadira ergonòmica',
  preu: 89.90,
  destacat: true,
  etiquetes: ['oficina', 'confort']
}; // També vàlid{% endcapture %}
    {% include code-block.html lang="typescript" code=code_235 %}
    <p><strong>Context d'integració:</strong> Les propietats opcionals són especialment útils quan es treballa amb adaptadors (Lectura 3.2.2) que transformen dades externes.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_236 %}// Proveu d'ometre una propietat obligatòria:
const incorrecte: ElementCataleg = {
  id: 1,
  nom: 'Test'
  // Error: Property 'descripcio' is missing
  // Error: Property 'preu' is missing
};
// Proveu d'ometre una propietat opcional:
const correcte: ElementCataleg = {
  id: 1,
  nom: 'Test',
  descripcio: 'Descripció',
  preu: 99.90
  // destacat? omès - Compila correctament
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_236 %}
  {% endcapture %}
  {% include section-point.html numero="1.7" titol="Propietats opcionals vs obligatòries: quan usar cada tipus" contingut=section_point_1_7 %}

  {% capture section_point_1_8 %}
    <h4>1.8.1. Objectiu</h4>
    <p>Dominar els diferents tipus de dades disponibles a TypeScript per definir interfícies: tipus primitius, arrays, objectes niats, i tipus unions per estructures complexes.</p>
    <h4>1.8.2. Tipus primitius</h4>
    <p>TypeScript ofereix tipus bàsics que corresponen als de JavaScript:</p>
    {% capture code_237 %}interface Exemple {
  // String: Cadena de text
  text: string;
  // Number: Nombres enters o decimals
  enter: number;
  decimal: number;
  // Boolean: Cert o fals
  actiu: boolean;
  // Any: Qualsevol tipus (EVITAR!)
  qualsevol: any;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_237 %}
    <p><strong>Exemples d'ús:</strong></p>
    {% capture code_238 %}const dades: Exemple = {
  text: 'Hola món',
  enter: 42,
  decimal: 3.14,
  actiu: true,
  qualsevol: 'pot ser qualsevol cosa'
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_238 %}
    <h4>1.8.3. Arrays tipats</h4>
    <p>Definiu arrays especificant el tipus dels elements:</p>
    {% capture code_239 %}interface Producte {
  // Array de strings
  etiquetes: string[];
  // Array de numbers
  preus: number[];
  // Array d'objectes complexos
  ressenyes: Ressenya[];
}
interface Ressenya {
  autor: string;
  puntuacio: number;
  comentari: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_239 %}
    <p><strong>Sintaxi alternativa:</strong></p>
    {% capture code_240 %}interface Exemple {
  // Forma 1 (recomanada)
  noms: string[];
  // Forma 2 (menys habitual)
  noms: Array<string>;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_240 %}
    <h4>1.8.4. Objectes niats</h4>
    <p>Utilitzeu interfícies dins d'altres interfícies per estructures complexes:</p>
    {% capture code_241 %}interface Direccio {
  carrer: string;
  numero: number;
  ciutat: string;
  codiPostal: string;
  pais: string;
}
interface Usuari {
  id: number;
  nom: string;
  correu: string;
  // Objecte niat amb altra interfície
  direccio: Direccio;
  // Objecte niat opcional
  direccioEnviament?: Direccio;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_241 %}
    <p><strong>Exemple d'ús:</strong></p>
    {% capture code_242 %}const usuari: Usuari = {
  id: 1,
  nom: 'Joan Garcia',
  correu: 'joan@example.com',
  direccio: {
    carrer: 'Gran Via',
    numero: 123,
    ciutat: 'Barcelona',
    codiPostal: '08001',
    pais: 'Espanya'
  }
};
// Accés a propietats niades:
console.log(usuari.direccio.ciutat); // 'Barcelona'{% endcapture %}
    {% include code-block.html lang="typescript" code=code_242 %}
    <h4>1.8.5. Tipus unions</h4>
    <p>Combineu múltiples tipus amb l'operador <code>|</code>:</p>
    {% capture code_243 %}interface Element {
  // Pot ser string o null
  imatge: string | null;
  // Pot ser number o undefined
  descompte: number | undefined;
  // Pot ser un de tres strings literals
  estat: 'disponible' | 'esgotat' | 'precomanda';
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_243 %}
    <p><strong>Exemple d'ús:</strong></p>
    {% capture code_244 %}const element: Element = {
  imatge: null,                  // Vàlid: pot ser null
  descompte: undefined,          // Vàlid: pot ser undefined
  estat: 'disponible'            // Vàlid: un dels literals permesos
};
// Això falla:
const incorrecte: Element = {
  imatge: null,
  descompte: undefined,
  estat: 'en_tramit'  // Error: No és un dels literals permesos
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_244 %}
    <h4>1.8.6. Tipus complexos: exemples pràctics</h4>
    <p><strong>Catàleg d'elements amb totes les variants:</strong></p>
    {% capture code_245 %}interface ElementCataleg {
  // Primitius
  id: number;
  nom: string;
  actiu: boolean;
  // Opcionals
  destacat?: boolean;
  dataPublicacio?: string;
  // Arrays
  etiquetes: string[];
  preus: number[];
  // Objectes niats
  fabricant: Fabricant;
  especificacions?: Especificacions;
  // Unions
  estat: 'disponible' | 'esgotat' | 'precomanda';
  imatge: string | null;
}
interface Fabricant {
  nom: string;
  pais: string;
  web?: string;
}
interface Especificacions {
  pes: number;
  dimensions: {
    ample: number;
    alt: number;
    profunditat: number;
  };
  materials: string[];
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_245 %}
    <h4>1.8.7. Taula de tipus disponibles</h4>
    <table>
      <thead>
        <tr>
          <th>Tipus</th>
          <th>Descripció</th>
          <th>Exemple</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>string</code></td>
          <td>Cadena de text</td>
          <td><code>'Hola'</code>, <code>"món"</code>, <code>`template`</code></td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td>Nombre enter o decimal</td>
          <td><code>42</code>, <code>3.14</code>, <code>-10</code></td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td>Cert o fals</td>
          <td><code>true</code>, <code>false</code></td>
        </tr>
        <tr>
          <td><code>string[]</code></td>
          <td>Array de strings</td>
          <td><code>['a', 'b', 'c']</code></td>
        </tr>
        <tr>
          <td><code>number[]</code></td>
          <td>Array de numbers</td>
          <td><code>[1, 2, 3]</code></td>
        </tr>
        <tr>
          <td><code>InterficieX</code></td>
          <td>Objecte d'altra interfície</td>
          <td><code>{ prop: 'valor' }</code></td>
        </tr>
        <tr>
          <td><code>tipus | null</code></td>
          <td>Pot ser tipus o null</td>
          <td><code>'text'</code> o <code>null</code></td>
        </tr>
        <tr>
          <td><code>tipus | undefined</code></td>
          <td>Pot ser tipus o undefined</td>
          <td><code>42</code> o <code>undefined</code></td>
        </tr>
        <tr>
          <td><code>'literal'</code></td>
          <td>String literal específic</td>
          <td>Només <code>'aquest-valor'</code></td>
        </tr>
        <tr>
          <td><code>any</code></td>
          <td>Qualsevol tipus (EVITAR)</td>
          <td>Desactiva validació</td>
        </tr>
      </tbody>
    </table>
    <p><strong>Context d'integració:</strong> Els tipus complexos es combinen amb validacions (Lectura 2.3.2) per assegurar que les dades compleixen els requisits.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_246 %}// Proveu de crear objectes amb tipus incorrectes:
const test: ElementCataleg = {
  id: 'abc',           // Error: string no assignable a number
  nom: 123,            // Error: number no assignable a string
  actiu: 'sí',         // Error: string no assignable a boolean
  etiquetes: ['a', 1], // Error: number no assignable a string
  estat: 'cancelat'    // Error: no és un literal vàlid
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_246 %}
  {% endcapture %}
  {% include section-point.html numero="1.8" titol="Tipus de dades: text, nombres, booleans, arrays, objectes niats" contingut=section_point_1_8 %}

  {% capture section_point_1_9 %}
    <h4>1.9.1. Objectiu</h4>
    <p>Aprendre a organitzar models TypeScript en carpetes coherents, establir convencions de nomenclatura, utilitzar barrel exports, i documentar contractes de dades.</p>
    <h4>1.9.2. Estructura de carpetes recomanada</h4>
    <p>Organitzeu els models en una carpeta dedicada amb un fitxer per interfície:</p>
    {% capture code_247 %}src/app/models/
├── element.model.ts
├── categoria.model.ts
├── usuari.model.ts
├── comanda.model.ts
├── ressenya.model.ts
└── index.ts (opcional: barrel export){% endcapture %}
    {% include code-block.html lang="text" code=code_247 %}
    <h4>1.9.3. Un fitxer per interfície</h4>
    <p>Cada interfície va al seu propi fitxer per facilitar la reutilització i el manteniment:</p>
    <p><strong><code>element.model.ts</code></strong></p>
    {% capture code_248 %}export interface ElementCataleg {
  id: number;
  nom: string;
  preu: number;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_248 %}
    <p><strong><code>categoria.model.ts</code></strong></p>
    {% capture code_249 %}export interface Categoria {
  id: number;
  nom: string;
  icona: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_249 %}
    <p><strong><code>comanda.model.ts</code></strong></p>
    {% capture code_250 %}import { ElementCataleg } from './element.model';
import { Usuari } from './usuari.model';
export interface Comanda {
  id: number;
  usuari: Usuari;
  elements: ElementCataleg[];
  total: number;
  data: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_250 %}
    <h4>1.9.4. Nomenclatura consistent</h4>
    <p><strong>Convencions:</strong></p>
    <ul>
      <li>Fitxers: <code>nom-entitat.model.ts</code> (kebab-case)</li>
      <li>Interfícies: <code>NomEntitat</code> (PascalCase)</li>
      <li>Exports: <code>export interface NomEntitat</code></li>
    </ul>
    <p><strong>Exemples:</strong></p>
    {% capture code_251 %}element-cataleg.model.ts → export interface ElementCataleg
categoria-producte.model.ts → export interface CategoriaProducte
usuari-administrador.model.ts → export interface UsuariAdministrador{% endcapture %}
    {% include code-block.html lang="text" code=code_251 %}
    <h4>1.9.5. Barrel exports amb index.ts (opcional)</h4>
    <p>Simplifiqueu imports amb un fitxer <code>index.ts</code> que reexporti totes les interfícies:</p>
    <p><strong><code>models/index.ts</code></strong></p>
    {% capture code_252 %}export * from './element.model';
export * from './categoria.model';
export * from './usuari.model';
export * from './comanda.model';
export * from './ressenya.model';{% endcapture %}
    {% include code-block.html lang="typescript" code=code_252 %}
    <p><strong>Avantatge:</strong> Imports més curts i nets:</p>
    {% capture code_253 %}// Sense index.ts (imports individuals):
import { ElementCataleg } from '../models/element.model';
import { Categoria } from '../models/categoria.model';
import { Usuari } from '../models/usuari.model';
// AMB index.ts (import únic):
import { ElementCataleg, Categoria, Usuari } from '../models';{% endcapture %}
    {% include code-block.html lang="typescript" code=code_253 %}
    <h4>1.9.6. Models per domini funcional</h4>
    <p>Per a projectes grans, agrupeu models per domini:</p>
    {% capture code_254 %}src/app/models/
├── cataleg/
│   ├── element.model.ts
│   ├── categoria.model.ts
│   └── ressenya.model.ts
├── usuaris/
│   ├── usuari.model.ts
│   ├── perfil.model.ts
│   └── preferencies.model.ts
└── comandes/
    ├── comanda.model.ts
    ├── linia-comanda.model.ts
    └── estat-comanda.model.ts{% endcapture %}
    {% include code-block.html lang="text" code=code_254 %}
    <h4>1.9.7. Documentació de models</h4>
    <p>Creeu un fitxer <code>docs/models.md</code> que documenti els contractes:</p>
    <p><strong><code>docs/models.md</code></strong></p>
    {% capture code_255 %}# Models de dades
## ElementCataleg
Representa un element del catàleg de productes.
| Camp | Tipus | Obligatori | Descripció |
|------|-------|------------|------------|
| id | number | Sí | Identificador únic |
| nom | string | Sí | Nom del producte |
| descripcio | string | Sí | Descripció detallada |
| preu | number | Sí | Preu en euros |
| destacat | boolean | No | Si és destacat |
**Origen:** API `/elements`
**Utilitzat a:** ElementService, TargetaComponent
## Política d'evolució
- Camps nous s'afegeixen com **opcionals** fins adopció completa
- Canvis de tipus requereixen nova versió de model
- Documentar sempre l'origen de cada camp{% endcapture %}
    {% include code-block.html lang="markdown" code=code_255 %}
    <p><strong>Context d'integració:</strong> L'organització de models facilita la creació de serveis modulars (Lectura 3.1.1) i la reutilització de codi.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_256 %}# Crear estructura de carpetes:
mkdir -p src/app/models
# Crear fitxers de models:
ng generate interface models/element
ng generate interface models/categoria
ng generate interface models/usuari
# Verificar estructura:
tree src/app/models{% endcapture %}
    {% include code-block.html lang="bash" code=code_256 %}
  {% endcapture %}
  {% include section-point.html numero="1.9" titol="Organització: carpeta models amb interfícies agrupades" contingut=section_point_1_9 %}

  {% capture section_point_1_10 %}
    <h4>1.10.1. Objectiu</h4>
    <p>Aplicar models TypeScript per tipar respostes d'API amb genèrics, propietats @Input() de components, signals i computed, assegurant validació de tipus a tota l'aplicació.</p>
    <h4>1.10.2. Tipar respostes d'API</h4>
    <p>Utilitzeu genèrics per tipar les peticions HTTP:</p>
    {% capture code_257 %}// src/app/serveis/element.service.ts
import { HttpClient } from '@angular/common/http';
import { ElementCataleg } from '../models/element.model';
carregarElements(): void {
  // Genèric <ElementCataleg[]> indica el tipus de resposta esperat
  this.http.get<ElementCataleg[]>('http://localhost:4301/elements')
    .subscribe({
      next: (dades: ElementCataleg[]) => {
        this.elements.set(dades);
        // TypeScript garanteix que cada element té:
        // - id (number)
        // - nom (string)
        // - descripcio (string)
        // - categoria (string)
        // - preu (number)
        // - imatge (string)
        // - destacat? (boolean opcional)
      },
      error: err => {
        console.error('Error carregant elements', err);
      }
    });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_257 %}
    <p><strong>Respostes anidades:</strong></p>
    {% capture code_258 %}interface RespostaAPI<T> {
  dades: T;
  estat: 'success' | 'error';
  missatge?: string;
}
// Tipar resposta amb dades de tipus ElementCataleg[]
this.http.get<RespostaAPI<ElementCataleg[]>>(url)
  .subscribe({
    next: resposta => {
      if (resposta.estat === 'success') {
        this.elements.set(resposta.dades);
      }
    }
  });{% endcapture %}
    {% include code-block.html lang="typescript" code=code_258 %}
    <h4>1.10.3. @Input() tipats en components</h4>
    <p>Tipeu les propietats <code>@Input()</code> per garantir que els components reben dades correctes:</p>
    {% capture code_259 %}// src/app/components/targeta-element/targeta-element.component.ts
import { Component, Input } from '@angular/core';
import { ElementCataleg } from '../../models/element.model';
@Component({
  selector: 'app-targeta-element',
  standalone: true,
  templateUrl: './targeta-element.component.html'
})
export class TargetaElementComponent {
  // Input tipat: només accepta ElementCataleg
  @Input({ required: true }) element!: ElementCataleg;
  // TypeScript garanteix que 'element' té totes les propietats
  obtenirPreuAmbIVA(): number {
    return this.element.preu * 1.21; // Segur: preu és number
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_259 %}
    <p><strong>Ús al component pare:</strong></p>
    {% capture code_260 %}<!-- app.component.html -->
<app-targeta-element
  *ngFor="let elem of elements()"
  [element]="elem">
  <!-- TypeScript valida que 'elem' és ElementCataleg -->
</app-targeta-element>{% endcapture %}
    {% include code-block.html lang="html" code=code_260 %}
    <h4>1.10.4. Computed signals tipats</h4>
    <p>Tipeu els signals i computed per mantenir tipus consistents:</p>
    {% capture code_261 %}// src/app/app.component.ts
import { Component, computed, inject } from '@angular/core';
import { ElementService } from './serveis/element.service';
import { ElementCataleg } from './models/element.model';
@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html'
})
export class AppComponent {
  private readonly elementService = inject(ElementService);
  // Computed tipat: retorna ElementCataleg[]
  elements = computed<ElementCataleg[]>(() =>
    this.elementService.elements$()()
  );
  // Computed derivat: també tipat
  elementsDestacats = computed<ElementCataleg[]>(() =>
    this.elements().filter(el => el.destacat === true)
  );
  // TypeScript sap que cada element té la propietat 'destacat'
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_261 %}
    <h4>1.10.5. Verificació a temps de compilació</h4>
    <p>Amb models tipats, TypeScript detecta errors abans d'executar:</p>
    {% capture code_262 %}// Error detectat a compilació:
const element: ElementCataleg = {
  id: 1,
  nom: 'Taula',
  preu: '99.90' // Error: Type 'string' is not assignable to type 'number'
};
// Error detectat a compilació:
function mostrar(el: ElementCataleg): void {
  console.log(el.nomm); // Error: Property 'nomm' does not exist
}
// Correcte i validat:
function calcular(el: ElementCataleg): number {
  return el.preu * 1.21; // TypeScript sap que preu és number
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_262 %}
    <h4>1.10.6. Taula: Punts de tipatge a l'aplicació</h4>
    <table>
      <thead>
        <tr>
          <th>Component</th>
          <th>Element a tipar</th>
          <th>Exemple</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Servei</strong></td>
          <td>Signal privat</td>
          <td><code>private elements = signal&lt;ElementCataleg[]&gt;([])</code></td>
        </tr>
        <tr>
          <td><strong>Servei</strong></td>
          <td>Mètode retorn</td>
          <td><code>elements$(): ReadonlySignal&lt;ElementCataleg[]&gt;</code></td>
        </tr>
        <tr>
          <td><strong>Servei</strong></td>
          <td>Petició HTTP</td>
          <td><code>this.http.get&lt;ElementCataleg[]&gt;(url)</code></td>
        </tr>
        <tr>
          <td><strong>Component</strong></td>
          <td>@Input</td>
          <td><code>@Input() element!: ElementCataleg</code></td>
        </tr>
        <tr>
          <td><strong>Component</strong></td>
          <td>Computed</td>
          <td><code>computed&lt;ElementCataleg[]&gt;(() => ...)</code></td>
        </tr>
        <tr>
          <td><strong>Component</strong></td>
          <td>Propietat local</td>
          <td><code>elementSeleccionat: ElementCataleg | null = null</code></td>
        </tr>
        <tr>
          <td><strong>Plantilla</strong></td>
          <td>Variable local</td>
          <td><code>let element of elements()</code> → element és ElementCataleg</td>
        </tr>
      </tbody>
    </table>
    <p><strong>Context d'integració:</strong> Els models tipats es combinen amb la gestió d'estats (Lectura 3.1.3) per assegurar que errors i dades carregades tenen l'estructura esperada.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_263 %}// Al servei, proveu de retornar tipus incorrecte:
elements$(): string[] {
  return this.elements.asReadonly();
  // Error: Type 'ReadonlySignal<ElementCataleg[]>'
  //          is not assignable to type 'string[]'
}
// Al component, proveu d'assignar tipus incorrecte:
@Input() element!: string;
// Després a la plantilla:
<app-targeta-element [element]="elemCataleg">
// Error: Type 'ElementCataleg' is not assignable to type 'string'{% endcapture %}
    {% include code-block.html lang="typescript" code=code_263 %}
  {% endcapture %}
  {% include section-point.html numero="1.10" titol="Ús de models: tipar respostes d'API i propietats de components" contingut=section_point_1_10 %}

  {% capture section_point_1_11 %}
    <h4>1.11.1. Objectiu</h4>
    <p>Valorar els avantatges de TypeScript amb models tipats: detecció d'errors en temps de desenvolupament, refactoring segur, documentació automàtica, i millor experiència desenvolupador.</p>
    <h4>1.11.2. Errors detectats abans d'executar</h4>
    <p>El principal avantatge de TypeScript amb models és detectar errors <strong>durant l'escriptura</strong> en lloc de descobrir-los en producció.</p>
    <p><strong>Escenari 1: Typo en nom de propietat</strong></p>
    {% capture code_264 %}function mostrarPreu(element: ElementCataleg): void {
  console.log(element.preuu);
  // Error IMMEDIAT: Property 'preuu' does not exist on type 'ElementCataleg'
  // VS Code subratlla en vermell mentre escriviu
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_264 %}
    <p><strong>Escenari 2: Tipus incorrecte</strong></p>
    {% capture code_265 %}function calcular(element: ElementCataleg): number {
  return element.preu.toUpperCase();
  // Error: Property 'toUpperCase' does not exist on type 'number'
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_265 %}
    <p><strong>Escenari 3: Propietat mancant</strong></p>
    {% capture code_266 %}const element: ElementCataleg = {
  id: 1,
  nom: 'Taula'
  // Error: Property 'descripcio' is missing
  // Error: Property 'preu' is missing
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_266 %}
    <h4>1.11.3. Refactoring segur</h4>
    <p>Quan canvieu el nom d'una propietat a la interfície, TypeScript actualitza automàticament tots els usos:</p>
    <p><strong>Abans:</strong></p>
    {% capture code_267 %}interface ElementCataleg {
  titol: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_267 %}
    <p><strong>Refactoring:</strong> Canviar <code>titol</code> → <code>nom</code> amb "Rename Symbol" (F2 a VS Code)</p>
    <p><strong>Després:</strong></p>
    {% capture code_268 %}interface ElementCataleg {
  nom: string; // Canviat automàticament arreu
}
// Tots els usos actualitzats automàticament:
console.log(element.nom); // Era element.titol
<h2>{{ element.nom }}</h2> // Era {{ element.titol }}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_268 %}
    <h4>1.11.4. Documentació automàtica</h4>
    <p>Els models TypeScript actuen com a documentació viva del codi:</p>
    {% capture code_269 %}/**
 * Model d'un element del catàleg
 */
export interface ElementCataleg {
  /** Identificador únic */
  id: number;
  /** Nom descriptiu de l'element */
  nom: string;
  /** Preu en euros sense IVA */
  preu: number;
}
// Quan passeu el cursor per sobre, l'IDE mostra:
// ElementCataleg
// Model d'un element del catàleg
//   - id: number (Identificador únic)
//   - nom: string (Nom descriptiu de l'element)
//   - preu: number (Preu en euros sense IVA){% endcapture %}
    {% include code-block.html lang="typescript" code=code_269 %}
    <h4>1.11.5. Millor experiència desenvolupador</h4>
    <p><strong>Autocompletat intel·ligent:</strong></p>
    <ul>
      <li>En escriure <code>element.</code>, l'IDE mostra totes les propietats disponibles</li>
      <li>Documentació inline amb JSDoc</li>
      <li>Tipus de cada propietat visible immediatament</li>
    </ul>
    <p><strong>Navegació ràpida:</strong></p>
    <ul>
      <li>Cmd/Ctrl + Click sobre <code>ElementCataleg</code> → salta a la definició</li>
      <li>"Find All References" → troba tots els usos</li>
      <li>"Peek Definition" → veu la interfície sense canviar de fitxer</li>
    </ul>
    <p><strong>Checklist de beneficis:</strong></p>
    {% include checklist.html elements="<strong>Errors de compilació</strong> en lloc de runtime|<strong>Autocompletat</strong> complet a l'IDE|<strong>Refactoring</strong> automàtic i segur|<strong>Documentació</strong> integrada al codi|<strong>Navegació</strong> ràpida entre definicions|<strong>Confiança</strong> en el codi (el compilador valida)|<strong>Onboarding</strong> més ràpid (models auto-explicatius)" %}
    <p><strong>Context d'integració:</strong> Els avantatges dels models es multipliquen quan es combinen amb signals reactius (Lectura 2.2.2) i gestió d'errors robusta (Lectura 3.1.3).</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_270 %}// Proveu de fer un typo deliberat:
const test: ElementCataleg = { /* ... */ };
console.log(test.preuu); // VS Code marca error IMMEDIATAMENT
// Proveu de canviar el tipus d'una propietat:
interface ElementCataleg {
  preu: string; // Era number
}
// Tots els llocs que fan `preu * 1.21` mostren error{% endcapture %}
    {% include code-block.html lang="typescript" code=code_270 %}
  {% endcapture %}
  {% include section-point.html numero="1.11" titol="Avantatges: detecció d'errors en temps de desenvolupament" contingut=section_point_1_11 %}

  {% capture section_point_1_12 %}
    <h4>1.12.1. Objectiu</h4>
    <p>Crear un sistema complet de models per al catàleg amb validació automàtica, aplicant tots els conceptes apresos en aquesta lectura.</p>
    <h4>1.12.2. Passos</h4>
    <p><strong>1. Crear estructura de models:</strong></p>
    {% capture code_271 %}mkdir -p src/app/models
ng generate interface models/element
ng generate interface models/categoria{% endcapture %}
    {% include code-block.html lang="bash" code=code_271 %}
    <p><strong>2. Definir interfície ElementCataleg:</strong></p>
    {% capture code_272 %}// src/app/models/element.model.ts
export interface ElementCataleg {
  id: number;
  nom: string;
  descripcio: string;
  categoria: string;
  preu: number;
  imatge: string;
  destacat?: boolean;
  dataPublicacio?: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_272 %}
    <p><strong>3. Definir interfície Categoria:</strong></p>
    {% capture code_273 %}// src/app/models/categoria.model.ts
export interface Categoria {
  id: number;
  nom: string;
  icona: string;
  color: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_273 %}
    <p><strong>4. Actualitzar servei amb models:</strong></p>
    {% capture code_274 %}// src/app/serveis/element.service.ts
import { ElementCataleg } from '../models/element.model';
private elements = signal<ElementCataleg[]>([]);
carregarElements(): void {
  this.http.get<ElementCataleg[]>(`${this.baseUrl}/elements`)
    .subscribe({
      next: dades => this.elements.set(dades),
      error: err => console.error(err)
    });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_274 %}
    <p><strong>5. Actualitzar component amb models:</strong></p>
    {% capture code_275 %}// src/app/components/targeta-element/targeta-element.component.ts
import { ElementCataleg } from '../../models/element.model';
@Input({ required: true }) element!: ElementCataleg;{% endcapture %}
    {% include code-block.html lang="typescript" code=code_275 %}
    <p><strong>6. Documentar models:</strong></p>
    {% capture code_276 %}mkdir docs
touch docs/models.md{% endcapture %}
    {% include code-block.html lang="bash" code=code_276 %}
    {% capture code_277 %}# Models de dades
## ElementCataleg
- Origen: API `/elements`
- Camps obligatoris: id, nom, descripcio, categoria, preu, imatge
- Camps opcionals: destacat, dataPublicacio{% endcapture %}
    {% include code-block.html lang="markdown" code=code_277 %}
    <p><strong>7. Provar validació TypeScript:</strong></p>
    {% capture code_278 %}// Proveu de crear objecte incorrecte:
const test: ElementCataleg = {
  id: 'abc', // Error detectat
  nom: 123   // Error detectat
};{% endcapture %}
    {% include code-block.html lang="typescript" code=code_278 %}
    <p><strong>8. Validar amb linter:</strong></p>
    {% capture code_279 %}npm run lint   # Comprova tipus correctes
ng build       # Compila verificant models{% endcapture %}
    {% include code-block.html lang="bash" code=code_279 %}
    <h4>1.12.3. Resultat esperat</h4>
    <p>Sistema de models complet que detecta errors automàticament, proporciona autocompletat, i documenta els contractes de dades.</p>
  {% endcapture %}
  {% include section-point.html numero="1.12" titol="Mini exemple pràctic" contingut=section_point_1_12 %}

  {% capture section_point_1_13 %}
    <h4>1.13.1. Problemes transversals</h4>
    <table>
      <thead>
        <tr>
          <th>Error</th>
          <th>Causa</th>
          <th>Solució</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Property 'X' does not exist on type 'Y'</td>
          <td>Typo al nom de la propietat o interfície incompleta</td>
          <td>Verificar ortografia i afegir propietat a la interfície si cal</td>
        </tr>
        <tr>
          <td>Type 'string' is not assignable to type 'number'</td>
          <td>Tipus incorrecte assignat a una propietat</td>
          <td>Canviar el tipus de la propietat o convertir el valor: <code>Number(valor)</code></td>
        </tr>
        <tr>
          <td>Property 'X' is missing in type 'Y'</td>
          <td>Objecte no té totes les propietats obligatòries</td>
          <td>Afegir propietat mancant o marcar-la com opcional amb <code>?</code></td>
        </tr>
        <tr>
          <td>Cannot find module '../models/X'</td>
          <td>Import incorrecte o fitxer inexistent</td>
          <td>Verificar ruta del fitxer i que existeixi amb extensió <code>.model.ts</code></td>
        </tr>
        <tr>
          <td>Object is possibly 'undefined'</td>
          <td>Propietat opcional sense validació</td>
          <td>Usar operador <code>?.</code> o validar amb <code>if (obj?.prop)</code></td>
        </tr>
      </tbody>
    </table>
    <h4>1.13.2. Problemes d'arquitectura</h4>
    <table>
      <thead>
        <tr>
          <th>Problema</th>
          <th>Causa</th>
          <th>Solució</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Models duplicats a diferents carpetes</td>
          <td>Falta d'organització centralitzada</td>
          <td>Crear carpeta <code>src/app/models</code> única i utilitzar barrel exports</td>
        </tr>
        <tr>
          <td>Interfícies massa grans (>15 propietats)</td>
          <td>Model que representa múltiples entitats</td>
          <td>Dividir en interfícies més petites i combinar-les: <code>extends</code> o composició</td>
        </tr>
        <tr>
          <td>Models amb dades i lògica barrejades</td>
          <td>Confusió entre model (dades) i servei (lògica)</td>
          <td>Models només defineixen estructura, lògica va als serveis</td>
        </tr>
        <tr>
          <td>Ús excessiu de <code>any</code></td>
          <td>Desconeixement de l'estructura de dades</td>
          <td>Inspeccionar resposta API i crear interfície adequada</td>
        </tr>
      </tbody>
    </table>
  {% endcapture %}
  {% include section-point.html numero="1.13" titol="Resolució de problemes" contingut=section_point_1_13 %}

  {% capture section_point_1_14 %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert TypeScript. <strong>Context:</strong> Tinc aquesta resposta JSON de l'API: <code>{ \"id\": 1, \"nom\": \"Portàtil\", \"preu\": 899.90, \"categoria\": \"Electrònica\", \"disponible\": true, \"especificacions\": { \"pes\": 1.5, \"color\": \"gris\" }, \"etiquetes\": [\"nou\", \"oferta\"] }</code>. <strong>Tasca:</strong> Crea una interfície TypeScript que representi aquesta estructura amb objectes niats i arrays. Inclou JSDoc per documentar cada camp i marca camps opcionals si cal. <strong>Format:</strong> Codi TypeScript comentat amb explicació." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte Angular. <strong>Context:</strong> Tinc un servei que utilitza <code>any</code>: <code>this.http.get&lt;any&gt;('/api/elements').subscribe(data =&gt; this.elements.set(data));</code>. <strong>Tasca:</strong> Ajuda'm a crear una interfície TypeScript adequada analitzant la resposta de l'API, substituir <code>any</code> pel tipus correcte, i explica els beneficis concrets del canvi (autocompletat, detecció errors, refactoring). <strong>Format:</strong> Guia pas a pas amb codi abans/després." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Debugger TypeScript. <strong>Context:</strong> He creat interfície <code>interface Producte { id: number; preu: number; disponible: boolean; }</code> però TypeScript dona errors quan assigno dades de l'API perquè <code>preu</code> arriba com string (\"99.90\") i <code>disponible</code> com number (1/0). <strong>Tasca:</strong> Explica dues solucions: adaptar la interfície amb tipus unions o crear adaptador per transformar dades. Compara avantatges/inconvenients de cada opció. <strong>Format:</strong> Taula comparativa amb exemples de codi." %}
  {% endcapture %}
  {% include section-point.html numero="1.14" titol="Prompts d'IA" contingut=section_point_1_14 %}

  {% capture section_point_1_15 %}
    <h4>1.15.1. Funcionalitat bàsica</h4>
    {% include checklist.html elements="Crear interfície TypeScript amb propietats obligatòries|Afegir propietats opcionals amb sintaxi <code>?</code>|Exportar i importar interfícies entre fitxers|Utilitzar tipus primitius (string, number, boolean)|Definir arrays tipats (<code>string[]</code>, <code>number[]</code>)" %}
    <h4>1.15.2. Models i serveis</h4>
    {% include checklist.html elements="Tipar respostes HTTP amb genèrics <code>&lt;T&gt;</code>|Tipar signals amb <code>signal&lt;Tipus&gt;()</code>|Utilitzar models a <code>@Input()</code> de components|Documentar interfícies amb JSDoc|Organitzar models a carpeta <code>src/app/models</code>" %}
    <h4>1.15.3. Validació i errors</h4>
    {% include checklist.html elements="Detectar errors de tipus abans de compilar|Utilitzar autocompletat de l'IDE|Refactoritzar propietats amb 'Rename Symbol'|Evitar l'ús de <code>any</code>|Validar propietats opcionals amb <code>?.</code>" %}
    <h4>1.15.4. Competències adquirides</h4>
    {% include checklist.html elements="Definir contractes de dades amb interfícies|Diferenciar propietats obligatòries i opcionals|Aplicar tipatge fort a tota l'aplicació|Documentar models amb comentaris JSDoc|Organitzar models de forma modular" %}
  {% endcapture %}
  {% include section-point.html numero="1.15" titol="Autoavaluació" contingut=section_point_1_15 %}

  {% capture section_point_1_16 %}
    <p>En aquesta lectura heu après a definir models de dades amb interfícies TypeScript, diferenciar propietats obligatòries i opcionals, utilitzar tipus complexos, organitzar models en carpetes modulars, i aplicar tipatge fort a serveis i components.</p>
    <p><strong>Què heu aconseguit:</strong></p>
    <ul>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Crear interfícies TypeScript amb propietats tipades</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Diferenciar obligatoris (<code>prop: tipus</code>) i opcionals (<code>prop?: tipus</code>)</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Utilitzar tipus primitius, arrays, objectes niats, i unions</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Organitzar models a <code>src/app/models</code> amb nomenclatura consistent</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Tipar respostes HTTP, signals, @Input(), i computed</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Detectar errors en temps de desenvolupament</li>
      <li><i class="bi bi-check-circle text-success" aria-hidden="true"></i> Documentar models amb JSDoc</li>
    </ul>
    <p><strong>Què us prepara per a les properes lectures:</strong></p>
    <ul>
      <li>Lectura 3.2.2: Creareu adaptadors que transformen dades externes al format de les vostres interfícies</li>
      <li>Lectura 3.2.3: Integrareu models amb signals reactius per gestionar estat complex</li>
      <li>Unitat 4: Utilitzareu models per definir contractes en formularis i validacions</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="1.16" titol="Síntesi" contingut=section_point_1_16 %}

  {% capture section_point_1_17 %}
    {% include definicio.html terme="Interfície TypeScript" definicio="Contracte que defineix l'estructura d'un objecte especificant propietats i els seus tipus." %}
    {% include definicio.html terme="Propietat obligatòria" definicio="Camp que sempre ha d'estar present a l'objecte (<code>nom: string</code>)." %}
    {% include definicio.html terme="Propietat opcional" definicio="Camp que pot estar present o no (<code>nom?: string</code>)." %}
    {% include definicio.html terme="Genèric TypeScript" definicio="Paràmetre de tipus que permet especificar el tipus d'una estructura (<code>&lt;T&gt;</code>)." %}
    {% include definicio.html terme="Barrel export" definicio="Fitxer <code>index.ts</code> que reexporta múltiples interfícies per simplificar imports." %}
    {% include definicio.html terme="JSDoc" definicio="Comentaris de documentació que l'IDE mostra com tooltips (<code>/** comentari */</code>)." %}
    {% include definicio.html terme="Tipus primitiu" definicio="Tipus bàsic de TypeScript: <code>string</code>, <code>number</code>, <code>boolean</code>." %}
    {% include definicio.html terme="Array tipat" definicio="Array que especifica el tipus dels seus elements (<code>string[]</code>)." %}
    {% include definicio.html terme="Objecte niat" definicio="Propietat que és un objecte d'una altra interfície." %}
    {% include definicio.html terme="Tipus union" definicio="Propietat que pot ser un de diversos tipus (<code>string | null</code>)." %}
    {% include definicio.html terme="Type assertion" definicio="Indicar a TypeScript el tipus concret d'una variable (<code>as Tipus</code>)." %}
    {% include definicio.html terme="Readonly signal" definicio="Signal que només pot llegir-se però no modificar-se des de fora." %}
    {% include definicio.html terme="Model de dades" definicio="Interfície que representa l'estructura d'una entitat del domini." %}
    {% include definicio.html terme="PascalCase" definicio="Convenció de nomenclatura amb majúscules inicials (<code>ElementCataleg</code>)." %}
    {% include definicio.html terme="kebab-case" definicio="Convenció de nomenclatura amb guions (<code>element-cataleg.model.ts</code>)." %}
  {% endcapture %}
  {% include section-point.html numero="1.17" titol="Repàs de conceptes" contingut=section_point_1_17 %}

</div>

<!-- SECCIÓ 2: Adaptadors i transformació de dades externes -->
<div class="section" id="Unitat3_Bloc2_Seccio2">
  <h2 id="Unitat3_Bloc2_Seccio2">2. Adaptadors i transformació de dades externes</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=2 seccio=2 %}


  {% include objectius.html llista="Analitzar respostes d'APIs externes i detectar diferències respecte als models interns|Construir funcions adaptadores que transformin dades externes al format intern de l'aplicació|Gestionar camps opcionals i absents aplicant valors per defecte adequats|Centralitzar transformacions en una capa reutilitzable i documentar el contracte de transformació" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 1</strong> — Defineix models de dades i estructures adequades al cas d'ús." %}

  {% capture section_point_2_1 %}
    <p>Abans de començar, necessiteu:</p>
    <ul>
      <li><strong>Lectures 3.1.1–3.1.3 i 3.2.1 completades:</strong> Servei <code>ElementService</code> consumint API mock, models TypeScript definits i documentats a <code>docs/models.md</code>.</li>
      <li><strong>API mock operativa:</strong> <code>json-server</code> executant-se a <code>http://localhost:4301/elements</code> o resposta JSON d'exemple disponible.</li>
      <li><strong>Models definits:</strong> Interfície <code>ElementCataleg</code> amb camps <code>id</code>, <code>nom</code>, <code>descripcio</code>, <code>categoria</code>, <code>preu</code>, <code>imatge</code>.</li>
      <li><strong>Documentació preparada:</strong> Fitxer <code>docs/serveis.md</code> llest per afegir secció d'adaptadors.</li>
    </ul>
    <p><strong>Verificació ràpida:</strong></p>
    {% capture code_280 %}# Terminal 1: API mock
json-server --watch db.json --port 4301
# Terminal 2: Capturar resposta raw de l'API
curl http://localhost:4301/elements > examples/resposta-api-raw.json
# Revisar estructura de dades:
cat examples/resposta-api-raw.json{% endcapture %}
    {% include code-block.html lang="bash" code=code_280 %}
    <p><strong>Punt d'autocomprovació:</strong> La resposta de l'API hauria de mostrar camps (possiblement en anglès: <code>title</code>, <code>description</code>, <code>price</code>) que difereixen del vostre model intern (<code>nom</code>, <code>descripcio</code>, <code>preu</code>).</p>
  {% endcapture %}
  {% include section-point.html numero="2.1" titol="Prerequisits" contingut=section_point_2_1 %}

  {% capture section_point_2_2 %}
    <h4>2.2.1. Què són els adaptadors de dades</h4>
    <p>Els adaptadors (també anomenats "mappers" o "transformers") són <strong>funcions pures que tradueixen dades externes al format intern</strong> de l'aplicació. Actuen com un pont entre el món extern (APIs amb les seves convencions) i el món intern (models del vostre domini).</p>
    <p>Un adaptador rep un objecte amb l'estructura externa i retorna un objecte amb l'estructura interna, aplicant transformacions necessàries: canvi de noms de camps, conversions de tipus, valors per defecte, i restructuració de dades niades.</p>
    <h4>2.2.2. Problema sense adaptadors</h4>
    <p><strong>Situació abans:</strong></p>
    <p>Quan consumiu APIs directament sense capa d'adaptació, el vostre codi queda acoblat a l'estructura externa. Això genera múltiples problemes:</p>
    {% capture code_281 %}// Servei SENSE adaptador (PROBLEMÀTIC)
@Injectable({ providedIn: 'root' })
export class ElementService {
  carregarElements(): void {
    this.http.get<any>('http://localhost:4301/elements').subscribe({
      next: (dades: any) => {
        // Problema: assumiu que l'API retorna exactament el que necessiteu
        this.elements.set(dades);
        // Què passa si l'API utilitza "title" en lloc de "nom"?
        // Què passa si "price" és string "99.90" en lloc de number 99.90?
        // Què passa si alguns camps són null?
      }
    });
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_281 %}
    {% capture code_282 %}<div *ngFor="let element of elements()">
  <h3>{{ element.title }}</h3>
  <p>{{ element.description }}</p>
  <span>{{ element.price }}€</span>
</div>{% endcapture %}
    {% include code-block.html lang="html" code=code_282 %}
    <p><strong>Exemple real d'API amb estructura diferent:</strong></p>
    {% capture code_283 %}{
  "data": [
    {
      "id": 1,
      "title": "Modern Table",
      "description": "Elegant wooden table",
      "category": "furniture",
      "price": "199.90",
      "image_url": "https://api.example.com/images/table.jpg",
      "is_featured": 1,
      "published_at": "2024-01-15T10:30:00Z"
    }
  ],
  "meta": {
    "total": 150,
    "page": 1
  }
}{% endcapture %}
    {% include code-block.html lang="json" code=code_283 %}
    <p><strong>Problemes que genera:</strong></p>
    <p><strong>1. Acoblament fort amb l'API externa</strong></p>
    <p>El vostre codi utilitza directament els noms de camps de l'API (<code>title</code>, <code>description</code>, <code>price</code>). Si l'API canvia aquests noms, heu de buscar manualment TOTS els llocs del codi on s'utilitzen i canviar-los un per un. Amb 50 components, això pot ser centenars de llocs.</p>
    <p><strong>2. Inconsistència lingüística</strong></p>
    <p>L'aplicació barreja català i anglès: els models interns són en català (<code>nom</code>, <code>descripcio</code>) però les dades de l'API són en anglès (<code>title</code>, <code>description</code>). Això crea confusió i dificulta la lectura del codi.</p>
    <p><strong>3. Tipus incorrectes sense detecció</strong></p>
    <p>L'API retorna <code>"price": "199.90"</code> (string) però el vostre model espera <code>preu: number</code>. Sense adaptador, aquest string arriba fins a la UI i provoca errors quan intenteu fer càlculs: <code>element.price * 1.21</code> → <code>NaN</code>.</p>
    <p><strong>4. Camps mancants provoquen undefined</strong></p>
    <p>Si l'API no retorna <code>image_url</code> per algun element, la propietat <code>imatge</code> serà <code>undefined</code>. A la UI, les imatges no es mostren i apareixen enllaços trencats, però cap error s'ha llançat.</p>
    <p><strong>5. Dades anidades sense extractar</strong></p>
    <p>L'API embolicà les dades reals dins de <code>{ data: [...], meta: {...} }</code>. El vostre codi ha d'accedir sempre a <code>.data</code> per obtenir els elements, complicant la lògica arreu.</p>
    <p><strong>6. Múltiples llocs amb lògica de transformació duplicada</strong></p>
    <p>Cada component que rep dades de l'API ha d'aplicar les mateixes transformacions: convertir <code>price</code> a number, posar placeholder per <code>image_url</code>, extreure de <code>.data</code>. Aquesta lògica es repeteix en 10-20 llocs diferents.</p>
    <h4>2.2.3. Solució amb adaptadors</h4>
    <p><strong>Els adaptadors centralitzen tota la transformació en un únic lloc:</strong></p>
    {% capture code_284 %}// Definició de tipus extern (el que retorna l'API)
interface ElementAPIResponse {
  data: ElementAPI[];
  meta: {
    total: number;
    page: number;
  };
}
interface ElementAPI {
  id: number;
  title: string;
  description: string;
  category: string;
  price: string;
  image_url?: string;
  is_featured?: number;
  published_at?: string;
}
// ADAPTADOR: transforma extern → intern
export function adaptarElementAPI(extern: ElementAPI): ElementCataleg {
  return {
    id: extern.id,
    nom: extern.title,
    descripcio: extern.description,
    categoria: extern.category,
    preu: parseFloat(extern.price),
    imatge: extern.image_url ?? '/assets/img/placeholder.png',
    destacat: extern.is_featured === 1,
    dataPublicacio: extern.published_at ? new Date(extern.published_at) : undefined
  };
}
export function adaptarRespostaAPI(resposta: ElementAPIResponse): ElementCataleg[] {
  return resposta.data.map(adaptarElementAPI);
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_284 %}
    {% capture code_285 %}// Servei AMB adaptador (CORRECTE)
@Injectable({ providedIn: 'root' })
export class ElementService {
  carregarElements(): void {
    this.http.get<ElementAPIResponse>('http://localhost:4301/elements')
      .subscribe({
        next: (resposta: ElementAPIResponse) => {
          const elementsAdaptats = adaptarRespostaAPI(resposta);
          this.elements.set(elementsAdaptats);
        }
      });
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_285 %}
    {% capture code_286 %}<div *ngFor="let element of elements()">
  <h3>{{ element.nom }}</h3>
  <p>{{ element.descripcio }}</p>
  <span>{{ element.preu }}€</span>
</div>{% endcapture %}
    {% include code-block.html lang="html" code=code_286 %}
    <p><strong>Avantatges obtinguts:</strong></p>
    <table>
      <thead>
        <tr>
          <th>Aspecte</th>
          <th>Sense adaptador</th>
          <th>AMB adaptador</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Acoblament API</strong></td>
          <td>Fort (canvis API trenquen app)</td>
          <td>Baix (canvis només afecten adaptador)</td>
        </tr>
        <tr>
          <td><strong>Consistència lingüística</strong></td>
          <td>Barreja català/anglès</td>
          <td>100% català al codi intern</td>
        </tr>
        <tr>
          <td><strong>Tipus correctes</strong></td>
          <td>String/number inconsistent</td>
          <td>Sempre tipus esperats</td>
        </tr>
        <tr>
          <td><strong>Camps mancants</strong></td>
          <td>undefined sense control</td>
          <td>Valors per defecte automàtics</td>
        </tr>
        <tr>
          <td><strong>Lògica duplicada</strong></td>
          <td>Transformacions a 10-20 llocs</td>
          <td>Transformació centralitzada (1 lloc)</td>
        </tr>
        <tr>
          <td><strong>Mantenibilitat</strong></td>
          <td>Molt baixa</td>
          <td>Alta (un punt de canvi)</td>
        </tr>
        <tr>
          <td><strong>Testing</strong></td>
          <td>Difícil (mocks complexos)</td>
          <td>Fàcil (testejar adaptador aïllat)</td>
        </tr>
      </tbody>
    </table>
    <h4>2.2.4. Exemple comparat: Canvi a l'API</h4>
    <p><strong>Escenari:</strong> L'API canvia <code>title</code> per <code>product_name</code>.</p>
    <p><strong>SENSE adaptador:</strong></p>
    {% capture code_287 %}// Heu de buscar i canviar TOTS aquests llocs (50+ components):
<h3>{{ element.title }}</h3>
console.log(element.title);
if (element.title.length > 10)
// ... 47 llocs més ...{% endcapture %}
    {% include code-block.html lang="typescript" code=code_287 %}
    <p><strong>AMB adaptador:</strong></p>
    {% capture code_288 %}// Canvi en UN SOL lloc (l'adaptador):
export function adaptarElementAPI(extern: ElementAPI): ElementCataleg {
  return {
    nom: extern.product_name,
    // ... resta de camps igual ...
  };
}
// Tot el codi intern continua utilitzant "nom"
// 0 canvis necessaris als components!{% endcapture %}
    {% include code-block.html lang="typescript" code=code_288 %}
    <h4>2.2.5. Integració amb lectures anteriors</h4>
    <ul>
      <li><strong>Lectura 3.1.2 (Peticions HTTP):</strong> Els adaptadors es criden immediatament després de rebre la resposta de <code>this.http.get()</code>.</li>
      <li><strong>Lectura 3.2.1 (Models):</strong> Els adaptadors transformen de tipus externs a models interns (<code>ElementCataleg</code>).</li>
      <li><strong>Lectura 3.1.3 (Gestió d'errors):</strong> Els adaptadors poden validar dades i llançar errors si l'estructura és inesperada.</li>
      <li><strong>Lectura 2.1.1 (Components):</strong> Components sempre reben dades ja adaptades, mai dades crues de l'API.</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="2.2" titol="Marc conceptual" contingut=section_point_2_2 %}

  {% capture section_point_2_3 %}
    <p>Penseu en els adaptadors com <strong>traductors entre idiomes</strong>:</p>
    <ul>
      <li><strong>Idioma extern (API):</strong> Anglès amb convencions pròpies (<code>title</code>, <code>price</code> com string, <code>is_featured</code> com 0/1).</li>
      <li><strong>Idioma intern (App):</strong> Català amb convencions pròpies (<code>nom</code>, <code>preu</code> com number, <code>destacat</code> com boolean).</li>
      <li><strong>Traductor (Adaptador):</strong> Funció que rep text en un idioma i retorna text a l'altre, aplicant regles de transformació.</li>
    </ul>
    <p><strong>Analogia:</strong> Si rebeu una factura en anglès amb preus en dòlars, no la passeu directament a comptabilitat. Primer la traduïu al català i convertiu dòlars a euros. L'adaptador fa exactament això amb les dades.</p>
    <p><strong>Conceptes clau:</strong></p>
    <ul>
      <li><strong>Funció pura:</strong> Mateix input → mateix output, sense efectes secundaris.</li>
      <li><strong>Transformació unidireccional:</strong> Extern → Intern (no cal bidireccional).</li>
      <li><strong>Centralització:</strong> Un adaptador per entitat, reutilitzat arreu.</li>
      <li><strong>Valors per defecte:</strong> Sempre proporcionar fallbacks per camps opcionals.</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="2.3" titol="Model mental" contingut=section_point_2_3 %}

  {% capture section_point_2_4 %}
    <h4>2.4.1. Independència del backend</h4>
    <p>Els backends tenen les seves pròpies convencions: noms de camps en anglès, snake_case, estructures específiques. El vostre frontend també té les seves: noms en català, camelCase, models del domini.</p>
    <p><strong>Sense adaptadors,</strong> el frontend està esclavitzat al backend. Cada canvi al backend (rename d'un camp, nova estructura) requereix canvis massiu al frontend.</p>
    <p><strong>Amb adaptadors,</strong> el frontend és independent. El backend pot canviar lliurement, l'adaptador absorbeix els canvis.</p>
    <h4>2.4.2. Centralització de transformacions</h4>
    <p><strong>Problema comú:</strong> Transformacions duplicades en múltiples llocs.</p>
    {% capture code_289 %}// Component 1 (DUPLICAT)
mostrarElement(elem: any): void {
  const nom = elem.title || 'Sense nom';
  const preu = parseFloat(elem.price);
  // ...
}
// Component 2 (DUPLICAT)
filtrarElements(elems: any[]): any[] {
  return elems.map(e => ({
    nom: e.title || 'Sense nom',
    preu: parseFloat(e.price)
    // ...
  }));
}
// Component 3 (DUPLICAT)
// ... mateixa lògica repetida ...{% endcapture %}
    {% include code-block.html lang="typescript" code=code_289 %}
    <p><strong>Solució:</strong> Adaptador centralitzat cridat un cop després de la petició.</p>
    {% capture code_290 %}// Adaptador (ÚNIC LLOC)
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    nom: elem.title ?? 'Sense nom',
    preu: parseFloat(elem.price),
    // ... transformació completa ...
  };
}
// Servei crida adaptador
this.http.get(url).subscribe({
  next: resposta => {
    const adaptats = resposta.map(adaptarElementAPI);
    this.elements.set(adaptats);
  }
});
// Components reben dades ja adaptades
// No necessiten saber res sobre l'estructura externa{% endcapture %}
    {% include code-block.html lang="typescript" code=code_290 %}
    <h4>2.4.3. Protecció contra canvis</h4>
    <p>Els backends evolucionen: nous camps, renamed fields, estructures modificades. Els adaptadors protegeixen el vostre codi d'aquests canvis.</p>
    <p><strong>Exemple real:</strong></p>
    {% capture code_291 %}// Versió 1 de l'API
interface ElementAPI_v1 {
  id: number;
  title: string;
  price: string;
}
// Versió 2 de l'API (canvi de noms)
interface ElementAPI_v2 {
  id: number;
  product_name: string;
  unit_price: string;
}
// Adaptador v1
export function adaptarElementAPI_v1(elem: ElementAPI_v1): ElementCataleg {
  return { nom: elem.title, preu: parseFloat(elem.price), ... };
}
// Adaptador v2 (ÚNIC CANVI NECESSARI)
export function adaptarElementAPI_v2(elem: ElementAPI_v2): ElementCataleg {
  return { nom: elem.product_name, preu: parseFloat(elem.unit_price), ... };
}
// Servei decideix quina versió utilitzar
carregarElements(): void {
  const adaptador = this.versioAPI === 2 ? adaptarElementAPI_v2 : adaptarElementAPI_v1;
  this.http.get(url).subscribe({
    next: resposta => this.elements.set(resposta.map(adaptador))
  });
}
// Components NO canvien MAI
// Sempre treballen amb ElementCataleg{% endcapture %}
    {% include code-block.html lang="typescript" code=code_291 %}
    <h4>2.4.4. Taula comparativa: Format extern vs intern</h4>
    <table>
      <thead>
        <tr>
          <th>Aspecte</th>
          <th>Format extern (API)</th>
          <th>Format intern (App)</th>
          <th>Transformació adaptador</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Noms camps</strong></td>
          <td>Anglès (<code>title</code>, <code>description</code>)</td>
          <td>Català (<code>nom</code>, <code>descripcio</code>)</td>
          <td>Mapeja noms</td>
        </tr>
        <tr>
          <td><strong>Convencions</strong></td>
          <td>snake_case (<code>image_url</code>)</td>
          <td>camelCase (<code>imatge</code>)</td>
          <td>Converteix convencions</td>
        </tr>
        <tr>
          <td><strong>Tipus</strong></td>
          <td>Strings (<code>"199.90"</code>, <code>"1"</code>)</td>
          <td>Types adequats (number, boolean)</td>
          <td>Converteix tipus</td>
        </tr>
        <tr>
          <td><strong>Camps opcionals</strong></td>
          <td>Poden ser null/undefined</td>
          <td>Valors per defecte garantits</td>
          <td>Aplica fallbacks</td>
        </tr>
        <tr>
          <td><strong>Estructura</strong></td>
          <td>Dades embolicades (<code>{data:[...]}</code>)</td>
          <td>Arrays directes (<code>[...]</code>)</td>
          <td>Extreu dades</td>
        </tr>
        <tr>
          <td><strong>Dates</strong></td>
          <td>ISO strings (<code>"2024-01-15T10:30:00Z"</code>)</td>
          <td>Date objects</td>
          <td>Parseja dates</td>
        </tr>
      </tbody>
    </table>
    <p><strong>Context d'integració:</strong> Els adaptadors completen el sistema de models (Lectura 3.2.1) permetent treballar amb dades externes sense comprometre la consistència interna.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_292 %}# Captureu resposta real de l'API:
curl http://localhost:4301/elements | jq '.' > resposta-externa.json
# Compareu amb el vostre model intern:
cat src/app/models/element.model.ts
# Identifiqueu diferències: noms de camps, tipus, estructura{% endcapture %}
    {% include code-block.html lang="bash" code=code_292 %}
  {% endcapture %}
  {% include section-point.html numero="2.4" titol="Per què necessitem adaptadors: format extern vs format intern" contingut=section_point_2_4 %}

  {% capture section_point_2_5 %}
    <h4>2.5.1. Convencions de nomenclatura</h4>
    <p>Les APIs segueixen convencions diferents segons la tecnologia:</p>
    <p><strong>APIs REST (anglès, snake_case):</strong></p>
    {% capture code_293 %}{"product_id": 1, "product_name": "Modern Table", "unit_price": 199.90, "image_url": "https://..."}{% endcapture %}
    {% include code-block.html lang="json" code=code_293 %}
    <p><strong>APIs GraphQL (anglès, camelCase):</strong></p>
    {% capture code_294 %}{"productId": 1, "productName": "Modern Table", "unitPrice": 199.90, "imageUrl": "https://..."}{% endcapture %}
    {% include code-block.html lang="json" code=code_294 %}
    <p><strong>Model intern (català, camelCase):</strong></p>
    {% capture code_295 %}interface ElementCataleg {
  id: number;
  nom: string;
  preu: number;
  imatge: string;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_295 %}
    <h4>2.5.2. Wrapping de dades</h4>
    <p>Moltes APIs embolicen les dades reals dins d'objectes addicionals:</p>
    <p><strong>Exemple 1: Wrapping amb metadata</strong></p>
    {% capture code_296 %}{"status": "success", "data": [{"id": 1, "title": "Product 1"}, {"id": 2, "title": "Product 2"}], "meta": {"total": 150, "page": 1, "per_page": 20}}{% endcapture %}
    {% include code-block.html lang="json" code=code_296 %}
    <p><strong>Exemple 2: Wrapping amb error</strong></p>
    {% capture code_297 %}{"success": true, "result": {"items": [ /* dades aquí */ ], "count": 10}, "error": null}{% endcapture %}
    {% include code-block.html lang="json" code=code_297 %}
    <p><strong>Adaptador per extreure dades:</strong></p>
    {% capture code_298 %}interface APIResponse<T> {
  status: string;
  data: T;
  meta?: {
    total: number;
    page: number;
  };
}
export function adaptarResposta<T, U>(resposta: APIResponse<T[]>, adaptador: (item: T) => U): U[] {
  return resposta.data.map(adaptador);
}
// Ús:
this.http.get<APIResponse<ElementAPI[]>>(url).subscribe({
  next: resposta => {
    const elements = adaptarResposta(resposta, adaptarElementAPI);
    this.elements.set(elements);
  }
});{% endcapture %}
    {% include code-block.html lang="typescript" code=code_298 %}
    <h4>2.5.3. Tipus incompatibles</h4>
    <p>Les APIs retornen sovint tipus que no coincideixen amb els models:</p>
    <p><strong>Problemes típics:</strong></p>
    <table>
      <thead>
        <tr>
          <th>Camp API</th>
          <th>Tipus API</th>
          <th>Model intern</th>
          <th>Problema</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>"price": "99.90"</code></td>
          <td>string</td>
          <td><code>preu: number</code></td>
          <td>Cal parsejar</td>
        </tr>
        <tr>
          <td><code>"is_featured": 1</code></td>
          <td>number (0/1)</td>
          <td><code>destacat: boolean</code></td>
          <td>Cal convertir</td>
        </tr>
        <tr>
          <td><code>"published_at": "2024-01-15T..."</code></td>
          <td>string ISO</td>
          <td><code>dataPublicacio: Date</code></td>
          <td>Cal parsear</td>
        </tr>
        <tr>
          <td><code>"tags": "furniture,wood"</code></td>
          <td>string CSV</td>
          <td><code>etiquetes: string[]</code></td>
          <td>Cal split</td>
        </tr>
        <tr>
          <td><code>"rating": null</code></td>
          <td>null</td>
          <td><code>valoracio: number</code></td>
          <td>Cal valor defecte</td>
        </tr>
      </tbody>
    </table>
    <p><strong>Adaptador amb conversions de tipus:</strong></p>
    {% capture code_299 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.title,
    preu: parseFloat(elem.price),
    destacat: elem.is_featured === 1,
    dataPublicacio: elem.published_at ? new Date(elem.published_at) : undefined,
    etiquetes: elem.tags ? elem.tags.split(',') : [],
    valoracio: elem.rating ?? 0
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_299 %}
    <h4>2.5.4. Estructures niades</h4>
    <p>APIs complexes retornen objectes niats que cal aplanar o reestructurar:</p>
    <p><strong>API amb dades niades:</strong></p>
    {% capture code_300 %}{"id": 1, "name": "Product 1", "pricing": {"base_price": 199.90, "discount": 10, "currency": "EUR"}, "manufacturer": {"name": "ACME Corp", "country": "Spain"}}{% endcapture %}
    {% include code-block.html lang="json" code=code_300 %}
    <p><strong>Adaptador que aplana estructura:</strong></p>
    {% capture code_301 %}interface ElementAPINested {
  id: number;
  name: string;
  pricing: {
    base_price: number;
    discount: number;
    currency: string;
  };
  manufacturer: {
    name: string;
    country: string;
  };
}
export function adaptarElementAPINested(elem: ElementAPINested): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.name,
    preu: elem.pricing.base_price,
    descompte: elem.pricing.discount,
    fabricant: elem.manufacturer.name,
    paisFabricant: elem.manufacturer.country
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_301 %}
    <p><strong>Context d'integració:</strong> Entendre les estructures d'API diverses prepara per crear adaptadors flexibles que gestionen qualsevol format.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_302 %}// Proveu diferents estructures d'API:
const resposta1 = { data: [ /* elements */ ] };
const resposta2 = { result: { items: [ /* elements */ ] } };
const resposta3 = [ /* elements directament */ ];
// Creeu adaptadors per a cada cas{% endcapture %}
    {% include code-block.html lang="typescript" code=code_302 %}
  {% endcapture %}
  {% include section-point.html numero="2.5" titol="Estructura de respostes d'APIs: sovint diferents del que necessitem" contingut=section_point_2_5 %}

  {% capture section_point_2_6 %}
    <h4>2.6.1. Signatura de la funció adaptadora</h4>
    <p>Una funció adaptadora té sempre la mateixa estructura:</p>
    {% capture code_303 %}// Tipus entrada (el que retorna l'API)
interface TipusExtern {
  // Camps tal com venen de l'API
}
// Tipus sortida (el model intern)
interface TipusIntern {
  // Camps del model de l'aplicació
}
// Funció adaptadora (funció pura)
export function adaptar(extern: TipusExtern): TipusIntern {
  return {
    // Mapeja camps, aplica transformacions
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_303 %}
    <h4>2.6.2. Exemple bàsic complet</h4>
    <p><strong>Pas 1:</strong> Definir tipus extern (resposta API)</p>
    {% capture code_304 %}// src/app/adaptadors/types/element-api.type.ts
export interface ElementAPI {
  id: number;
  title: string;
  description: string;
  category: string;
  price: string;
  image_url?: string;
  is_featured?: number;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_304 %}
    <p><strong>Pas 2:</strong> Crear funció adaptadora</p>
    {% capture code_305 %}// src/app/adaptadors/element.adaptador.ts
import { ElementCataleg } from '../models/element.model';
import { ElementAPI } from './types/element-api.type';
/**
 * Adapta un element de l'API al model intern
 * @param apiElement - Element tal com ve de l'API
 * @returns Element adaptat al model ElementCataleg
 */
export function adaptarElementAPI(apiElement: ElementAPI): ElementCataleg {
  return {
    id: apiElement.id,
    nom: apiElement.title,
    descripcio: apiElement.description,
    categoria: apiElement.category,
    preu: parseFloat(apiElement.price),
    imatge: apiElement.image_url ?? '/assets/img/placeholder.png',
    destacat: apiElement.is_featured === 1
  };
}
/**
 * Adapta un array d'elements de l'API
 * @param apiElements - Array d'elements de l'API
 * @returns Array d'elements adaptats
 */
export function adaptarElementsAPI(apiElements: ElementAPI[]): ElementCataleg[] {
  return apiElements.map(adaptarElementAPI);
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_305 %}
    <p><strong>Pas 3:</strong> Utilitzar al servei</p>
    {% capture code_306 %}// src/app/serveis/element.service.ts
import { Injectable, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ElementCataleg } from '../models/element.model';
import { ElementAPI } from '../adaptadors/types/element-api.type';
import { adaptarElementsAPI } from '../adaptadors/element.adaptador';
@Injectable({ providedIn: 'root' })
export class ElementService {
  private readonly http = inject(HttpClient);
  private readonly baseUrl = 'http://localhost:4301';
  private readonly elements = signal<ElementCataleg[]>([]);
  carregarElements(): void {
    this.http.get<ElementAPI[]>(`${this.baseUrl}/elements`).subscribe({
      next: (resposta: ElementAPI[]) => {
        const elementsAdaptats = adaptarElementsAPI(resposta);
        this.elements.set(elementsAdaptats);
      }
    });
  }
  elements$() {
    return this.elements.asReadonly();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_306 %}
    <h4>2.6.3. Tests de l'adaptador</h4>
    <p>Els adaptadors són funcions pures, fàcils de testejar:</p>
    {% capture code_307 %}// src/app/adaptadors/element.adaptador.spec.ts
import { adaptarElementAPI } from './element.adaptador';
import { ElementAPI } from './types/element-api.type';
describe('adaptarElementAPI', () => {
  it('hauria de mapear camps correctament', () => {
    const apiElement: ElementAPI = {
      id: 1,
      title: 'Test Product',
      description: 'Test description',
      category: 'furniture',
      price: '199.90',
      image_url: 'https://example.com/image.jpg',
      is_featured: 1
    };
    const result = adaptarElementAPI(apiElement);
    expect(result.id).toBe(1);
    expect(result.nom).toBe('Test Product');
    expect(result.descripcio).toBe('Test description');
    expect(result.preu).toBe(199.90);
    expect(result.destacat).toBe(true);
  });
  it('hauria d\'aplicar valors per defecte per camps opcionals', () => {
    const apiElement: ElementAPI = {
      id: 2,
      title: 'Product without image',
      description: 'Test',
      category: 'other',
      price: '49.90'
    };
    const result = adaptarElementAPI(apiElement);
    expect(result.imatge).toBe('/assets/img/placeholder.png');
    expect(result.destacat).toBe(false);
  });
  it('hauria de convertir price string a number', () => {
    const apiElement: ElementAPI = {
      id: 3,
      title: 'Test',
      description: 'Test',
      category: 'test',
      price: '1234.56'
    };
    const result = adaptarElementAPI(apiElement);
    expect(typeof result.preu).toBe('number');
    expect(result.preu).toBe(1234.56);
  });
});{% endcapture %}
    {% include code-block.html lang="typescript" code=code_307 %}
    <p><strong>Context d'integració:</strong> L'adaptador es col·loca entre el servei HTTP (Lectura 3.1.2) i els models interns (Lectura 3.2.1).</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_308 %}// Proveu manualment l'adaptador a la consola del navegador:
const test: ElementAPI = {
  id: 1,
  title: 'Test',
  description: 'Desc',
  category: 'Cat',
  price: '99.90'
};
const adaptat = adaptarElementAPI(test);
console.log(adaptat);
// { id: 1, nom: 'Test', descripcio: 'Desc', preu: 99.90, ... }{% endcapture %}
    {% include code-block.html lang="typescript" code=code_308 %}
  {% endcapture %}
  {% include section-point.html numero="2.6" titol="Crear funció adaptadora: transformar objecte d'API a model propi" contingut=section_point_2_6 %}

  {% capture section_point_2_7 %}
    <h4>2.7.1. Taula de correspondències</h4>
    <p>Creeu una taula documentant la correspondència entre camps externs i interns:</p>
    <table>
      <thead>
        <tr>
          <th>Camp API</th>
          <th>Tipus API</th>
          <th>Camp Model</th>
          <th>Tipus Model</th>
          <th>Transformació</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>id</code></td>
          <td>number</td>
          <td><code>id</code></td>
          <td>number</td>
          <td>Cap</td>
        </tr>
        <tr>
          <td><code>title</code></td>
          <td>string</td>
          <td><code>nom</code></td>
          <td>string</td>
          <td>Rename</td>
        </tr>
        <tr>
          <td><code>description</code></td>
          <td>string</td>
          <td><code>descripcio</code></td>
          <td>string</td>
          <td>Rename</td>
        </tr>
        <tr>
          <td><code>category</code></td>
          <td>string</td>
          <td><code>categoria</code></td>
          <td>string</td>
          <td>Cap</td>
        </tr>
        <tr>
          <td><code>price</code></td>
          <td>string</td>
          <td><code>preu</code></td>
          <td>number</td>
          <td><code>parseFloat()</code></td>
        </tr>
        <tr>
          <td><code>image_url</code></td>
          <td>string?</td>
          <td><code>imatge</code></td>
          <td>string</td>
          <td>Rename + fallback</td>
        </tr>
        <tr>
          <td><code>is_featured</code></td>
          <td>number?</td>
          <td><code>destacat</code></td>
          <td>boolean</td>
          <td><code>=== 1</code></td>
        </tr>
        <tr>
          <td><code>published_at</code></td>
          <td>string?</td>
          <td><code>dataPublicacio</code></td>
          <td>Date?</td>
          <td><code>new Date()</code></td>
        </tr>
      </tbody>
    </table>
    <h4>2.7.2. Mapeig de camps simples</h4>
    <p>Camps amb només canvi de nom:</p>
    {% capture code_309 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    nom: elem.title,
    descripcio: elem.description,
    categoria: elem.category,
    // ... altres transformacions ...
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_309 %}
    <h4>2.7.3. Mapeig amb transformació de tipus</h4>
    <p>Camps que requereixen conversió de tipus:</p>
    {% capture code_310 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    preu: parseFloat(elem.price),
    destacat: elem.is_featured === 1,
    dataPublicacio: elem.published_at ? new Date(elem.published_at) : undefined,
    // ... altres camps ...
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_310 %}
    <h4>2.7.4. Mapeig de camps niats</h4>
    <p>Camps dins d'objectes niats que cal extreure:</p>
    {% capture code_311 %}interface ElementAPIComplex {
  id: number;
  product: {
    name: string;
    details: {
      description: string;
      specs: string;
    };
  };
  pricing: {
    base: number;
    currency: string;
  };
}
export function adaptarElementAPIComplex(elem: ElementAPIComplex): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.product.name,
    descripcio: elem.product.details.description,
    especificacions: elem.product.details.specs,
    preu: elem.pricing.base,
    moneda: elem.pricing.currency
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_311 %}
    <h4>2.7.5. Mapeig amb càlculs</h4>
    <p>Camps calculats a partir d'altres camps:</p>
    {% capture code_312 %}interface ElementAPICalculs {
  id: number;
  title: string;
  base_price: number;
  tax_rate: number;
  discount_percent: number;
}
export function adaptarElementAPICalculs(elem: ElementAPICalculs): ElementCataleg {
  const preuAmbIVA = elem.base_price * (1 + elem.tax_rate);
  const descompte = elem.discount_percent / 100;
  const preuFinal = preuAmbIVA * (1 - descompte);
  return {
    id: elem.id,
    nom: elem.title,
    preuBase: elem.base_price,
    preuAmbIVA: preuAmbIVA,
    preuFinal: preuFinal,
    descompteAplicat: elem.discount_percent
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_312 %}
    <h4>2.7.6. Taula completa d'exemple</h4>
    <p><strong>Documentació del contracte de transformació:</strong></p>
    {% capture code_313 %}# Adaptador ElementAPI → ElementCataleg
## Correspondència de camps
| Camp extern | Tipus | Camp intern | Tipus | Transformació aplicada |
|-------------|-------|-------------|-------|------------------------|
| id | number | id | number | - |
| title | string | nom | string | - |
| description | string | descripcio | string | - |
| category | string | categoria | string | - |
| price | string | preu | number | parseFloat() |
| image_url | string \| undefined | imatge | string | ?? '/assets/img/placeholder.png' |
| is_featured | 0 \| 1 \| undefined | destacat | boolean | === 1 |
| published_at | string \| undefined | dataPublicacio | Date \| undefined | new Date() o undefined |
## Valors per defecte
- **image_url absent:** `/assets/img/placeholder.png`
- **is_featured absent:** `false`
- **published_at absent:** `undefined`{% endcapture %}
    {% include code-block.html lang="markdown" code=code_313 %}
    <p><strong>Context d'integració:</strong> El mapeig de camps documenta la traducció entre món extern i intern, facilitant manteniment i onboarding d'equip.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_314 %}// Proveu mapeig amb dades reals:
const apiData: ElementAPI = {
  id: 1,
  title: 'Taula moderna',
  description: 'Taula de fusta elegant',
  category: 'mobles',
  price: '199.90',
  image_url: 'https://example.com/table.jpg',
  is_featured: 1
};
const adaptat = adaptarElementAPI(apiData);
console.table(adaptat);
// Verifiqueu que tots els camps es mapegen correctament{% endcapture %}
    {% include code-block.html lang="typescript" code=code_314 %}
  {% endcapture %}
  {% include section-point.html numero="2.7" titol="Mapeig de camps: noms diferents, estructures diferents" contingut=section_point_2_7 %}

  {% capture section_point_2_8 %}
    <h4>2.8.1. Operador de coalescència nul·la (<code>??</code>)</h4>
    <p>L'operador <code>??</code> retorna el valor de l'esquerra si no és <code>null</code> ni <code>undefined</code>, altrament retorna el de la dreta:</p>
    {% capture code_315 %}const valor = campOpcional ?? valorPerDefecte;
// Exemples:
const nom = element.title ?? 'Sense nom';
const preu = element.price ?? 0;
const imatge = element.image_url ?? '/assets/img/placeholder.png';{% endcapture %}
    {% include code-block.html lang="typescript" code=code_315 %}
    <h4>2.8.2. Estratègies per camps opcionals</h4>
    <p><strong>1. Valor per defecte estàtic</strong></p>
    {% capture code_316 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    imatge: elem.image_url ?? '/assets/img/placeholder.png',
    destacat: elem.is_featured === 1 ? true : false,
    valoracio: elem.rating ?? 0,
    etiquetes: elem.tags ?? []
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_316 %}
    <p><strong>2. Valor per defecte generat</strong></p>
    {% capture code_317 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    id: elem.id ?? Date.now(),
    slug: elem.slug ?? elem.title.toLowerCase().replace(/\s+/g, '-'),
    dataCreacio: elem.created_at ? new Date(elem.created_at) : new Date()
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_317 %}
    <p><strong>3. Valor per defecte condicional</strong></p>
    {% capture code_318 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    descripcio: elem.description ?? `Element de la categoria ${elem.category}`,
    preu: elem.price ? parseFloat(elem.price) : elem.category === 'premium' ? 99.90 : 19.90,
    imatge: elem.image_url ?? elem.thumbnail_url ?? `/assets/img/categories/${elem.category}.jpg` ?? '/assets/img/placeholder.png'
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_318 %}
    <h4>2.8.3. Validació de camps obligatoris</h4>
    <p>Alguns camps són tan crítics que no poden tenir fallback:</p>
    {% capture code_319 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  if (!elem.id || elem.id <= 0) {
    throw new Error(`Element sense ID vàlid: ${JSON.stringify(elem)}`);
  }
  if (!elem.title || elem.title.trim() === '') {
    throw new Error(`Element ${elem.id} sense títol`);
  }
  return {
    id: elem.id,
    nom: elem.title,
    descripcio: elem.description ?? 'Sense descripció',
    // ... resta de camps amb fallbacks ...
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_319 %}
    <h4>2.8.4. Taula de valors per defecte recomanats</h4>
    <table>
      <thead>
        <tr>
          <th>Tipus camp</th>
          <th>Valor per defecte recomanat</th>
          <th>Exemple</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>String</strong></td>
          <td>Text descriptiu</td>
          <td><code>'Sense nom'</code>, <code>'No disponible'</code></td>
        </tr>
        <tr>
          <td><strong>Number</strong></td>
          <td>0 o valor mínim lògic</td>
          <td><code>0</code>, <code>1</code></td>
        </tr>
        <tr>
          <td><strong>Boolean</strong></td>
          <td>false (més segur)</td>
          <td><code>false</code></td>
        </tr>
        <tr>
          <td><strong>Array</strong></td>
          <td>Array buit</td>
          <td><code>[]</code></td>
        </tr>
        <tr>
          <td><strong>Date</strong></td>
          <td>undefined o data actual</td>
          <td><code>undefined</code>, <code>new Date()</code></td>
        </tr>
        <tr>
          <td><strong>Objecte</strong></td>
          <td>Objecte buit o undefined</td>
          <td><code>{}</code>, <code>undefined</code></td>
        </tr>
        <tr>
          <td><strong>URL imatge</strong></td>
          <td>Placeholder estàtic</td>
          <td><code>'/assets/img/placeholder.png'</code></td>
        </tr>
        <tr>
          <td><strong>ID</strong></td>
          <td>Generat (timestamp o UUID)</td>
          <td><code>Date.now()</code>, <code>crypto.randomUUID()</code></td>
        </tr>
      </tbody>
    </table>
    <h4>2.8.5. Gestió de múltiples nivells opcionals</h4>
    <p>Amb objectes niats opcionals, utilitzeu optional chaining (<code>?.</code>):</p>
    {% capture code_320 %}interface ElementAPINested {
  id: number;
  product?: {
    details?: {
      description?: string;
      specs?: string;
    };
  };
}
export function adaptarElementAPINested(elem: ElementAPINested): ElementCataleg {
  return {
    id: elem.id,
    descripcio: elem.product?.details?.description ?? 'Sense descripció',
    especificacions: elem.product?.details?.specs ?? 'Sense especificacions'
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_320 %}
    <p><strong>Context d'integració:</strong> Els valors per defecte asseguren que la UI sempre rep dades consistents, complementant la gestió d'errors (Lectura 3.1.3).</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_321 %}// Proveu amb dades incompletes:
const incomplet: ElementAPI = {
  id: 1,
  title: 'Element mínim',
  description: 'Desc',
  category: 'test',
  price: '10.00'
};
const adaptat = adaptarElementAPI(incomplet);
console.log(adaptat.imatge);
console.log(adaptat.destacat);
console.log(adaptat.dataPublicacio);{% endcapture %}
    {% include code-block.html lang="typescript" code=code_321 %}
  {% endcapture %}
  {% include section-point.html numero="2.8" titol="Valors per defecte: gestionar camps opcionals o absents" contingut=section_point_2_8 %}

  {% capture section_point_2_9 %}
    <h4>2.9.1. String → Number</h4>
    <p>APIs retornen sovint nombres com strings:</p>
    {% capture code_322 %}// API retorna:
{ "price": "199.90", "quantity": "5" }
// Adaptador converteix:
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    preu: parseFloat(elem.price),
    quantitat: parseInt(elem.quantity, 10),
    preuValidat: !isNaN(parseFloat(elem.price)) ? parseFloat(elem.price) : 0
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_322 %}
    <p><strong>Funcions de conversió:</strong></p>
    <ul>
      <li><code>parseFloat(str)</code>: Converteix string a decimal</li>
      <li><code>parseInt(str, 10)</code>: Converteix string a enter (base 10)</li>
      <li><code>Number(str)</code>: Conversió genèrica (menys robust)</li>
    </ul>
    <h4>2.9.2. String ISO → Date</h4>
    <p>Dates ISO 8601 són strings que cal convertir:</p>
    {% capture code_323 %}// API retorna:
{ "published_at": "2024-01-15T10:30:00Z" }
// Adaptador converteix:
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    dataPublicacio: elem.published_at ? new Date(elem.published_at) : undefined,
    dataValidada: elem.published_at && !isNaN(Date.parse(elem.published_at)) ? new Date(elem.published_at) : new Date()
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_323 %}
    <h4>2.9.3. Boolean numèric (0/1) → Boolean</h4>
    <p>APIs de PHP, bases de dades retornen booleans com 0/1:</p>
    {% capture code_324 %}// API retorna:
{ "is_featured": 1, "is_active": 0 }
// Adaptador converteix:
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    destacat: elem.is_featured === 1,
    actiu: elem.is_active === 1,
    destacatAlt: !!elem.is_featured
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_324 %}
    <h4>2.9.4. String CSV → Array</h4>
    <p>Llistes en format CSV que cal dividir:</p>
    {% capture code_325 %}// API retorna:
{ "tags": "furniture,modern,wood" }
// Adaptador converteix:
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    etiquetes: elem.tags ? elem.tags.split(',').map(t => t.trim()) : [],
    etiquetesNetes: elem.tags ? elem.tags.split(',').map(t => t.trim()).filter(t => t.length > 0) : []
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_325 %}
    <h4>2.9.5. Object string → Object</h4>
    <p>JSON serialitzat dins de string:</p>
    {% capture code_326 %}// API retorna:
{ "metadata": "{\"color\":\"blue\",\"size\":\"large\"}" }
// Adaptador converteix:
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  let metadata = {};
  try {
    metadata = elem.metadata ? JSON.parse(elem.metadata) : {};
  } catch (e) {
    console.error('Error parsing metadata:', e);
    metadata = {};
  }
  return {
    color: metadata.color ?? 'default',
    mida: metadata.size ?? 'medium'
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_326 %}
    <h4>2.9.6. Taula de funcions de conversió</h4>
    <table>
      <thead>
        <tr>
          <th>Tipus origen</th>
          <th>Tipus destí</th>
          <th>Funció</th>
          <th>Exemple</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>string</td>
          <td>number</td>
          <td><code>parseFloat()</code></td>
          <td><code>"99.90"</code> → <code>99.90</code></td>
        </tr>
        <tr>
          <td>string</td>
          <td>number</td>
          <td><code>parseInt(str, 10)</code></td>
          <td><code>"5"</code> → <code>5</code></td>
        </tr>
        <tr>
          <td>string</td>
          <td>Date</td>
          <td><code>new Date()</code></td>
          <td><code>"2024-01-15T..."</code> → <code>Date</code></td>
        </tr>
        <tr>
          <td>number (0/1)</td>
          <td>boolean</td>
          <td><code>=== 1</code></td>
          <td><code>1</code> → <code>true</code></td>
        </tr>
        <tr>
          <td>string</td>
          <td>boolean</td>
          <td><code>=== 'true'</code></td>
          <td><code>"true"</code> → <code>true</code></td>
        </tr>
        <tr>
          <td>string CSV</td>
          <td>string[]</td>
          <td><code>.split(',')</code></td>
          <td><code>"a,b,c"</code> → <code>["a","b","c"]</code></td>
        </tr>
        <tr>
          <td>string JSON</td>
          <td>object</td>
          <td><code>JSON.parse()</code></td>
          <td><code>'{"a":1}'</code> → <code>{a:1}</code></td>
        </tr>
        <tr>
          <td>undefined/null</td>
          <td>T</td>
          <td><code>?? valorDefecte</code></td>
          <td><code>null</code> → <code>valorDefecte</code></td>
        </tr>
      </tbody>
    </table>
    <h4>2.9.7. Exemple complet amb múltiples conversions</h4>
    {% capture code_327 %}interface ElementAPIComplexTypes {
  id: number;
  title: string;
  price: string;
  is_featured: number;
  published_at: string;
  tags: string;
  rating: string;
  stock: string;
}
export function adaptarComplexTypes(elem: ElementAPIComplexTypes): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.title,
    preu: parseFloat(elem.price),
    valoracio: parseFloat(elem.rating),
    stock: parseInt(elem.stock, 10),
    destacat: elem.is_featured === 1,
    dataPublicacio: new Date(elem.published_at),
    etiquetes: elem.tags.split(',').map(t => t.trim())
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_327 %}
    <p><strong>Context d'integració:</strong> Les transformacions de tipus asseguren que els models interns utilitzen sempre els tipus correctes, facilitant càlculs i validacions posteriors.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_328 %}// Proveu conversions:
const test: ElementAPIComplexTypes = {
  id: 1,
  title: 'Test',
  price: '199.90',
  is_featured: 1,
  published_at: '2024-01-15T10:30:00Z',
  tags: 'furniture, modern, wood',
  rating: '4.5',
  stock: '10'
};
const adaptat = adaptarComplexTypes(test);
console.log(typeof adaptat.preu);
console.log(typeof adaptat.destacat);
console.log(adaptat.dataPublicacio instanceof Date);
console.log(Array.isArray(adaptat.etiquetes));{% endcapture %}
    {% include code-block.html lang="typescript" code=code_328 %}
  {% endcapture %}
  {% include section-point.html numero="2.9" titol="Transformació de tipus: convertir text a nombre, dates a objectes" contingut=section_point_2_9 %}

  {% capture section_point_2_10 %}
    <h4>2.10.1. Organització en carpeta dedicada</h4>
    <p>Creeu una carpeta <code>src/app/adaptadors</code> amb estructura clara:</p>
    {% capture code_329 %}src/app/adaptadors/
├── element.adaptador.ts
├── categoria.adaptador.ts
├── usuari.adaptador.ts
├── comanda.adaptador.ts
└── types/
    ├── element-api.type.ts
    ├── categoria-api.type.ts
    ├── usuari-api.type.ts
    └── comanda-api.type.ts{% endcapture %}
    {% include code-block.html lang="text" code=code_329 %}
    <h4>2.10.2. Un adaptador per entitat</h4>
    <p>Cada entitat del domini té el seu propi adaptador:</p>
    <p><strong>element.adaptador.ts:</strong></p>
    {% capture code_330 %}export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  // Transformació específica d'elements
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_330 %}
    <p><strong>categoria.adaptador.ts:</strong></p>
    {% capture code_331 %}export function adaptarCategoriaAPI(cat: CategoriaAPI): Categoria {
  // Transformació específica de categories
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_331 %}
    <h4>2.10.3. Reutilització en múltiples serveis</h4>
    <p>L'adaptador centralitzat es reutilitza arreu:</p>
    {% capture code_332 %}// Servei 1: ElementService
carregarElements(): void {
  this.http.get<ElementAPI[]>(url).subscribe({
    next: resposta => {
      const adaptats = resposta.map(adaptarElementAPI);
      this.elements.set(adaptats);
    }
  });
}
// Servei 2: CercaService
cercar(terme: string): void {
  this.http.get<ElementAPI[]>(`${url}?q=${terme}`).subscribe({
    next: resposta => {
      const adaptats = resposta.map(adaptarElementAPI);
      this.resultats.set(adaptats);
    }
  });
}
// Servei 3: PreferitsService
obtenirPreferits(ids: number[]): void {
  this.http.post<ElementAPI[]>(`${url}/batch`, { ids }).subscribe({
    next: resposta => {
      const adaptats = resposta.map(adaptarElementAPI);
      this.preferits.set(adaptats);
    }
  });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_332 %}
    <h4>2.10.4. Adaptadors compostos</h4>
    <p>Per a entitats complexes, composeu adaptadors:</p>
    {% capture code_333 %}interface ComandaAPI {
  id: number;
  user: UsuariAPI;
  items: ElementAPI[];
  total: number;
}
export function adaptarComandaAPI(comanda: ComandaAPI): Comanda {
  return {
    id: comanda.id,
    usuari: adaptarUsuariAPI(comanda.user),
    elements: comanda.items.map(adaptarElementAPI),
    total: comanda.total
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_333 %}
    <h4>2.10.5. Documentació del contracte</h4>
    <p>Documenteu cada adaptador amb JSDoc:</p>
    {% capture code_334 %}/**
 * Adaptador per transformar elements de l'API al model intern
 *
 * @module adaptadors/element
 * @since 1.0.0
 */
/**
 * Transforma un element de l'API al model ElementCataleg
 *
 * @param {ElementAPI} apiElement - Element tal com ve de l'API externa
 * @returns {ElementCataleg} Element adaptat al model intern
 *
 * @example
 * const apiData: ElementAPI = {
 *   id: 1,
 *   title: 'Modern Table',
 *   price: '199.90',
 *   is_featured: 1
 * };
 * const adaptat = adaptarElementAPI(apiData);
 */
export function adaptarElementAPI(apiElement: ElementAPI): ElementCataleg {
  // Implementació...
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_334 %}
    <p><strong>Context d'integració:</strong> Centralitzar adaptadors facilita manteniment i testing, seguint el principi DRY (Don't Repeat Yourself).</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_335 %}# Estructura verificada:
tree src/app/adaptadors
# Tests de tots els adaptadors:
npm run test -- adaptadors/
# Coverage dels adaptadors:
npm run test -- --coverage --coveragePathPattern=adaptadors{% endcapture %}
    {% include code-block.html lang="bash" code=code_335 %}
  {% endcapture %}
  {% include section-point.html numero="2.10" titol="Adaptadors centralitzats: una única funció per entitat" contingut=section_point_2_10 %}

  {% capture section_point_2_11 %}
    <h4>2.11.1. Resposta completa d'API real</h4>
    {% capture code_336 %}{"status": "success", "data": [{"id": 1, "title": "Modern Wooden Table", "description": "Elegant table made from solid oak wood", "category": "furniture", "price": "199.90", "image_url": "https://api.example.com/images/table-001.jpg", "is_featured": 1, "published_at": "2024-01-15T10:30:00Z", "rating": "4.5", "stock": "15", "tags": "furniture,modern,wood,oak"}, {"id": 2, "title": "Office Chair", "description": null, "category": "furniture", "price": "89.90", "image_url": null, "is_featured": 0, "published_at": null, "rating": null, "stock": "0", "tags": "furniture,office"}], "meta": {"total": 150, "page": 1, "per_page": 20}}{% endcapture %}
    {% include code-block.html lang="json" code=code_336 %}
    <h4>2.11.2. Adaptador complet implementat</h4>
    {% capture code_337 %}// Types
interface APIResponse {
  status: string;
  data: ElementAPI[];
  meta: {
    total: number;
    page: number;
    per_page: number;
  };
}
interface ElementAPI {
  id: number;
  title: string;
  description: string | null;
  category: string;
  price: string;
  image_url: string | null;
  is_featured: 0 | 1;
  published_at: string | null;
  rating: string | null;
  stock: string;
  tags: string;
}
// Adaptadors
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.title,
    descripcio: elem.description ?? 'Sense descripció disponible',
    categoria: elem.category,
    preu: parseFloat(elem.price),
    imatge: elem.image_url ?? '/assets/img/placeholder.png',
    destacat: elem.is_featured === 1,
    dataPublicacio: elem.published_at ? new Date(elem.published_at) : undefined,
    valoracio: elem.rating ? parseFloat(elem.rating) : 0,
    stock: parseInt(elem.stock, 10),
    etiquetes: elem.tags.split(',').map(t => t.trim()),
    disponible: parseInt(elem.stock, 10) > 0
  };
}
export function adaptarRespostaCompleta(resposta: APIResponse): ElementCataleg[] {
  return resposta.data.map(adaptarElementAPI);
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_337 %}
    <h4>2.11.3. Servei utilitzant adaptador</h4>
    {% capture code_338 %}@Injectable({ providedIn: 'root' })
export class ElementService {
  private readonly http = inject(HttpClient);
  private readonly baseUrl = 'http://localhost:4301';
  private readonly elements = signal<ElementCataleg[]>([]);
  private readonly estat = signal<EstatServei>({ carregant: false, error: null });
  carregarElements(): void {
    this.estat.set({ carregant: true, error: null });
    this.http.get<APIResponse>(`${this.baseUrl}/elements`).subscribe({
      next: (resposta: APIResponse) => {
        if (resposta.status !== 'success') {
          throw new Error(`API retorna status: ${resposta.status}`);
        }
        const elementsAdaptats = adaptarRespostaCompleta(resposta);
        this.elements.set(elementsAdaptats);
        this.estat.set({ carregant: false, error: null });
        console.log(`${elementsAdaptats.length} elements carregats i adaptats`);
      },
      error: err => {
        console.error('Error carregant elements:', err);
        this.elements.set([]);
        this.estat.set({
          carregant: false,
          error: 'No hem pogut carregar el catàleg'
        });
      }
    });
  }
  elements$() {
    return this.elements.asReadonly();
  }
  estat$() {
    return this.estat.asReadonly();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_338 %}
    <h4>2.11.4. Verificació a la consola</h4>
    {% capture code_339 %}// Al navegador (DevTools Console):
// 1. Abans d'adaptar:
console.log('Resposta API RAW:', respostaAPI.data[0]);
// {
//   id: 1,
//   title: "Modern Wooden Table",
//   price: "199.90",
//   is_featured: 1,
//   image_url: null
// }
// 2. Després d'adaptar:
const adaptat = adaptarElementAPI(respostaAPI.data[0]);
console.log('Element ADAPTAT:', adaptat);
// {
//   id: 1,
//   nom: "Modern Wooden Table",
//   preu: 199.90,
//   destacat: true,
//   imatge: "/assets/img/placeholder.png"
// }
// 3. Verificar tipus:
console.log('Tipus preu:', typeof adaptat.preu);
console.log('Tipus destacat:', typeof adaptat.destacat);
console.log('Tipus etiquetes:', Array.isArray(adaptat.etiquetes));{% endcapture %}
    {% include code-block.html lang="typescript" code=code_339 %}
    <p><strong>Context d'integració:</strong> L'exemple complet mostra el flux sencer des de la petició HTTP fins a les dades adaptades disponibles als components.</p>
    <p><strong>Verificació pràctica:</strong></p>
    {% capture code_340 %}# Executar aplicació i verificar adaptacions:
ng serve --port 4300
# A DevTools Console:
# - Inspeccionar network per veure resposta raw
# - Inspeccionar Vue components per veure dades adaptades
# - Confirmar que tipus són correctes{% endcapture %}
    {% include code-block.html lang="bash" code=code_340 %}
  {% endcapture %}
  {% include section-point.html numero="2.11" titol="Exemple pràctic: adaptar resposta d'una API d'elements al model" contingut=section_point_2_11 %}

  {% capture section_point_2_12 %}
    <p><strong>Escenari:</strong> Implementar adaptador complet per a l'API de catàleg amb validació i logging.</p>
    <p><strong>Passos:</strong></p>
    <p><strong>1. Capturar resposta real de l'API:</strong></p>
    {% capture code_341 %}mkdir -p examples
curl http://localhost:4301/elements | jq '.' > examples/resposta-api-raw.json{% endcapture %}
    {% include code-block.html lang="bash" code=code_341 %}
    <p><strong>2. Analitzar estructura i identificar diferències:</strong></p>
    <ul>
      <li>Camps amb noms diferents: <code>title</code> vs <code>nom</code></li>
      <li>Tipus incorrectes: <code>price</code> string vs <code>preu</code> number</li>
      <li>Camps opcionals: <code>image_url</code>, <code>is_featured</code></li>
    </ul>
    <p><strong>3. Crear tipus extern:</strong></p>
    {% capture code_342 %}// src/app/adaptadors/types/element-api.type.ts
export interface ElementAPI {
  id: number;
  title: string;
  description: string;
  category: string;
  price: string;
  image_url?: string;
  is_featured?: number;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_342 %}
    <p><strong>4. Implementar adaptador:</strong></p>
    {% capture code_343 %}// src/app/adaptadors/element.adaptador.ts
export function adaptarElementAPI(elem: ElementAPI): ElementCataleg {
  return {
    id: elem.id,
    nom: elem.title,
    descripcio: elem.description,
    categoria: elem.category,
    preu: parseFloat(elem.price),
    imatge: elem.image_url ?? '/assets/img/placeholder.png',
    destacat: elem.is_featured === 1
  };
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_343 %}
    <p><strong>5. Integrar al servei:</strong></p>
    {% capture code_344 %}// src/app/serveis/element.service.ts
import { adaptarElementAPI } from '../adaptadors/element.adaptador';
carregarElements(): void {
  this.http.get<ElementAPI[]>(url).subscribe({
    next: resposta => {
      const adaptats = resposta.map(adaptarElementAPI);
      this.elements.set(adaptats);
    }
  });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_344 %}
    <p><strong>6. Crear tests:</strong></p>
    {% capture code_345 %}// src/app/adaptadors/element.adaptador.spec.ts
describe('adaptarElementAPI', () => {
  it('hauria de transformar correctament', () => {
    const apiElem: ElementAPI = {
      id: 1,
      title: 'Test',
      description: 'Desc',
      category: 'Cat',
      price: '99.90'
    };
    const result = adaptarElementAPI(apiElem);
    expect(result.nom).toBe('Test');
    expect(result.preu).toBe(99.90);
    expect(typeof result.preu).toBe('number');
  });
});{% endcapture %}
    {% include code-block.html lang="typescript" code=code_345 %}
    <p><strong>7. Documentar contracte:</strong></p>
    {% capture code_346 %}# docs/adaptadors.md
## ElementAPI → ElementCataleg
| Camp API | Camp Model | Transformació |
|----------|-----------|---------------|
| title | nom | - |
| price | preu | parseFloat() |
| image_url | imatge | ?? placeholder |{% endcapture %}
    {% include code-block.html lang="markdown" code=code_346 %}
    <p><strong>8. Validar execució:</strong></p>
    {% capture code_347 %}npm run lint
npm run test -- adaptadors/
ng serve --port 4300{% endcapture %}
    {% include code-block.html lang="bash" code=code_347 %}
    <p><strong>Resultat esperat:</strong> Adaptador funcional que transforma dades de l'API al model intern, amb tests passant i documentació completa.</p>
  {% endcapture %}
  {% include section-point.html numero="2.12" titol="Mini exemple pràctic" contingut=section_point_2_12 %}

  {% capture section_point_2_13 %}
    <h4>2.13.1. Errors transversals</h4>
    <table>
      <thead>
        <tr>
          <th>Símptoma</th>
          <th>Causa probable</th>
          <th>Solució</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Adaptador no transforma camps</td>
          <td>Mapeig incorrecte de propietats</td>
          <td>Revisar correspondència camp extern → intern</td>
        </tr>
        <tr>
          <td>Valors per defecte no s'apliquen</td>
          <td>Operador <code>??</code> mal utilitzat</td>
          <td>Canviar <code>||</code> per <code>??</code> (nullish coalescing)</td>
        </tr>
        <tr>
          <td>Tipus incorrectes després d'adaptar</td>
          <td>Manca conversió de tipus</td>
          <td>Afegir <code>parseFloat()</code>, <code>parseInt()</code>, etc.</td>
        </tr>
        <tr>
          <td><code>NaN</code> en càlculs amb preus</td>
          <td>String no convertit a number</td>
          <td>Usar <code>parseFloat(elem.price)</code> en lloc de <code>elem.price</code></td>
        </tr>
        <tr>
          <td>Camps niats retornen undefined</td>
          <td>Manca optional chaining</td>
          <td>Usar <code>elem.obj?.prop</code> en lloc de <code>elem.obj.prop</code></td>
        </tr>
        <tr>
          <td>Dates invàlides</td>
          <td>Format ISO incorrecte</td>
          <td>Validar amb <code>!isNaN(Date.parse(str))</code> abans de <code>new Date()</code></td>
        </tr>
        <tr>
          <td>Arrays buits quan no haurien</td>
          <td>Split de string null</td>
          <td>Afegir validació: <code>str ? str.split(',') : []</code></td>
        </tr>
        <tr>
          <td><code>adaptarElementAPI is not a function</code></td>
          <td>Import incorrecte</td>
          <td>Verificar export/import: <code>export function adaptarElementAPI</code></td>
        </tr>
        <tr>
          <td>Múltiples transformacions al servei</td>
          <td>Adaptador no reutilitzat</td>
          <td>Centralitzar en una funció i cridar sempre</td>
        </tr>
        <tr>
          <td>Dades sense adaptar a UI</td>
          <td>Servei no crida adaptador</td>
          <td>Afegir <code>.map(adaptarElementAPI)</code> després de <code>subscribe</code></td>
        </tr>
      </tbody>
    </table>
    <h4>2.13.2. Errors de configuració</h4>
    <table>
      <thead>
        <tr>
          <th>Error</th>
          <th>Causa</th>
          <th>Solució</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>Cannot find module './adaptadors'</code></td>
          <td>Ruta import incorrecta</td>
          <td>Verificar ruta relativa: <code>../adaptadors/element.adaptador</code></td>
        </tr>
        <tr>
          <td>TypeScript no detecta tipus API</td>
          <td>Tipus no exportat</td>
          <td>Afegir <code>export interface ElementAPI</code></td>
        </tr>
        <tr>
          <td>Tests no troben adaptadors</td>
          <td>Path mapping incorrecte</td>
          <td>Configurar <code>paths</code> a <code>tsconfig.spec.json</code></td>
        </tr>
        <tr>
          <td>Servei no compila després afegir adaptador</td>
          <td>Tipus genèric incorrecte a <code>http.get</code></td>
          <td>Canviar <code>get&lt;any&gt;</code> per <code>get&lt;ElementAPI[]&gt;</code></td>
        </tr>
        <tr>
          <td>Circular dependency warnings</td>
          <td>Adaptador importa servei</td>
          <td>No importar mai serveis des d'adaptadors</td>
        </tr>
      </tbody>
    </table>
    <h4>2.13.3. Problemes de dependències</h4>
    <table>
      <thead>
        <tr>
          <th>Error</th>
          <th>Causa</th>
          <th>Solució</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>RxJS map not found</code></td>
          <td>Import incorrecte</td>
          <td><code>import { map } from 'rxjs/operators'</code></td>
        </tr>
        <tr>
          <td>TypeScript version mismatch</td>
          <td>TS incompatible amb Angular</td>
          <td><code>ng update @angular/core @angular/cli</code></td>
        </tr>
        <tr>
          <td>Tests fallen per tipus API</td>
          <td>Mock no té tipus correctes</td>
          <td>Utilitzar <code>Partial&lt;ElementAPI&gt;</code> o crear factory</td>
        </tr>
        <tr>
          <td>Coverage baixa d'adaptadors</td>
          <td>Tests insuficients</td>
          <td>Crear tests per tots els casos: happy path + edge cases</td>
        </tr>
      </tbody>
    </table>
  {% endcapture %}
  {% include section-point.html numero="2.13" titol="Resolució de problemes" contingut=section_point_2_13 %}

  {% capture section_point_2_14 %}
    <h4>2.14.1. Comprensió conceptual</h4>
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert Angular. <strong>Context:</strong> Estic aprenent adaptadors de dades per APIs. <strong>Tasca:</strong> Explica per què és millor tenir un adaptador centralitzat que transformar dades en diversos llocs del codi, amb exemples concrets de mantenibilitat i avantatges. <strong>Format:</strong> Explicació clara amb codi abans/després." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert TypeScript. <strong>Context:</strong> Estic treballant amb adaptadors. <strong>Tasca:</strong> Quina és la diferència entre mapear camps (rename) i transformar tipus (conversió)? Proporciona exemples de cada cas i quan utilitzar cadascun. <strong>Format:</strong> Comparativa amb taula i exemples de codi." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de programari. <strong>Context:</strong> Dissenyant adaptadors robustos. <strong>Tasca:</strong> Quan hauríem de llançar errors en un adaptador vs retornar valors per defecte? Proporciona criteris de decisió amb exemples concrets. <strong>Format:</strong> Guia de decisions amb arbre de decisió." %}
    <h4>2.14.2. Generació de codi</h4>
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Generador de codi Angular. <strong>Context:</strong> Integració amb API externa. <strong>Tasca:</strong> Crea un adaptador complet que transformi una resposta d'API amb camps en anglès i snake_case (id, product_name, unit_price, image_url, is_featured) a un model català amb camelCase (id, nom, preu, imatge, destacat). Inclou tipus TypeScript i conversions necessàries. <strong>Format:</strong> Codi TypeScript executable amb comentaris." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Documentador tècnic. <strong>Context:</strong> Documentar contracte d'adaptador. <strong>Tasca:</strong> Genera una taula markdown de correspondències entre 10 camps d'API externa i el model intern, especificant tipus origen, tipus destí i transformació aplicada per cada camp. <strong>Format:</strong> Taula markdown completa." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en testing Angular. <strong>Context:</strong> Testing d'adaptadors. <strong>Tasca:</strong> Escriu tests complets amb Jasmine per a un adaptador que gestiona camps opcionals i conversions de tipus (string→number, 0/1→boolean, ISO→Date). Inclou happy path i edge cases. <strong>Format:</strong> Codi de tests executable amb describe/it." %}
    <h4>2.14.3. Resolució de problemes</h4>
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Debugger Angular. <strong>Context:</strong> El meu adaptador no aplica valors per defecte correctament. <strong>Tasca:</strong> Revisa aquest codi i identifica el problema: [enganxa el teu codi aquí]. Verifica: ús correcte de <code>??</code> vs <code>||</code>, ordre de validacions, tipus de retorn. <strong>Format:</strong> Anàlisi línia per línia amb solució." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en transformació de dades. <strong>Context:</strong> API retorna dates en format DD/MM/YYYY. <strong>Tasca:</strong> Com puc gestionar una API que retorna dates en format DD/MM/YYYY en lloc d'ISO? Proporciona funció de parsejat, validació d'errors i fallback. <strong>Format:</strong> Codi TypeScript amb gestió d'errors completa." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de programari. <strong>Context:</strong> Dades API profundament niades. <strong>Tasca:</strong> Quin és el millor patró per adaptar dades niades amb múltiples nivells opcionals (ex: <code>obj?.lvl1?.lvl2?.lvl3</code>)? Proporciona estratègies amb optional chaining, validacions i valors per defecte. <strong>Format:</strong> Patrons amb exemples de codi." %}
    <h4>2.14.4. Anàlisi i millora</h4>
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte Angular. <strong>Context:</strong> Decidir on col·locar transformacions. <strong>Tasca:</strong> Compara els avantatges i inconvenients d'adaptar dades al servei (després de HTTP) vs adaptar-les al component (abans de mostrar). Considera mantenibilitat, reutilització i testabilitat. <strong>Format:</strong> Taula comparativa amb recomanacions." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Quality Assurance Angular. <strong>Context:</strong> Validar implementació d'adaptador. <strong>Tasca:</strong> Genera un checklist complet per validar que un adaptador està complet i ben implementat: tipus definits, conversions correctes, valors per defecte, tests, documentació. <strong>Format:</strong> Checklist markdown amb criteris d'acceptació." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de sistemes. <strong>Context:</strong> API en evolució constant. <strong>Tasca:</strong> Proposa una estratègia per mantenir adaptadors actualitzats quan l'API evoluciona: versionatge d'adaptadors, retrocompatibilitat, detecció de canvis trencants, migration paths. <strong>Format:</strong> Estratègia pas a pas amb exemples." %}
  {% endcapture %}
  {% include section-point.html numero="2.14" titol="Prompts d'IA" contingut=section_point_2_14 %}

  {% capture section_point_2_15 %}
    <h4>2.15.1. Criteris objectius (Definition of Done)</h4>
    <p><strong>L'aplicació està completa quan:</strong></p>
    <p><strong>Funcionalitat:</strong></p>
    {% include checklist.html elements="He vist l'adaptador transformant dades d'API a model intern|He comprovat que valors per defecte s'apliquen quan falten camps|He verificat que tipus són correctes després d'adaptar (number, boolean, Date)|He confirmat que la UI mostra dades adaptades consistents" %}
    <p><strong>Adaptadors i estructura:</strong></p>
    {% include checklist.html elements="He creat funcions adaptadores per totes les entitats principals|He organitzat adaptadors a carpeta <code>src/app/adaptadors</code>|He definit tipus API externs a carpeta <code>types/</code>|He documentat mapeig de camps amb taules de correspondències" %}
    <p><strong>Transformacions:</strong></p>
    {% include checklist.html elements="He implementat mapeig de camps amb noms diferents|He aplicat conversions de tipus (string→number, 0/1→boolean)|He gestionat camps opcionals amb operador <code>??</code>|He implementat extracció de dades niades" %}
    <p><strong>Control de versions:</strong></p>
    {% include checklist.html elements="He fet commit dels adaptadors nous|He actualitzat serveis per utilitzar adaptadors|He documentat contracte de transformació a <code>docs/adaptadors.md</code>" %}
    <p><strong>Proves i validació:</strong></p>
    {% include checklist.html elements="He creat tests per adaptadors amb casos happy path|He provat amb camps mancants (edge cases)|He executat <code>npm run lint</code> sense errors|He verificat que <code>npm run test</code> passa tots els tests" %}
    <h4>2.15.2. Competències adquirides</h4>
    <p><strong>Creació d'adaptadors:</strong></p>
    {% include checklist.html elements="Sé crear funcions adaptadores pures que no muten l'objecte original|Puc mapear camps amb noms diferents entre extern i intern|Entenc com aplicar valors per defecte amb operador <code>??</code>|Sé transformar tipus (string→number, 0/1→boolean, ISO→Date)" %}
    <p><strong>Gestió de dades externes:</strong></p>
    {% include checklist.html elements="Puc analitzar resposta d'API i identificar diferències amb models interns|Sé gestionar camps opcionals amb validacions adequades|Entenc com extreure dades de estructures niades amb optional chaining|Puc validar dades transformades abans de retornar-les" %}
    <p><strong>Organització i mantenibilitat:</strong></p>
    {% include checklist.html elements="Sé organitzar adaptadors en carpetes amb estructura clara|Puc documentar contractes de transformació amb taules de correspondències|Entenc avantatges de centralitzar adaptadors vs transformacions disperses|Sé quan crear un adaptador nou vs reutilitzar existent" %}
    <p><strong>Testing d'adaptadors:</strong></p>
    {% include checklist.html elements="Puc escriure tests unitaris per funcions adaptadores|Sé crear mocks d'API amb tipus correctes|Entenc com provar casos happy path i edge cases|Puc verificar que conversions de tipus funcionen correctament" %}
    <p><strong>Resolució de problemes:</strong></p>
    {% include checklist.html elements="Puc diagnosticar errors de mapeig incorrecte|Sé solucionar problemes amb valors per defecte|Entenc com gestionar circular dependencies entre models i adaptadors|Puc optimitzar adaptadors lents amb múltiples transformacions" %}
  {% endcapture %}
  {% include section-point.html numero="2.15" titol="Autoavaluació" contingut=section_point_2_15 %}

  {% capture section_point_2_16 %}
    <h4>2.16.1. Què hem aconseguit</h4>
    <p>Heu construït un <strong>sistema d'adaptadors</strong> que desacobla completament l'aplicació de les APIs externes. Ara el vostre codi intern està protegit contra canvis del backend, treballa amb models consistents en català, i utilitza sempre els tipus correctes.</p>
    <p>Aquest sistema us permet consumir qualsevol API externa (amb noms en anglès, estructures diferents, tipus incorrectes) i traduir-la automàticament al vostre model intern. Quan l'API canvia, només cal actualitzar l'adaptador en un únic lloc.</p>
    <p>Disposeu d'un <strong>catàleg amb adaptació completa</strong> que inclou:</p>
    <ul>
      <li><strong>Funcions adaptadores pures:</strong> Transformen objectes API a models interns sense efectes secundaris.</li>
      <li><strong>Mapeig de camps:</strong> Correspondència clara entre noms externs (<code>title</code>) i interns (<code>nom</code>).</li>
      <li><strong>Conversions de tipus:</strong> Strings a numbers, 0/1 a booleans, ISO strings a Dates.</li>
      <li><strong>Valors per defecte:</strong> Gestió automàtica de camps opcionals amb operador <code>??</code>.</li>
      <li><strong>Centralització:</strong> Un adaptador per entitat, reutilitzat en múltiples serveis.</li>
    </ul>
    <h4>2.16.2. Què queda preparat per a la Lectura 3.2.3</h4>
    <p>A la <strong>Lectura 3.2.3 (Integració reactiva)</strong> connectareu els adaptadors amb signals i subscripcions per actualitzar la UI automàticament quan arribin dades noves de l'API.</p>
    <p>Els adaptadors ja transformem les dades correctament. Ara només cal fer que aquesta transformació sigui <strong>reactiva</strong>: quan l'API retorna dades actualitzades, els adaptadors les transformen i els signals propaguen els canvis a tots els components subscrits automàticament.</p>
    <p>Completareu el flux de dades complet: <strong>API → Adaptador → Signal → Component → Plantilla</strong>, amb reactivitat automàtica end-to-end.</p>
    <h4>2.16.3. Contracte de sortida</h4>
    <ul>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Adaptadors creats per totes les entitats principals</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Serveis utilitzen adaptadors per transformar respostes d'API</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Mapeig de camps documentat amb taules de correspondències</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Conversions de tipus implementades (string→number, 0/1→boolean)</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Valors per defecte aplicats a camps opcionals</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Tests d'adaptadors passant amb coverage >80%</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> Documentació completa del contracte de transformació</li>
    </ul>
    <p><strong>Ara podeu integrar qualsevol API externa sense acoblar el codi intern!</strong></p>
    <h4>2.16.4. Referències ràpides</h4>
    <p><strong>Comandes essencials:</strong></p>
    {% capture code_348 %}ng generate class adaptadors/element-adaptador
npm run test -- adaptadors/
npm run test -- --coverage --coveragePathPattern=adaptadors{% endcapture %}
    {% include code-block.html lang="bash" code=code_348 %}
    <p><strong>Troubleshooting ràpid:</strong></p>
    <ul>
      <li>Valors undefined → Afegir <code>?? valorDefecte</code> per camps opcionals</li>
      <li>Tipus incorrectes → Usar <code>parseFloat()</code>, <code>parseInt()</code>, <code>=== 1</code> per conversions</li>
      <li>Mapeig incorrecte → Revisar taula correspondències camp extern → intern</li>
      <li>NaN en càlculs → Validar que strings es converteixen a number</li>
      <li>Camps niats undefined → Usar optional chaining: <code>elem.obj?.prop</code></li>
    </ul>
    <p><strong>Resolució de problemes detallada:</strong> Vegeu secció 2.13</p>
  {% endcapture %}
  {% include section-point.html numero="2.16" titol="Recapitulació" contingut=section_point_2_16 %}

  {% capture section_point_2_17 %}
    <ul>
      <li><strong>Adaptadors de dades:</strong> Funcions pures que transformen objectes API a models interns. Actuen com pont entre format extern i format intern. Centralitzen tota la lògica de transformació en un únic lloc.</li>
      <li><strong>Mapeig de camps:</strong> Correspondència entre noms externs i interns: <code>title</code> → <code>nom</code>. Canvi de convencions: snake_case → camelCase. Extracció de dades niades amb optional chaining (<code>?.</code>).</li>
      <li><strong>Conversions de tipus:</strong> String → Number (<code>parseFloat()</code>, <code>parseInt()</code>). Number (0/1) → Boolean (<code>=== 1</code>). String ISO → Date (<code>new Date()</code>). String CSV → Array (<code>.split(',')</code>).</li>
      <li><strong>Valors per defecte:</strong> Operador <code>??</code> retorna dreta si esquerra és <code>null</code>/<code>undefined</code>. Aplicats a camps opcionals per garantir consistència. Poden ser estàtics, generats o condicionals.</li>
      <li><strong>Organització:</strong> Carpeta dedicada: <code>src/app/adaptadors/</code>. Tipus API a subcarpeta: <code>adaptadors/types/</code>. Un adaptador per entitat principal. Documentació de contracte a <code>docs/adaptadors.md</code>.</li>
      <li><strong>Avantatges:</strong> Desacoblament (aplicació independent de l'API externa). Centralització (un punt de canvi quan l'API evoluciona). Consistència (models interns sempre amb tipus correctes). Testabilitat (funcions pures fàcils de testejar aïlladament).</li>
      <li><strong>Bones pràctiques:</strong> Crear tests per tots els adaptadors. Documentar correspondències amb taules. Validar dades crítiques, aplicar fallbacks per opcionals. No importar mai serveis des d'adaptadors (evitar circular deps). Utilitzar JSDoc per documentar transformacions.</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="2.17" titol="Repàs de conceptes" contingut=section_point_2_17 %}

</div>

<!-- SECCIÓ 3: Integració reactiva amb components -->
<div class="section" id="Unitat3_Bloc2_Seccio3">
  <h2 id="Unitat3_Bloc2_Seccio3">3. Integració reactiva amb components</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=3 bloc=2 seccio=3 %}


  {% include objectius.html llista="Connectar el servei amb components mitjançant fluxos reactius (signals) perquè la interfície s'actualitzi automàticament|Crear un component contenidor que orquestri la càrrega de dades i la gestió d'estats|Aplicar el patró contenidor/presentació per separar lògica de dades de visualització|Configurar plantilles reactives que s'actualitzin automàticament davant canvis" %}

  {% include info_box.html contingut="<strong>RA3 · Criteri 3</strong> — Actualitza la interfície de manera reactiva davant canvis en les dades." %}

  {% capture section_point_3_1 %}
    <p>Abans de començar, necessiteu:</p>
    <ul>
      <li><strong>Lectures 3.1.1–3.1.3 i 3.2.1–3.2.2</strong> — Servei amb peticions HTTP, gestió d'errors, models i adaptadors funcionals</li>
      <li><strong>Servei actiu:</strong> <code>ElementService</code> exposant <code>elements$()</code> i <code>estat$()</code> com a signals</li>
      <li><strong>API disponible:</strong> <code>json-server</code> o equivalent a <code>http://localhost:4301/elements</code></li>
      <li><strong>Documentació:</strong> Fitxers <code>docs/serveis.md</code> i <code>docs/models.md</code> existents</li>
    </ul>
    <p><strong>Verificació ràpida:</strong></p>
    {% capture code_349 %}cd ~/workspace/cataleg-elements
ng serve --port 4300
# En un altre terminal
json-server --watch db.json --port 4301{% endcapture %}
    {% include code-block.html lang="bash" code=code_349 %}
    <p><strong>Punt d'autocomprovació:</strong> El servidor Angular i json-server executant-se sense errors. El catàleg continua mostrant dades adaptades correctament.</p>
  {% endcapture %}
  {% include section-point.html numero="3.1" titol="Prerequisits" contingut=section_point_3_1 %}

  {% capture section_point_3_2 %}
    <h4>3.2.1. Què és la integració reactiva</h4>
    <p>La <strong>integració reactiva</strong> connecta les fonts de dades (serveis) amb els components de forma que la interfície s'actualitzi automàticament quan canvien les dades, sense necessitat de recarregar la pàgina ni invocar actualitzacions manuals.</p>
    <p><strong>Diferència clau:</strong></p>
    <ul>
      <li><strong>Integració manual:</strong> Component crida servei, rep dades, assigna a propietat, detecta canvis manualment</li>
      <li><strong>Integració reactiva:</strong> Component s'observa signals/observables, Angular actualitza DOM automàticament</li>
    </ul>
    <h4>3.2.2. Problema sense integració reactiva</h4>
    <p>Abans dels frameworks reactius, actualitzar la interfície quan canviaven dades remotes requeria codi manual propens a errors.</p>
    <p><strong>Situació sense reactivitat:</strong></p>
    {% capture code_350 %}// component-antic.ts
export class ComponentAntic {
  elements: Element[] = [];
  carregant = false;
  error: string | null = null;
  constructor(private http: HttpClient) {}
  carregarElements(): void {
    this.carregant = true;
    this.error = null;
    this.http.get<Element[]>('http://localhost:4301/elements')
      .subscribe({
        next: (dades) => {
          this.elements = dades;
          this.carregant = false;
          // He d'invocar change detection manualment?
          // Com gestiono múltiples components que necessiten les mateixes dades?
        },
        error: (err) => {
          this.error = 'Error en carregar elements';
          this.carregant = false;
          // Cada component gestiona errors independentment
        }
      });
  }
  // Cal desubscriure manualment en OnDestroy?
  // Què passa si el component es destrueix durant la petició?
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_350 %}
    {% capture code_351 %}<!-- component-antic.html -->
<div *ngIf="carregant">Carregant...</div>
<div *ngIf="error">{{ error }}</div>
<div *ngFor="let element of elements">{{ element.nom }}</div>
<!-- Cal invocar carregarElements() des de 10 components diferents?
     Duplicació de lògica i estat inconsistent entre components -->{% endcapture %}
    {% include code-block.html lang="html" code=code_351 %}
    <p><strong>Problemes que genera:</strong></p>
    <p><strong>1. Duplicació de lògica de càrrega</strong></p>
    <p>Cada component que necessita dades d'elements ha de reimplementar la lògica de petició HTTP, gestió d'errors i gestió d'estat de càrrega. Si teniu 5 components (llista, filtre, detall, formulari, resum), cada un té 30-40 línies de codi duplicat. Manteniment impossible.</p>
    <p><strong>2. Estat inconsistent entre components</strong></p>
    <p>Quan actualitzeu un element des d'un component (ex: formulari), els altres components (llista, detall) continuen mostrant dades desactualitzades. Cal implementar mecanismes de notificació manuals entre components. Sistema fràgil i propens a bugs.</p>
    <p><strong>3. Gestió de subscripcions complexa</strong></p>
    <p>Cada component ha de subscriure's als observables i desubscriure's en <code>ngOnDestroy()</code> per evitar fuites de memòria. Oblidar-ho genera fuites. Codi verbós amb múltiples <code>Subscription</code> i lògica de neteja.</p>
    <p><strong>4. Testing difícil</strong></p>
    <p>Provar un component requereix simular peticions HTTP, gestió d'errors i temps d'espera. Tests acoblats a implementació. Mock de <code>HttpClient</code> en cada test. Tests lents i fràgils.</p>
    <p><strong>5. Actualitzacions manuals del DOM</strong></p>
    <p>Quan les dades canvien (ex: nova petició, filtrat, ordenació), cal invocar change detection manualment o confiar que Angular ho detecti. Comportament inconsistent. Interfície desincronitzada amb dades.</p>
    <h4>3.2.3. Solució amb integració reactiva</h4>
    <p>Angular amb signals proporciona reactivitat sincrònica i automàtica entre servei i components.</p>
    <p><strong>Situació amb reactivitat:</strong></p>
    {% capture code_352 %}// element.service.ts - Servei centralitzat
@Injectable({ providedIn: 'root' })
export class ElementService {
  private elementsSignal = signal<ElementCataleg[]>([]);
  private estatSignal = signal<EstatPeticio>({ carregant: false });
  // Exposem com a ReadonlySignal
  elements$ = this.elementsSignal.asReadonly();
  estat$ = this.estatSignal.asReadonly();
  carregarElements(): void {
    this.estatSignal.update(e => ({ ...e, carregant: true, error: null }));
    this.http.get<ElementAPI[]>('http://localhost:4301/elements')
      .pipe(
        map(dades => dades.map(adaptarElementAPI)),
        catchError(error => {
          this.estatSignal.update(e => ({
            carregant: false,
            error: 'No s\'han pogut carregar els elements'
          }));
          return of([]);
        })
      )
      .subscribe(elements => {
        this.elementsSignal.set(elements);
        this.estatSignal.update(e => ({ ...e, carregant: false }));
      });
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_352 %}
    {% capture code_353 %}// cataleg-page.component.ts - Component contenidor
@Component({
  selector: 'app-cataleg-page',
  standalone: true,
  imports: [LlistaElementsComponent, CommonModule],
  templateUrl: './cataleg-page.component.html'
})
export class CatalegPageComponent implements OnInit {
  private readonly elementService = inject(ElementService);
  // Computed derivats automàticament dels signals
  elements = computed(() => this.elementService.elements$());
  estatServei = computed(() => this.elementService.estat$());
  ngOnInit(): void {
    this.elementService.carregarElements();
  }
  reintentar(): void {
    this.elementService.reintentar();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_353 %}
    {% capture code_354 %}<!-- cataleg-page.component.html -->
<section *ngIf="estatServei().carregant" class="estat">
  Carregant catàleg...
</section>
<section *ngIf="estatServei().error as missatge" class="error" role="alert">
  <p>{{ missatge }}</p>
  <button type="button" (click)="reintentar()">Tornar-ho a provar</button>
</section>
<app-llista-elements [elements]="elements()"></app-llista-elements>{% endcapture %}
    {% include code-block.html lang="html" code=code_354 %}
    <p><strong>Avantatges específics:</strong></p>
    <ul>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> <strong>Lògica centralitzada:</strong> Servei únic gestiona dades. Components consumeixen signals sense duplicar lògica. 10 components = 1 servei + 10 consumidors simples.</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> <strong>Sincronització automàtica:</strong> Actualitzeu <code>elementsSignal.set([...])</code>, tots els components subscriptors actualitzen DOM immediatament. Zero codi de notificació manual.</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> <strong>Neteja automàtica:</strong> Signals no requereixen desubscripció. Angular gestiona automàticament el cicle de vida. Adéu fuites de memòria.</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> <strong>Testing senzill:</strong> Proveu servei amb signals mockejats. Components proven que consumeixen signals correctament. Tests unitaris ràpids i desacoblats.</li>
      <li><i class="bi bi-check-circle-fill" aria-hidden="true"></i> <strong>Change detection optimitzada:</strong> Signals integrats amb detecció de canvis. Angular actualitza només zones afectades. Rendiment superior.</li>
    </ul>
    <h4>3.2.4. Exemple real complet</h4>
    <p><strong>Situació:</strong> Catàleg amb 100 elements, filtre per categoria, botó de recàrrega.</p>
    <p><strong>Sense reactivitat (codi duplicat):</strong></p>
    {% capture code_355 %}// llista-elements.component.ts
export class LlistaElementsComponent {
  elements: Element[] = [];
  carregant = false;
  constructor(private http: HttpClient) {}
  ngOnInit(): void {
    this.carregarElements(); // Duplicat 1
  }
  carregarElements(): void {
    this.carregant = true;
    this.http.get<Element[]>('...').subscribe(/* 15 línies */);
  }
}
// filtre-elements.component.ts
export class FiltreElementsComponent {
  elements: Element[] = [];
  carregant = false;
  constructor(private http: HttpClient) {}
  ngOnInit(): void {
    this.carregarElements(); // Duplicat 2
  }
  carregarElements(): void {
    this.carregant = true;
    this.http.get<Element[]>('...').subscribe(/* 15 línies */);
  }
}
// detall-element.component.ts
export class DetallElementComponent {
  elements: Element[] = [];
  carregant = false;
  constructor(private http: HttpClient) {}
  ngOnInit(): void {
    this.carregarElements(); // Duplicat 3
  }
  carregarElements(): void {
    this.carregant = true;
    this.http.get<Element[]>('...').subscribe(/* 15 línies */);
  }
}
// 3 components × 20 línies = 60 línies de codi duplicat
// Canviar URL API = modificar 3 fitxers
// Afegir gestió d'errors = modificar 3 fitxers{% endcapture %}
    {% include code-block.html lang="typescript" code=code_355 %}
    <p><strong>Amb reactivitat (servei centralitzat):</strong></p>
    {% capture code_356 %}// element.service.ts - 30 línies
@Injectable({ providedIn: 'root' })
export class ElementService {
  private elementsSignal = signal<Element[]>([]);
  elements$ = this.elementsSignal.asReadonly();
  carregarElements(): void {
    this.http.get<Element[]>('...')
      .subscribe(elements => this.elementsSignal.set(elements));
  }
}
// llista-elements.component.ts - 5 línies
export class LlistaElementsComponent {
  private service = inject(ElementService);
  elements = computed(() => this.service.elements$());
  ngOnInit(): void { this.service.carregarElements(); }
}
// filtre-elements.component.ts - 5 línies
export class FiltreElementsComponent {
  private service = inject(ElementService);
  elements = computed(() => this.service.elements$());
}
// detall-element.component.ts - 5 línies
export class DetallElementComponent {
  private service = inject(ElementService);
  elements = computed(() => this.service.elements$());
}
// Total: 30 + 3×5 = 45 línies vs 60 línies
// Canviar URL API = modificar 1 fitxer
// Afegir gestió d'errors = modificar 1 fitxer
// Actualització automàtica en tots 3 components{% endcapture %}
    {% include code-block.html lang="typescript" code=code_356 %}
    <h4>3.2.5. Comparativa visual</h4>
    <table>
      <thead>
        <tr>
          <th>Aspecte</th>
          <th>Sense reactivitat</th>
          <th>Amb reactivitat (signals)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Lògica de càrrega</strong></td>
          <td>Duplicada a cada component</td>
          <td>Centralitzada al servei</td>
        </tr>
        <tr>
          <td><strong>Sincronització</strong></td>
          <td>Manual amb notificacions</td>
          <td>Automàtica amb signals</td>
        </tr>
        <tr>
          <td><strong>Línies de codi</strong></td>
          <td>20-30 per component</td>
          <td>5-10 per component</td>
        </tr>
        <tr>
          <td><strong>Gestió subscripcions</strong></td>
          <td>Manual amb ngOnDestroy</td>
          <td>Automàtica (Angular gestiona)</td>
        </tr>
        <tr>
          <td><strong>Change detection</strong></td>
          <td>Invocació manual o inconsistent</td>
          <td>Optimitzada amb signals</td>
        </tr>
        <tr>
          <td><strong>Testing</strong></td>
          <td>Mock HttpClient a cada test</td>
          <td>Mock signals al servei</td>
        </tr>
        <tr>
          <td><strong>Mantenibilitat</strong></td>
          <td>Baixa (canvis a múltiples fitxers)</td>
          <td>Alta (canvis al servei)</td>
        </tr>
        <tr>
          <td><strong>Fuites memòria</strong></td>
          <td>Risc alt (oblid desubscriure)</td>
          <td>Risc zero (neteja automàtica)</td>
        </tr>
      </tbody>
    </table>
    <h4>3.2.6. Conceptes clau</h4>
    <table>
      <thead>
        <tr>
          <th>Concepte</th>
          <th>Definició</th>
          <th>Sintaxi</th>
          <th>Quan usar</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Signal</strong></td>
          <td>Contenidor reactiu amb detecció automàtica de canvis</td>
          <td><code>signal&lt;T&gt;(valor)</code></td>
          <td>Dades sincronitzades entre servei-component</td>
        </tr>
        <tr>
          <td><strong>Computed</strong></td>
          <td>Signal derivat calculat automàticament</td>
          <td><code>computed(() =&gt; signal())</code></td>
          <td>Transformar o combinar signals</td>
        </tr>
        <tr>
          <td><strong>ReadonlySignal</strong></td>
          <td>Signal de només lectura per encapsulació</td>
          <td><code>signal.asReadonly()</code></td>
          <td>Exposar dades des de serveis</td>
        </tr>
        <tr>
          <td><strong>Effect</strong></td>
          <td>Callback que s'executa quan canvia signal</td>
          <td><code>effect(() =&gt; { ... })</code></td>
          <td>Reaccionar a canvis (logging, analytics)</td>
        </tr>
        <tr>
          <td><strong>Observable</strong></td>
          <td>Flux asíncron amb subscripció manual</td>
          <td><code>Observable&lt;T&gt;</code></td>
          <td>Peticions HTTP, events, streams</td>
        </tr>
      </tbody>
    </table>
    <h4>3.2.7. Patró contenidor/presentació</h4>
    <p><strong>Component contenidor (smart component):</strong></p>
    <ul>
      <li>Injecta serveis</li>
      <li>Gestiona estat i dades</li>
      <li>Orquestra lògica de negoci</li>
      <li>Passa dades a components fills</li>
    </ul>
    <p><strong>Component presentació (dumb component):</strong></p>
    <ul>
      <li>Rep dades via <code>@Input()</code></li>
      <li>Emet events via <code>@Output()</code></li>
      <li>Només visualització</li>
      <li>Sense lògica de negoci</li>
    </ul>
    <p><strong>Beneficis:</strong></p>
    <ul>
      <li>Reutilització: components presentació usables a múltiples contextos</li>
      <li>Testing: components presentació fàcils de provar (inputs fixos)</li>
      <li>Mantenibilitat: lògica centralitzada a contenidors</li>
    </ul>
    <h4>3.2.8. Characteristics principals</h4>
    <p><strong>Reactivitat sincrònica</strong></p>
    <p>Signals emeten canvis sincrònament. Quan actualitzeu <code>elementsSignal.set([...])</code>, tots els consumers (<code>computed</code>, templates) s'actualitzen immediatament dins el mateix tick de detecció de canvis. Predictible i depurable.</p>
    <p><strong>Encapsulació de dades</strong></p>
    <p>Serveis exposen <code>ReadonlySignal</code> via <code>asReadonly()</code>. Components consumidors no poden modificar dades directament. Única font de veritat al servei. Integritat de dades garantida.</p>
    <p><strong>Composició de signals</strong></p>
    <p>Podeu derivar nous signals amb <code>computed()</code> combinant múltiples signals. Exemple: <code>elementsFiltrats = computed(() =&gt; this.elements$().filter(e =&gt; e.categoria === this.filtre()))</code>. Actualització automàtica quan canvia qualsevol signal dependent.</p>
    <p><strong>Interoperabilitat amb RxJS</strong></p>
    <p>Signals coexisteixen amb observables. Useu <code>toObservable()</code> per convertir signal a observable, i <code>toSignal()</code> per convertir observable a signal. Millor de tots dos mons.</p>
    <h4>3.2.9. Integració amb el flux de treball</h4>
    <p>La integració reactiva s'integra amb:</p>
    <ul>
      <li><strong>HttpClient:</strong> Peticions asíncrones consumides per serveis reactius</li>
      <li><strong>Routing:</strong> Components carregats dinàmicament consumeixen signals</li>
      <li><strong>Forms:</strong> Validacions reactives amb signals de formularis</li>
      <li><strong>State management:</strong> Signals com a base per gestió d'estat global</li>
    </ul>
    <p>En les pròximes lectures aprendreu:</p>
    <ul>
      <li>Formularis reactius amb validacions</li>
      <li>Routing avançat amb resolvers</li>
      <li>Testing de components reactius</li>
      <li>Gestió d'estat amb signals globals</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="3.2" titol="Marc conceptual" contingut=section_point_3_2 %}

  {% capture section_point_3_3 %}
    <h4>3.3.1. Flux de dades reactiu</h4>
    {% capture code_357 %}API Externa
  ↓ HttpClient
Servei (ElementService)
  ↓ signals (elementsSignal, estatSignal)
ReadonlySignals exposats
  ↓ inject() al component
Component contenidor (CatalegPageComponent)
  ↓ computed() deriva signals
Template Angular
  ↓ interpolació {% raw %}{{ }}{% endraw %} i directives
DOM del navegador
  ↓ change detection automàtica
Usuari veu interfície actualitzada{% endcapture %}
    {% include code-block.html lang="text" code=code_357 %}
    <h4>3.3.2. Relació entre signals i computed</h4>
    {% capture code_358 %}signal<T>(valor)           →  Font de dades mutable
  ↓ .set() o .update()
signal.asReadonly()        →  Exposició encapsulada
  ↓ inject() al component
computed(() => signal())   →  Derivació automàtica
  ↓ {% raw %}{{ computed() }}{% endraw %}
Template actualitzat       →  Visualització reactiva{% endcapture %}
    {% include code-block.html lang="text" code=code_358 %}
    <p><strong>Regla mnemotècnica:</strong></p>
    <ul>
      <li><code>signal()</code> = caixa amb valor que pots canviar</li>
      <li><code>computed()</code> = fórmula que recalcula quan canvien signals</li>
      <li><code>asReadonly()</code> = finestra per veure sense tocar</li>
    </ul>
    <h4>3.3.3. Patró contenidor/presentació</h4>
    {% capture code_359 %}Component contenidor (smart)
  - Injecta ElementService
  - Gestiona elements$ i estat$
  - Orquestra càrrega/reintentar
  ↓ passa dades via [input]
Component presentació (dumb)
  - Rep @Input() elements
  - Emet @Output() events
  - Només visualitza
  - Reutilitzable{% endcapture %}
    {% include code-block.html lang="text" code=code_359 %}
    <p><strong>Error comú a evitar:</strong></p>
    <p><i class="bi bi-x-circle" aria-hidden="true"></i> Injectar servei directament a component presentació → perd reutilització</p>
    <p><i class="bi bi-check-circle" aria-hidden="true"></i> Passar dades via <code>@Input()</code> → component independent del servei</p>
  {% endcapture %}
  {% include section-point.html numero="3.3" titol="Model mental" contingut=section_point_3_3 %}

  {% capture section_point_3_4 %}
    <h4>3.4.1. Objectiu</h4>
    <p>Entendre les diferències entre signals i observables, i quan usar cada tecnologia.</p>
    <h4>3.4.2. Signals (Angular 16+)</h4>
    <ul>
      <li>Reactivitat sincrònica</li>
      <li>Integració nativa amb change detection</li>
      <li>Sense necessitat de desubscripció</li>
      <li>API simple: <code>set()</code>, <code>update()</code>, <code>computed()</code></li>
    </ul>
    {% capture code_360 %}const contador = signal(0);
contador.set(10);              // Assignar valor
contador.update(n => n + 1);   // Incrementar
const doble = computed(() => contador() * 2); // Derivat{% endcapture %}
    {% include code-block.html lang="typescript" code=code_360 %}
    <h4>3.4.3. Observables (RxJS)</h4>
    <ul>
      <li>Reactivitat asíncrona</li>
      <li>Fluxos d'esdeveniments complexos</li>
      <li>Requereix subscripció/desubscripció</li>
      <li>Operadors potents: <code>map</code>, <code>filter</code>, <code>debounceTime</code>, etc.</li>
    </ul>
    {% capture code_361 %}const elements$ = this.http.get<Element[]>('...');
elements$.pipe(
  map(dades => adaptarDades(dades)),
  catchError(err => of([]))
).subscribe(elements => console.log(elements));{% endcapture %}
    {% include code-block.html lang="typescript" code=code_361 %}
    <h4>3.4.4. Quan usar signals</h4>
    <ul>
      <li>Dades sincronitzades entre servei-component</li>
      <li>Estat local del component</li>
      <li>Propietats calculades simples</li>
      <li>Integració amb templates Angular</li>
    </ul>
    <h4>3.4.5. Quan usar observables</h4>
    <ul>
      <li>Peticions HTTP asíncrones</li>
      <li>Gestió d'esdeveniments de formularis</li>
      <li>WebSockets i streams de dades</li>
      <li>Composició complexa amb operadors RxJS</li>
    </ul>
    <h4>3.4.6. Combinació recomanada</h4>
    {% capture code_362 %}// Servei: Observables per HTTP, signals per exposar dades
carregarElements(): void {
  this.http.get<Element[]>('...')  // Observable
    .subscribe(elements =>
      this.elementsSignal.set(elements)  // Signal
    );
}
// Component: Computed per derivar signals
elements = computed(() => this.service.elements$());{% endcapture %}
    {% include code-block.html lang="typescript" code=code_362 %}
    <p><strong>Clau:</strong> Signals per sincronització component-servei, observables per operacions asíncrones. Complementaris, no excloents.</p>
    <h4>3.4.7. Resultat esperat</h4>
    <p>Compreneu que signals simplifiquen reactivitat sincrònica mentre observables gestionen asincronisme complex.</p>
  {% endcapture %}
  {% include section-point.html numero="3.4" titol="Conceptes de reactivitat: signals vs observables" contingut=section_point_3_4 %}

  {% capture section_point_3_5 %}
    <h4>3.5.1. Objectiu</h4>
    <p>Configurar el servei per exposar dades com a <code>ReadonlySignal</code>, garantint encapsulació.</p>
    <h4>3.5.2. Estructura del servei</h4>
    {% capture code_363 %}// src/app/serveis/element.service.ts
import { Injectable, signal, computed } from '@angular/core';
import { HttpClient } from '@angular/common/http';
@Injectable({ providedIn: 'root' })
export class ElementService {
  private readonly http = inject(HttpClient);
  // Signals privats (mutables)
  private elementsSignal = signal<ElementCataleg[]>([]);
  private estatSignal = signal<EstatPeticio>({
    carregant: false,
    error: null
  });
  // Exposició pública (readonly)
  elements$ = this.elementsSignal.asReadonly();
  estat$ = this.estatSignal.asReadonly();
  carregarElements(): void {
    this.estatSignal.update(e => ({ ...e, carregant: true, error: null }));
    this.http.get<ElementAPI[]>('http://localhost:4301/elements')
      .pipe(
        map(dades => dades.map(adaptarElementAPI)),
        catchError(error => {
          this.estatSignal.update(e => ({
            carregant: false,
            error: 'No s\'han pogut carregar els elements'
          }));
          return of([]);
        })
      )
      .subscribe(elements => {
        this.elementsSignal.set(elements);
        this.estatSignal.update(e => ({ ...e, carregant: false }));
      });
  }
  reintentar(): void {
    this.carregarElements();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_363 %}
    <h4>3.5.3. Beneficis de ReadonlySignal</h4>
    <ul>
      <li>Components no poden modificar dades directament: <code>service.elements$().push(nou)</code> <i class="bi bi-x-circle" aria-hidden="true"></i> Error de compilació</li>
      <li>Única font de veritat: només el servei modifica signals</li>
      <li>API clara: <code>elements$()</code> retorna dades, no permet mutació</li>
    </ul>
    <h4>3.5.4. Effect opcional per logging</h4>
    {% capture code_364 %}constructor() {
  effect(() => {
    const estat = this.estat$();
    if (estat.error) {
      console.warn('[ElementService] Error:', estat.error);
    }
  });
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_364 %}
    <p><strong>Clau:</strong> Exposar signals com a <code>ReadonlySignal</code> via <code>asReadonly()</code> garanteix encapsulació i integritat de dades.</p>
    <h4>3.5.5. Resultat esperat</h4>
    <p>Servei exposa <code>elements$()</code> i <code>estat$()</code> com a ReadonlySignals consumibles per components.</p>
  {% endcapture %}
  {% include section-point.html numero="3.5" titol="Exposar signals des del servei" contingut=section_point_3_5 %}

  {% capture section_point_3_6 %}
    <h4>3.6.1. Objectiu</h4>
    <p>Generar un component contenidor que consumeixi el servei i orquestri la càrrega de dades.</p>
    <h4>3.6.2. Generar component</h4>
    {% capture code_365 %}ng generate component pages/cataleg-page --standalone --inline-style=false --inline-template=false{% endcapture %}
    {% include code-block.html lang="bash" code=code_365 %}
    <h4>3.6.3. Implementació del component</h4>
    {% capture code_366 %}// src/app/pages/cataleg-page/cataleg-page.component.ts
import { Component, OnInit, computed, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ElementService } from '../../serveis/element.service';
import { ElementCataleg } from '../../models/element.model';
import { LlistaElementsComponent } from '../../components/llista-elements/llista-elements.component';
@Component({
  selector: 'app-cataleg-page',
  standalone: true,
  imports: [CommonModule, LlistaElementsComponent],
  templateUrl: './cataleg-page.component.html',
  styleUrls: ['./cataleg-page.component.scss']
})
export class CatalegPageComponent implements OnInit {
  private readonly elementService = inject(ElementService);
  // Computed signals derivats del servei
  elements = computed<ElementCataleg[]>(() => this.elementService.elements$());
  estatServei = computed(() => this.elementService.estat$());
  ngOnInit(): void {
    // Carregar elements en inicialitzar component
    this.elementService.carregarElements();
  }
  reintentar(): void {
    this.elementService.reintentar();
  }
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_366 %}
    <h4>3.6.4. Per què computed()</h4>
    <ul>
      <li>Derivació automàtica: quan canvia <code>elements$()</code> al servei, <code>elements</code> al component s'actualitza automàticament</li>
      <li>Avaluació lazy: només recalcula quan es llegeix el valor</li>
      <li>Integració amb change detection: Angular detecta canvis eficientment</li>
    </ul>
    <h4>3.6.5. Alternativa sense computed (no recomanada)</h4>
    {% capture code_367 %}// NO fer això
get elements() {
  return this.elementService.elements$();
}
// Funciona però perd beneficis de signals (change detection optimitzada){% endcapture %}
    {% include code-block.html lang="typescript" code=code_367 %}
    <p><strong>Clau:</strong> Component contenidor injecta servei, deriva signals amb <code>computed()</code> i orquestra càrrega de dades.</p>
    <h4>3.6.6. Resultat esperat</h4>
    <p>Component <code>CatalegPageComponent</code> creat i connectat al servei mitjançant signals.</p>
  {% endcapture %}
  {% include section-point.html numero="3.6" titol="Crear component contenidor" contingut=section_point_3_6 %}

  {% capture section_point_3_7 %}
    <h4>3.7.1. Objectiu</h4>
    <p>Crear la plantilla HTML que consumeixi els computed signals i mostri estats dinàmicament.</p>
    <h4>3.7.2. Plantilla completa</h4>
    {% capture code_368 %}<!-- src/app/pages/cataleg-page/cataleg-page.component.html -->
<section class="cataleg-container">
<!-- Estat de càrrega -->
<section *ngIf="estatServei().carregant" class="estat-carregant">
<div class="spinner"></div>
<p>Carregant catàleg d'elements...</p>
</section>
<!-- Estat d'error -->
<section *ngIf="estatServei().error as missatgeError" class="estat-error" role="alert">
<svg class="icona-error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
<path d="M12 2L1 21h22L12 2zm0 3.5L20.5 19h-17L12 5.5zM11 10v4h2v-4h-2zm0 6v2h2v-2h-2z"/>
</svg>
<p>{{ missatgeError }}</p>
<button type="button" (click)="reintentar()" class="boto-reintentar">
Tornar-ho a provar
</button>
</section>
<!-- Contingut principal: llista d'elements -->
<app-llista-elements
*ngIf="!estatServei().carregant && !estatServei().error"
[elements]="elements()">
</app-llista-elements>
</section>{% endcapture %}
    {% include code-block.html lang="html" code=code_368 %}
    <h4>3.7.3. Estils bàsics (opcional)</h4>
    {% capture code_369 %}// src/app/pages/cataleg-page/cataleg-page.component.scss
.cataleg-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
}
.estat-carregant {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  padding: 3rem;
  .spinner {
    width: 3rem;
    height: 3rem;
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-top-color: #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
}
.estat-error {
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  padding: 2rem;
  text-align: center;
  .icona-error {
    width: 4rem;
    height: 4rem;
    fill: #c33;
    margin-bottom: 1rem;
  }
  .boto-reintentar {
    margin-top: 1rem;
    padding: 0.5rem 1.5rem;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    &:hover {
      background: #2980b9;
    }
  }
}
@keyframes spin {
  to { transform: rotate(360deg); }
}{% endcapture %}
    {% include code-block.html lang="scss" code=code_369 %}
    <h4>3.7.4. Reactivitat automàtica</h4>
    <p>Quan <code>estatServei()</code> canvia al servei (de <code>carregant: true</code> a <code>carregant: false</code>), Angular actualitza automàticament la plantilla:</p>
    <ul>
      <li>Amaga spinner</li>
      <li>Mostra llista d'elements</li>
      <li>Tot sense codi manual de detecció de canvis</li>
    </ul>
    <p><strong>Clau:</strong> Plantilla consumeix computed signals amb <code>estatServei()</code> i <code>elements()</code>, actualitzant-se automàticament.</p>
    <h4>3.7.5. Resultat esperat</h4>
    <p>Plantilla reactiva que mostra spinner durant càrrega, missatge d'error si falla, i llista d'elements quan carrega correctament.</p>
  {% endcapture %}
  {% include section-point.html numero="3.7" titol="Configurar plantilla reactiva amb computed" contingut=section_point_3_7 %}

  <!-- Punt 3.8: Gestionar estats de càrrega i error -->
  {% capture section_point_3_8 %}
    <h4>3.8.1. Objectiu</h4>
    <p>Implementar gestió robusta d'estats amb reintentos i missatges informatius per millorar l'experiència d'usuari.</p>
    <h4>3.8.2. Tipus d'estat</h4>
    <p>Definim una interfície per gestionar l'estat de les peticions HTTP:</p>
    {% capture code_370 %}// src/app/models/estat-peticio.model.ts
export interface EstatPeticio {
  carregant: boolean;
  error: string | null;
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_370 %}
    <p>Aquesta interfície centralitza els estats possibles: càrrega activa (<code>carregant</code>) i missatge d'error opcional (<code>error</code>).</p>
    <h4>3.8.3. Gestió d'estat al servei</h4>
    <p>El servei actualitza el signal d'estat en cada fase de la petició HTTP:</p>
    {% capture code_371 %}private estatSignal = signal<EstatPeticio>({
  carregant: false,
  error: null
});

carregarElements(): void {
  // Estat inicial: carregant
  this.estatSignal.update(e => ({ ...e, carregant: true, error: null }));

  this.http.get<ElementAPI[]>('http://localhost:4301/elements')
    .pipe(
      timeout(5000), // Timeout de 5 segons
      map(dades => dades.map(adaptarElementAPI)),
      catchError(error => {
        // Estat d'error: missatge informatiu
        let missatge = 'No s\'han pogut carregar els elements';

        if (error.name === 'TimeoutError') {
          missatge = 'Temps d\'espera esgotat. Comproveu la connexió.';
        } else if (error.status === 404) {
          missatge = 'Endpoint no trobat. Verificar URL de l\'API.';
        } else if (error.status === 500) {
          missatge = 'Error del servidor. Intentar-ho més tard.';
        }

        this.estatSignal.update(e => ({
          carregant: false,
          error: missatge
        }));

        return of([]); // Retornar array buit
      })
    )
    .subscribe(elements => {
      // Estat d'èxit: dades carregades
      this.elementsSignal.set(elements);
      this.estatSignal.update(e => ({ ...e, carregant: false }));
    });
}

reintentar(): void {
  this.carregarElements();
}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_371 %}
    <p><strong>Gestió d'errors diferenciada:</strong></p>
    <ul>
      <li><code>TimeoutError</code>: Temps d'espera esgotat, suggereix problemes de connexió</li>
      <li><code>404</code>: Endpoint no trobat, verificar URL de l'API</li>
      <li><code>500</code>: Error del servidor, intentar més tard</li>
      <li>Per defecte: Missatge genèric informatiu</li>
    </ul>
    <p>El mètode <code>reintentar()</code> permet a l'usuari repetir la petició després d'un error.</p>
    <h4>3.8.4. Plantilla amb gestió d'estats</h4>
    <p>La plantilla accedeix directament a les propietats de l'objecte estat:</p>
    {% capture code_372 %}<section *ngIf="estatServei().carregant">
  Carregant...
</section>

<section *ngIf="estatServei().error as missatge">
  <p>{% raw %}{{ missatge }}{% endraw %}</p>
  <button (click)="reintentar()">Reintentar</button>
</section>

<app-llista-elements
  *ngIf="!estatServei().carregant && !estatServei().error"
  [elements]="elements()">
</app-llista-elements>{% endcapture %}
    {% include code-block.html lang="html" code=code_372 %}
    <p>Utilitzem <code>*ngIf="estatServei().error as missatge"</code> per capturar el missatge i mostrar-lo només si existeix.</p>
    <h4>3.8.5. Patrons d'estat comuns</h4>
    <p>Taula de transicions d'estat durant el cicle de vida d'una petició:</p>
    <div class="table-responsive"><table class="table table-bordered"><thead><tr><th>Situació</th><th><code>carregant</code></th><th><code>error</code></th><th>Acció UI</th></tr></thead><tbody><tr><td>Inicial</td><td><code>false</code></td><td><code>null</code></td><td>Cridar <code>carregarElements()</code></td></tr><tr><td>Carregant</td><td><code>true</code></td><td><code>null</code></td><td>Mostrar spinner</td></tr><tr><td>Èxit</td><td><code>false</code></td><td><code>null</code></td><td>Mostrar dades</td></tr><tr><td>Error</td><td><code>false</code></td><td><code>"missatge"</code></td><td>Mostrar error + botó reintentar</td></tr></tbody></table></div>
    <p><strong>Clau:</strong> Signal d'estat centralitzat permet gestionar càrrega, èxit i error de forma consistent i reactiva.</p>
    <h4>3.8.6. Resultat esperat</h4>
    <p>Interfície que mostra estats clarament (spinner, missatges d'error específics) i permet reintentar peticions fallides amb un clic.</p>
  {% endcapture %}
  {% include section-point.html numero="3.8" titol="Gestionar estats de càrrega i error" contingut=section_point_3_8 %}

  <!-- Punt 3.9: Integrar component amb rutes -->
  {% capture section_point_3_9 %}
    <h4>3.9.1. Objectiu</h4>
    <p>Configurar el router d'Angular per carregar el component contenidor com a pàgina independent amb URL dedicada.</p>
    <h4>3.9.2. Configuració de rutes</h4>
    <p>Definim les rutes de l'aplicació al fitxer de configuració:</p>
    {% capture code_373 %}// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { CatalegPageComponent } from './pages/cataleg-page/cataleg-page.component';

export const routes: Routes = [
  { path: '', redirectTo: '/cataleg', pathMatch: 'full' },
  { path: 'cataleg', component: CatalegPageComponent },
  { path: '**', redirectTo: '/cataleg' }
];{% endcapture %}
    {% include code-block.html lang="typescript" code=code_373 %}
    <p><strong>Rutes definides:</strong></p>
    <ul>
      <li>Redirecció de l'arrel (<code>''</code>) cap a <code>/cataleg</code></li>
      <li>Ruta principal <code>/cataleg</code> que carrega <code>CatalegPageComponent</code></li>
      <li>Wildcard (<code>**</code>) per redirigir rutes no trobades a <code>/cataleg</code></li>
    </ul>
    <h4>3.9.3. Actualització del component arrel</h4>
    <p>El component <code>AppComponent</code> integra el <code>RouterOutlet</code> per renderitzar les rutes:</p>
    {% capture code_374 %}// src/app/app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  template: `
    <header>
      <h1>Catàleg d'Elements</h1>
      <nav>
        <a routerLink="/cataleg">Catàleg</a>
      </nav>
    </header>
    <main>
      <router-outlet></router-outlet>
    </main>
  `,
  styles: [`
    header {
      background: #2c3e50;
      color: white;
      padding: 1rem 2rem;

      h1 {
        margin: 0;
        font-size: 1.5rem;
      }

      nav {
        margin-top: 0.5rem;

        a {
          color: #3498db;
          text-decoration: none;

          &:hover {
            text-decoration: underline;
          }
        }
      }
    }

    main {
      padding: 2rem;
    }
  `]
})
export class AppComponent {}{% endcapture %}
    {% include code-block.html lang="typescript" code=code_374 %}
    <p><strong>Elements clau:</strong></p>
    <ul>
      <li>Importem <code>RouterOutlet</code> als imports del component standalone</li>
      <li>Template amb <code>&lt;router-outlet&gt;</code> que renderitza el component actiu</li>
      <li>Navegació amb <code>routerLink="/cataleg"</code> per enllaços declaratius</li>
      <li>Estils inline per a l'header i estructura bàsica</li>
    </ul>
    <h4>3.9.4. Verificació de navegació</h4>
    <p>Passos per comprovar que el routing funciona correctament:</p>
    <ol>
      <li>Executeu <code>ng serve --port 4300</code> per iniciar el servidor de desenvolupament</li>
      <li>Navegueu a <code>http://localhost:4300/cataleg</code> al navegador</li>
      <li>El component <code>CatalegPageComponent</code> es carrega automàticament</li>
      <li>Les dades es carreguen en el hook <code>ngOnInit()</code> del component</li>
    </ol>
    <p><strong>Clau:</strong> Routing permet carregar components contenidors com a pàgines independents amb URLs dedicades.</p>
    <h4>3.9.5. Resultat esperat</h4>
    <p>Aplicació amb routing funcional, pàgina de catàleg accessible via <code>/cataleg</code>, navegació fluida entre rutes.</p>
  {% endcapture %}
  {% include section-point.html numero="3.9" titol="Integrar component amb rutes" contingut=section_point_3_9 %}

  <!-- Punt 3.10: Provar reactivitat i actualitzacions automàtiques -->
  {% capture section_point_3_10 %}
    <h4>3.10.1. Objectiu</h4>
    <p>Verificar que els canvis de dades al servei actualitzen la interfície automàticament gràcies als signals.</p>
    <h4>3.10.2. Test manual amb DevTools</h4>
    <p>Podem provar la reactivitat modificant els signals directament des de la consola del navegador:</p>
    <p><strong>1. Modificar dades des de DevTools:</strong></p>
    {% capture code_375 %}// Obrir DevTools > Console
// Accedir al component via ng.getComponent()
const component = ng.getComponent(document.querySelector('app-cataleg-page'));
const service = component['elementService'];

// Modificar signal manualment
service['elementsSignal'].update(elements => [
  ...elements,
  {
    id: 999,
    nom: 'Element de prova',
    categoria: 'Test',
    preu: 100
  }
]);

// La interfície s'actualitza immediatament sense recarregar{% endcapture %}
    {% include code-block.html lang="javascript" code=code_375 %}
    <p>Observeu com la interfície s'actualitza immediatament sense necessitat de recarregar la pàgina.</p>
    <p><strong>2. Simular un error:</strong></p>
    {% capture code_376 %}service['estatSignal'].set({
  carregant: false,
  error: 'Error de prova manual'
});

// Template mostra immediatament missatge d'error{% endcapture %}
    {% include code-block.html lang="javascript" code=code_376 %}
    <p>La plantilla mostra immediatament el missatge d'error amb el botó de reintentar.</p>
    <p><strong>3. Simular estat de càrrega:</strong></p>
    {% capture code_377 %}service['estatSignal'].set({
  carregant: true,
  error: null
});

// Template mostra spinner immediatament{% endcapture %}
    {% include code-block.html lang="javascript" code=code_377 %}
    <p>El spinner apareix instantàniament a la interfície.</p>
    <h4>3.10.3. Verificacions a realitzar</h4>
    <p>Checklist de proves de reactivitat:</p>
    <ul>
      <li><i class="bi bi-check-square" aria-hidden="true"></i> Afegir element → Llista s'actualitza sense recarregar</li>
      <li><i class="bi bi-check-square" aria-hidden="true"></i> Modificar estat → UI reflecteix canvi instantàniament</li>
      <li><i class="bi bi-check-square" aria-hidden="true"></i> Múltiples components → Tots s'actualitzen simultàniament</li>
      <li><i class="bi bi-check-square" aria-hidden="true"></i> Reintentar després d'error → Càrrega correcta</li>
    </ul>
    <h4>3.10.4. Comparativa amb observables</h4>
    <p>Diferències en gestió de subscripcions:</p>
    {% capture code_378 %}// Amb observables: cal desubscriure manualment
ngOnDestroy(): void {
  this.subscription.unsubscribe(); // Necessari
}

// Amb signals: neteja automàtica
// No cal ngOnDestroy per signals{% endcapture %}
    {% include code-block.html lang="typescript" code=code_378 %}
    <p><strong>Avantatges dels signals:</strong></p>
    <ul>
      <li>No cal gestió manual de subscripcions</li>
      <li>Neteja automàtica quan el component es destrueix</li>
      <li>API més simple i menys propensa a errors</li>
      <li>Integració nativa amb change detection d'Angular</li>
    </ul>
    <p><strong>Clau:</strong> Signals proporcionen actualitzacions automàtiques sense subscripcions manuals ni gestió de cicle de vida.</p>
    <h4>3.10.5. Resultat esperat</h4>
    <p>Comprovació que qualsevol canvi al servei actualitza tots els components consumidors immediatament, sense codi de sincronització manual.</p>
  {% endcapture %}
  {% include section-point.html numero="3.10" titol="Provar reactivitat i actualitzacions automàtiques" contingut=section_point_3_10 %}

  <!-- Punt 3.11: Documentar flux de dades -->
  {% capture section_point_3_11 %}
    <h4>3.11.1. Objectiu</h4>
    <p>Registrar l'arquitectura reactiva al dossier tècnic del projecte per facilitar manteniment i onboarding.</p>
    <h4>3.11.2. Diagrama de flux de dades</h4>
    <p>Actualitzem el fitxer <code>docs/serveis.md</code> amb el diagrama de flux reactiu:</p>
    {% capture code_379 %}## Flux de dades reactiu

### Arquitectura
```
API Externa (json-server:4301)
  ↓ HttpClient.get()
ElementService
  ↓ elementsSignal.set()
ReadonlySignals (elements$, estat$)
  ↓ inject() + computed()
CatalegPageComponent (contenidor)
  ↓ [elements]="elements()"
LlistaElementsComponent (presentació)
  ↓ *ngFor="let element of elements"
DOM del navegador
```{% endcapture %}
    {% include code-block.html lang="markdown" code=code_379 %}
    <h4>3.11.3. Taula de components consumidors</h4>
    <p>Documentem quins components consumeixen signals i quines són les seves responsabilitats:</p>
    <div class="table-responsive"><table class="table table-bordered"><thead><tr><th>Component</th><th>Signals consumits</th><th>Responsabilitat</th></tr></thead><tbody><tr><td><code>CatalegPageComponent</code></td><td><code>elements$()</code>, <code>estat$()</code></td><td>Orquestrar càrrega i distribució</td></tr><tr><td><code>LlistaElementsComponent</code></td><td>Cap (rep via @Input)</td><td>Visualitzar llista</td></tr><tr><td><code>DetallElementComponent</code></td><td>Cap (rep via @Input)</td><td>Mostrar detall individual</td></tr></tbody></table></div>
    <h4>3.11.4. Gestió de subscripcions</h4>
    <p>Documentem les diferències en gestió de subscripcions entre signals i observables:</p>
    {% capture code_380 %}### Gestió de subscripcions

**Signals (Angular 16+):**
- ✅ Neteja automàtica
- ✅ Integració nativa amb change detection
- ✅ No requereix `ngOnDestroy()`

**Observables (quan necessari):**
- ⚠️ Subscripció dins `subscribe()`
- ⚠️ Desubscripció amb `takeUntil()` o `Subscription`
- ⚠️ Neteja manual en `ngOnDestroy()`

**Exemple observable amb neteja:**
```typescript
private destroy$ = new Subject<void>();

ngOnInit(): void {
  this.http.get('...')
    .pipe(takeUntil(this.destroy$))
    .subscribe(dades => { ... });
}

ngOnDestroy(): void {
  this.destroy$.next();
  this.destroy$.complete();
}
```{% endcapture %}
    {% include code-block.html lang="markdown" code=code_380 %}
    <h4>3.11.5. Decisions de disseny</h4>
    <p>Expliquem les decisions arquitectòniques preses:</p>
    {% capture code_381 %}### Decisions de disseny

**Per què signals en lloc d'observables purs:**
- Simplicitat: No cal gestionar subscripcions
- Rendiment: Change detection optimitzada
- Ergonomia: API més simple per estat sincronitzat

**Quan continuar usant observables:**
- Peticions HTTP (asíncrones)
- Operadors RxJS complexos (debounceTime, switchMap)
- Esdeveniments de formularis{% endcapture %}
    {% include code-block.html lang="markdown" code=code_381 %}
    <p><strong>Combinació recomanada:</strong> Observables per asincronisme → <code>subscribe()</code> → signals per sincronització → <code>computed()</code> → template</p>
    <p><strong>Clau:</strong> Documentar flux reactiu facilita manteniment i onboarding de nous desenvolupadors.</p>
    <h4>3.11.6. Resultat esperat</h4>
    <p>Dossier tècnic actualitzat amb diagrama de flux, taula de components, gestió de subscripcions i decisions de disseny documentades.</p>
  {% endcapture %}
  {% include section-point.html numero="3.11" titol="Documentar flux de dades" contingut=section_point_3_11 %}

  <!-- Punt 3.12: Mini exemple pràctic -->
  {% capture section_point_3_12 %}
    <h4>3.12.1. Objectiu</h4>
    <p>Consolidar la integració reactiva completa: servei amb signals, component contenidor, plantilla reactiva.</p>
    <h4>3.12.2. Passos del mini exemple</h4>
    <p><strong>1. Verificar estructura del servei (5'):</strong></p>
    {% capture code_382 %}# Comprovar que ElementService exposa signals
code src/app/serveis/element.service.ts
# Cercar: elements$ = this.elementsSignal.asReadonly();
#        estat$ = this.estatSignal.asReadonly();{% endcapture %}
    {% include code-block.html lang="bash" code=code_382 %}
    <p><strong>2. Crear component contenidor (10'):</strong></p>
    {% capture code_383 %}ng generate component pages/cataleg-page --standalone{% endcapture %}
    {% include code-block.html lang="bash" code=code_383 %}
    <p><strong>3. Implementar lògica reactiva (15'):</strong></p>
    {% capture code_384 %}// Copiar implementació de la secció 6
private readonly elementService = inject(ElementService);
elements = computed(() => this.elementService.elements$());
estatServei = computed(() => this.elementService.estat$());{% endcapture %}
    {% include code-block.html lang="typescript" code=code_384 %}
    <p><strong>4. Configurar plantilla (15'):</strong></p>
    {% capture code_385 %}<!-- Copiar plantilla de la secció 7 -->
<section *ngIf="estatServei().carregant">Carregant...</section>
<section *ngIf="estatServei().error as err">{% raw %}{{ err }}{% endraw %}</section>
<app-llista-elements [elements]="elements()"></app-llista-elements>{% endcapture %}
    {% include code-block.html lang="html" code=code_385 %}
    <p><strong>5. Integrar amb routing (10'):</strong></p>
    {% capture code_386 %}// app.routes.ts
{ path: 'cataleg', component: CatalegPageComponent }{% endcapture %}
    {% include code-block.html lang="typescript" code=code_386 %}
    <p><strong>6. Provar reactivitat (10'):</strong></p>
    {% capture code_387 %}ng serve --port 4300
# Navegar a http://localhost:4300/cataleg
# Verificar que dades carreguen automàticament
# Provar botó reintentar si hi ha error{% endcapture %}
    {% include code-block.html lang="bash" code=code_387 %}
    <p><strong>7. Documentar flux (10'):</strong></p>
    {% capture code_388 %}# Actualitzar docs/serveis.md amb diagrama de flux{% endcapture %}
    {% include code-block.html lang="bash" code=code_388 %}
    <h4>3.12.3. Resultat esperat</h4>
    <p>Aplicació amb integració reactiva completa: servei amb signals, component contenidor consumint signals amb <code>computed()</code>, plantilla actualitzant-se automàticament, routing funcional i documentació actualitzada.</p>
  {% endcapture %}
  {% include section-point.html numero="3.12" titol="Mini exemple pràctic" contingut=section_point_3_12 %}

  <!-- Punt 3.13: Resolució de problemes -->
  {% capture section_point_3_13 %}
    <h4>3.13.1. Objectiu</h4>
    <p>Identificar i resoldre problemes comuns en integració reactiva amb signals i components.</p>
    <h4>3.13.2. Problemes transversals</h4>
    <div class="table-responsive"><table class="table table-bordered"><thead><tr><th>Símptoma</th><th>Possible causa</th><th>Solució ràpida</th></tr></thead><tbody><tr><td>Components sense actualitzar</td><td>No s'utilitza <code>computed</code> correctament</td><td>Verificar sintaxi: <code>computed(() => service.signal$())</code></td></tr><tr><td><code>Cannot read properties of undefined</code></td><td>Accés a propietat abans que dades estiguin disponibles</td><td>Afegir guards al template: <code>*ngIf="elements().length > 0"</code></td></tr><tr><td>Fuites de memòria amb observables</td><td>Subscripció sense desubscriure</td><td>Usar <code>takeUntil()</code> o convertir a signal amb <code>toSignal()</code></td></tr><tr><td>Duplicació de codi entre components</td><td>Components repetint lògica de servei</td><td>Centralitzar al component contenidor, passar dades via <code>@Input()</code></td></tr><tr><td>Errors de change detection</td><td>Modificació directa de signals readonly</td><td>Només modificar signals privats al servei amb <code>.set()</code> o <code>.update()</code></td></tr></tbody></table></div>
    <h4>3.13.3. Errors de configuració</h4>
    <div class="table-responsive"><table class="table table-bordered"><thead><tr><th>Error</th><th>Causa</th><th>Solució</th></tr></thead><tbody><tr><td><code>inject() can only be used in constructor</code></td><td>Cridar <code>inject()</code> fora de constructor</td><td>Moure <code>inject()</code> a nivell de classe o usar constructor</td></tr><tr><td><code>signal is not a function</code></td><td>Import incorrecte de signal</td><td><code>import { signal } from '@angular/core';</code></td></tr><tr><td><code>computed() returned undefined</code></td><td>Funció computed no retorna valor</td><td>Afegir <code>return</code> a la funció</td></tr><tr><td>Component no carrega en ruta</td><td>Ruta mal configurada</td><td>Verificar <code>app.routes.ts</code></td></tr><tr><td><code>asReadonly is not a function</code></td><td>Versió Angular &lt; 16</td><td>Actualitzar Angular: <code>ng update @angular/core @angular/cli</code></td></tr></tbody></table></div>
    <h4>3.13.4. Problemes de dependències</h4>
    <div class="table-responsive"><table class="table table-bordered"><thead><tr><th>Error</th><th>Causa</th><th>Solució</th></tr></thead><tbody><tr><td><code>HttpClient provider missing</code></td><td><code>provideHttpClient()</code> no configurat</td><td>Afegir a <code>app.config.ts</code>: <code>providers: [provideHttpClient()]</code></td></tr><tr><td><code>CommonModule directive not found</code></td><td>CommonModule no importat</td><td>Afegir a imports component: <code>imports: [CommonModule, ...]</code></td></tr><tr><td><code>RouterOutlet not found</code></td><td>RouterOutlet no importat</td><td>Afegir a AppComponent: <code>imports: [RouterOutlet]</code></td></tr><tr><td>TypeScript errors amb signals</td><td>tsconfig massa restrictiu</td><td>Verificar <code>tsconfig.json</code>: <code>"target": "ES2022"</code></td></tr><tr><td>Template no actualitza signals</td><td>Template no invocar signals</td><td>Usar <code>signal()</code> amb parèntesis: <code>{% raw %}{{ elements() }}{% endraw %}</code></td></tr></tbody></table></div>
  {% endcapture %}
  {% include section-point.html numero="3.13" titol="Resolució de problemes" contingut=section_point_3_13 %}

  <!-- Punt 3.14: Prompts d'IA -->
  {% capture section_point_3_14 %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte Angular. <strong>Context:</strong> Estic dissenyant l'arquitectura d'una aplicació Angular amb catàleg d'elements que utilitza signals i observables. <strong>Tasca:</strong> Genera un diagrama del flux de dades complet des de l'API externa fins al DOM del navegador, incloent punts de control (validació, transformació, gestió d'errors) en cada capa: API → HttpClient → Servei → Signals → Component contenidor → Component presentació → Plantilla → DOM. <strong>Format:</strong> Diagrama ASCII amb explicació de cada punt de control." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert RxJS i Angular. <strong>Context:</strong> Tinc components Angular que utilitzen observables i necessito gestionar subscripcions correctament per evitar fuites de memòria. <strong>Tasca:</strong> Explica detalladament tres estratègies diferents per gestionar subscripcions: 1) <code>takeUntil()</code> amb Subject, 2) <code>async</code> pipe al template, i 3) <code>toSignal()</code> per convertir a signals. Per cada estratègia proporciona exemple de codi complet, casos d'ús recomanats, avantatges, inconvenients i impacte en el rendiment. <strong>Format:</strong> Guia comparativa amb taula resum i exemples pràctics." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert Angular Signals. <strong>Context:</strong> Estic migrant una aplicació Angular de observables purs a una arquitectura híbrida amb signals. <strong>Tasca:</strong> Crea una comparativa exhaustiva entre signals i observables a Angular cobrint: diferències conceptuals (push vs pull), sintaxi i API, gestió de subscripcions, integració amb change detection, rendiment, casos d'ús òptims per cada tecnologia, i com combinar-los eficientment (observables per HTTP → signals per estat). <strong>Format:</strong> Taula comparativa amb exemples de codi i patrons de combinació recomanats." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de components Angular. <strong>Context:</strong> Necessito implementar el patró contenidor/presentació (smart/dumb components) en una aplicació real de catàleg d'elements. <strong>Tasca:</strong> Descriu el patró amb un exemple concret i complet que inclogui: definició de component contenidor (<code>CatalegPageComponent</code>) amb lògica de negoci, servei injectat i gestió d'estat; component de presentació (<code>LlistaElementsComponent</code>) amb <code>@Input()</code> i <code>@Output()</code>; flux de dades entre components; i beneficis concrets (reutilització, testing, mantenibilitat). <strong>Format:</strong> Tutorial pas a pas amb codi TypeScript i HTML complet." %}
    {% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en rendiment Angular. <strong>Context:</strong> Vull entendre les millores de rendiment que aporten els signals respecte a la change detection tradicional amb observables. <strong>Tasca:</strong> Genera una taula comparativa detallada entre change detection amb signals (signal-based change detection) vs change detection tradicional amb observables cobrint: mecanisme de detecció de canvis, zones afectades per actualitzacions, necessitat de <code>markForCheck()</code>, impacte en aplicacions grans, overhead de subscripcions, i exemples de rendiment mesurable (temps d'actualització, nombre de cicles de detecció). <strong>Format:</strong> Taula comparativa amb mètriques quantitatives i recomanacions d'ús." %}
  {% endcapture %}
  {% include section-point.html numero="3.14" titol="Prompts d'IA" contingut=section_point_3_14 %}

  <!-- Punt 3.15: Autoavaluació -->
  {% capture section_point_3_15 %}
    <h4>3.15.1. Funcionalitat</h4>
    {% include checklist.html elements="He vist el component <code>CatalegPageComponent</code> carregar dades automàticament en inicialitzar|He comprovat que l'estat de càrrega (spinner) es mostra mentre es carreguen les dades|He verificat que l'estat d'error es mostra correctament amb missatge informatiu i botó reintentar|He confirmat que la llista d'elements es renderitza correctament després de carregar dades" %}
    <h4>3.15.2. Projecte i estructura</h4>
    {% include checklist.html elements="He creat el servei <code>ElementService</code> exposant signals readonly (<code>elements$</code>, <code>estat$</code>)|He organitzat el component contenidor <code>CatalegPageComponent</code> amb <code>computed()</code> derivant signals|He configurat la plantilla amb directives <code>*ngIf</code> gestionant estats dinàmicament|He estructurat el patró contenidor/presentació correctament" %}
    <h4>3.15.3. Control de versions</h4>
    {% include checklist.html elements="He inicialitzat/actualitzat repositori Git local amb els canvis|He fet commit amb missatge descriptiu: \"feat: afegir integració reactiva amb signals\"|He publicat a GitHub si correspon" %}
    <h4>3.15.4. Eines</h4>
    {% include checklist.html elements="He verificat <code>ng serve</code> operatiu amb component contenidor carregant dades|He comprovat routing funcional amb ruta <code>/cataleg</code> accessible|He validat que signals actualitzen interfície automàticament sense recarregar pàgina" %}
    <h4>3.15.5. Documentació</h4>
    {% include checklist.html elements="He actualitzat <code>docs/serveis.md</code> amb diagrama de flux reactiu|He documentat components consumidors i signals utilitzats|He registrat decisions de disseny (per què signals, quan observables)" %}
    <h4>3.15.6. Reactivitat amb signals</h4>
    {% include checklist.html elements="Sé crear signals privats i exposar-los com a ReadonlySignal amb <code>asReadonly()</code>|Puc utilitzar <code>computed()</code> per derivar signals automàticament|Entenc la diferència entre signals i observables i quan usar cada tecnologia|Sé combinar observables (HTTP) amb signals (sincronització) eficientment" %}
    <h4>3.15.7. Arquitectura de components</h4>
    {% include checklist.html elements="Sé implementar el patró contenidor/presentació separant lògica de visualització|Puc injectar serveis amb <code>inject()</code> i consumir signals amb <code>computed()</code>|Entenc com passar dades de component contenidor a presentació via <code>@Input()</code>|Sé organitzar components per responsabilitat única" %}
    <h4>3.15.8. Gestió d'estat</h4>
    {% include checklist.html elements="Puc gestionar múltiples estats (càrrega, èxit, error) amb un únic signal|Sé actualitzar signals amb <code>.set()</code> i <code>.update()</code> adequadament|Entenc com encapsular estat al servei i exposar-lo de forma controlada|Puc implementar reintentos de peticions fallides" %}
    <h4>3.15.9. Integració amb Angular</h4>
    {% include checklist.html elements="Sé configurar routing per carregar components contenidors com a pàgines|Puc usar directives estructurals (<code>*ngIf</code>, <code>*ngFor</code>) amb signals|Entenc com funciona change detection amb signals (optimitzada)|Sé integrar HttpClient amb signals per peticions asíncrones" %}
    <h4>3.15.10. Documentació tècnica</h4>
    {% include checklist.html elements="Puc documentar flux de dades amb diagrames ASCII|Sé crear taules de components consumidors i responsabilitats|Entenc com registrar decisions de disseny per futur manteniment|Puc explicar l'arquitectura reactiva a altres desenvolupadors" %}
  {% endcapture %}
  {% include section-point.html numero="3.15" titol="Autoavaluació" contingut=section_point_3_15 %}

  <!-- Punt 3.16: Recapitulació -->
  {% capture section_point_3_16 %}
    <h4>3.16.1. Què hem aconseguit</h4>
    <p>Disposeu d'una <strong>integració reactiva completa</strong> entre servei i components que actualitza la interfície automàticament quan canvien les dades, sense necessitat de codi de sincronització manual.</p>
    <p>El projecte inclou:</p>
    <ol>
      <li><strong>Servei reactiu:</strong> <code>ElementService</code> amb signals privats (<code>elementsSignal</code>, <code>estatSignal</code>) i exposició pública via ReadonlySignals (<code>elements$</code>, <code>estat$</code>). Encapsulació garantida amb única font de veritat.</li>
      <li><strong>Component contenidor:</strong> <code>CatalegPageComponent</code> injectant servei i derivant signals amb <code>computed()</code>. Orquestra càrrega de dades, gestió d'errors i distribució de dades cap a components presentació.</li>
      <li><strong>Plantilla reactiva:</strong> Template amb directives <code>*ngIf</code> gestionant estats (càrrega, error, èxit) i mostrant dades dinàmicament. Actualitzacions automàtiques quan canvien signals.</li>
      <li><strong>Routing funcional:</strong> Ruta <code>/cataleg</code> carregant component contenidor com a pàgina independent. Integració amb navegació d'aplicació.</li>
      <li><strong>Documentació completa:</strong> Flux de dades documentat amb diagrama, taula de components consumidors i decisions de disseny registrades a <code>docs/serveis.md</code>.</li>
    </ol>
    <h4>3.16.2. Què queda preparat per a la Unitat 4</h4>
    <p>A la <strong>Unitat 4 (RA4)</strong> utilitzareu aquesta base reactiva per implementar funcionalitats avançades:</p>
    <ul>
      <li><strong>Formularis reactius:</strong> Creació, edició i eliminació d'elements amb validacions</li>
      <li><strong>Routing avançat:</strong> Resolvers per pre-carregar dades, lazy loading de mòduls</li>
      <li><strong>Gestió d'estat global:</strong> Store amb signals per estat compartit entre múltiples components</li>
      <li><strong>Optimitzacions:</strong> Virtual scrolling per llistes grans, estratègies de caching</li>
    </ul>
    <p>La integració reactiva establerta serveix com a fonament per totes aquestes funcionalitats, garantint sincronització automàtica i rendiment optimitzat.</p>
    <h4>3.16.3. Contracte de sortida</h4>
    <ul>
      <li><i class="bi bi-check-circle-fill text-success" aria-hidden="true"></i> Servei amb signals exposant dades de forma encapsulada</li>
      <li><i class="bi bi-check-circle-fill text-success" aria-hidden="true"></i> Component contenidor consumint signals amb computed</li>
      <li><i class="bi bi-check-circle-fill text-success" aria-hidden="true"></i> Plantilla reactiva amb gestió d'estats dinàmica</li>
      <li><i class="bi bi-check-circle-fill text-success" aria-hidden="true"></i> Routing configurat amb pàgina de catàleg accessible</li>
      <li><i class="bi bi-check-circle-fill text-success" aria-hidden="true"></i> Documentació tècnica del flux de dades completa</li>
    </ul>
    <p><strong>L'arquitectura reactiva està consolidada. Preparats per funcionalitats avançades!</strong></p>
    <h4>3.16.4. Referències ràpides</h4>
    <p><strong>Sintaxi essencial de signals:</strong></p>
    {% capture code_389 %}signal<T>(valor)                    // Crear signal
signal.set(nouValor)                // Assignar valor
signal.update(fn => nouValor)       // Actualitzar amb funció
signal.asReadonly()                 // Exposar readonly
computed(() => signal())            // Derivar signal
effect(() => { /* ... */ })         // Reaccionar a canvis{% endcapture %}
    {% include code-block.html lang="typescript" code=code_389 %}
    <p><strong>Pattern component contenidor:</strong></p>
    {% capture code_390 %}private service = inject(Service);
elements = computed(() => this.service.elements$());{% endcapture %}
    {% include code-block.html lang="typescript" code=code_390 %}
    <p><strong>Template amb signals:</strong></p>
    {% capture code_391 %}<div *ngIf="signal()">{% raw %}{{ signal() }}{% endraw %}</div>
<div *ngFor="let item of signal()">{% raw %}{{ item }}{% endraw %}</div>{% endcapture %}
    {% include code-block.html lang="html" code=code_391 %}
    <p><strong>Troubleshooting ràpid:</strong></p>
    <ul>
      <li>Components no actualitzen → Verificar <code>computed(() => ...)</code> amb parèntesis</li>
      <li>Errors TypeScript amb signals → Invocar signal amb <code>signal()</code> no <code>signal</code></li>
      <li>Change detection no funciona → Comprovar que signals són de <code>@angular/core</code></li>
      <li>Fuites memòria amb observables → Convertir a signal amb <code>toSignal()</code> o usar <code>takeUntil()</code></li>
    </ul>
    <p><strong>Resolució de problemes detallada:</strong> Vegeu secció 3.13</p>
  {% endcapture %}
  {% include section-point.html numero="3.16" titol="Recapitulació" contingut=section_point_3_16 %}

  <!-- Punt 3.17: Repàs de conceptes -->
  {% capture section_point_3_17 %}
    <h4>3.17.1. Conceptes clau</h4>
    <p><strong>Reactivitat en Angular:</strong></p>
    <ul>
      <li>Signals: reactivitat sincrònica amb integració nativa</li>
      <li>Observables: fluxos asíncrons amb operadors RxJS</li>
      <li>Computed: derivació automàtica de signals</li>
      <li>Effect: callbacks reactius a canvis de signals</li>
    </ul>
    <p><strong>Patró contenidor/presentació:</strong></p>
    <ul>
      <li>Contenidor (smart): gestiona dades i lògica de negoci</li>
      <li>Presentació (dumb): només visualitza dades rebudes via <code>@Input()</code></li>
      <li>Beneficis: reutilització, testing, mantenibilitat</li>
    </ul>
    <p><strong>Signals vs observables:</strong></p>
    <ul>
      <li>Signals: estat sincronitzat, sense subscripcions manuals</li>
      <li>Observables: operacions asíncrones complexes, composició amb operadors</li>
      <li>Combinació: observables per HTTP, signals per sincronització</li>
    </ul>
    <p><strong>Flux de dades reactiu:</strong></p>
    <ul>
      <li>API → HttpClient (observable)</li>
      <li>→ Servei (adaptació + signal.set())</li>
      <li>→ Component (computed derivant signal)</li>
      <li>→ Template (interpolació {% raw %}{{ signal() }}{% endraw %})</li>
      <li>→ DOM (change detection automàtica)</li>
    </ul>
    <p><strong>Gestió d'estat:</strong></p>
    <ul>
      <li>Signal privat al servei: <code>elementsSignal = signal&lt;T[]&gt;([])</code></li>
      <li>Exposició pública readonly: <code>elements$ = elementsSignal.asReadonly()</code></li>
      <li>Actualització encapsulada: només servei modifica signals</li>
      <li>Consumició al component: <code>elements = computed(() => service.elements$())</code></li>
    </ul>
    <p><strong>Change detection optimitzada:</strong></p>
    <ul>
      <li>Signals marquen components automàticament per actualització</li>
      <li>Angular actualitza només zones afectades</li>
      <li>Rendiment superior vs change detection tradicional</li>
    </ul>
    <p><strong>Documentació de flux:</strong></p>
    <ul>
      <li>Diagrama visual del flux de dades</li>
      <li>Taula de components consumidors i responsabilitats</li>
      <li>Decisions de disseny (per què signals, quan observables)</li>
      <li>Política de subscripcions i neteja</li>
    </ul>
  {% endcapture %}
  {% include section-point.html numero="3.17" titol="Repàs de conceptes" contingut=section_point_3_17 %}

</div>
