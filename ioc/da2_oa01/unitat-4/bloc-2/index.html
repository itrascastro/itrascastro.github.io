---
layout: bloc
title: "Bloc 2: Arquitectura i patrons"
description: "Gesti√≥ d'estat, modularitzaci√≥ i bones pr√†ctiques arquitect√≤niques"
keywords: "Angular, arquitectura, estat, patrons, modularitzaci√≥"
unitat: 4
bloc: 2
bloc_numero: 2
---

<!--
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  BLOC 2 - UNITAT 4
  Contingut migrat des de:
  - .resources/Autoria/Unitat4/Lli√ßo2/OA1/lectura-u4-l2-oa1.md
  - .resources/Autoria/Unitat4/Lli√ßo2/OA2/lectura-u4-l2-oa2.md
  - .resources/Autoria/Unitat4/Lli√ßo2/OA3/lectura-u4-l2-oa3.md
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-->

<div class="section" id="Unitat4_Bloc2_Seccio1">
  <h2 id="Unitat4_Bloc2_Seccio1">1. Patr√≥ de gesti√≥ d'estat centralitzada</h2>

  <!-- MULTIM√àDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=2 seccio=1 %}


  {% include objectius.html llista="Identificar situacions on m√∫ltiples components necessiten accedir a les mateixes dades compartides|Crear un servei d'estat centralitzat amb observables per gestionar dades globals|Subscriure components a canvis d'estat per rebre actualitzacions autom√†tiques|Aplicar el principi d'immutabilitat per evitar modificacions directes de l'estat" %}

  {% include info_box.html contingut="<strong>RA4 ¬∑ Criteri 4</strong> ‚Äî Optimitza els recursos i genera un paquet llest per a publicaci√≥." %}

  {% capture section_point_1_1 %}
<p>Abans de comen√ßar, necessiteu:</p>
<ul>
<li><strong>Unitat 3 completada:</strong> Heu treballat amb serveis, injecci√≥ de depend√®ncies i comunicaci√≥ amb APIs externes</li>
<li><strong>Conceptes d'observables:</strong> Comprensi√≥ b√†sica de <code>BehaviorSubject</code>, <code>Observable</code> i subscripcions</li>
<li><strong>Comunicaci√≥ entre components:</strong> Coneixeu <code>@Input</code> i <code>@Output</code> per passar dades entre components</li>
<li><strong>Jerarquies de components:</strong> Enteneu relacions pare-fill i germans en l'arbre de components</li>
<li><strong>Projecte funcional:</strong> Teniu una aplicaci√≥ Angular amb m√∫ltiples components creats</li>
</ul>

<p><strong>Verificaci√≥ r√†pida:</strong></p>

{% capture code_1 %}# Verificar que teniu el projecte preparat
ng version
ng serve --open{% endcapture %}
{% include code-block.html lang="bash" code=code_1 %}

<p><strong>Punt d'autocomprovaci√≥:</strong> L'aplicaci√≥ s'obre al navegador i podeu navegar entre components sense errors.</p>
  {% endcapture %}
  {% include section-point.html numero="1.1" titol="Prerequisits" contingut=section_point_1_1 %}

  {% capture section_point_1_2 %}
<h4>1.2.1. Qu√® √©s la gesti√≥ d'estat centralitzada</h4>
<p>La gesti√≥ d'estat centralitzada √©s un patr√≥ arquitect√≤nic on totes les dades globals de l'aplicaci√≥ es guarden en un √∫nic lloc accessible des de qualsevol component. En lloc que cada component mantingui la seva c√≤pia de dades compartides, tots els components consulten i actualitzen un estat central que propaga els canvis autom√†ticament.</p>

<h4>1.2.2. Problema sense gesti√≥ d'estat centralitzada</h4>
<p><strong>Situaci√≥ abans:</strong></p>
<p>Quan diferents components necessiten accedir a les mateixes dades (usuari autenticat, cistella de compra, configuraci√≥ global), cada component mant√© la seva pr√≤pia c√≤pia. Si l'usuari fa login, cal actualitzar manualment cada component.</p>

{% capture code_2 %}src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ header/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ header.component.ts       // T√© el seu propi usuari: User | null
‚îÇ   ‚îú‚îÄ‚îÄ sidebar/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sidebar.component.ts      // Tamb√© t√© el seu propi usuari: User | null
‚îÇ   ‚îú‚îÄ‚îÄ profile/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile.component.ts      // I aquest tamb√©: User | null
‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
‚îÇ       ‚îî‚îÄ‚îÄ dashboard.component.ts    // Un altre m√©s: User | null{% endcapture %}
{% include code-block.html lang="text" code=code_2 %}

<p>Cada component duplica les dades i no sab quan altres components les modifiquen.</p>

<p><strong>Problemes que genera:</strong></p>

<p><strong>1. Inconsist√®ncia de dades</strong></p>
<p>Quan l'usuari fa login al <code>HeaderComponent</code>, altres components no s'assabenten del canvi. El <code>SidebarComponent</code> segueix mostrant "Usuari no autenticat" mentre el <code>HeaderComponent</code> mostra el nom de l'usuari. Aquesta desincronitzaci√≥ crea confusi√≥ i errors.</p>

{% capture code_3 %}// HeaderComponent fa login
this.currentUser = { id: 1, name: 'Anna' };

// Per√≤ SidebarComponent encara t√©:
this.currentUser = null; // PROBLEMA: Desincronitzat!{% endcapture %}
{% include code-block.html lang="typescript" code=code_3 %}

<p><strong>2. Complexitat exponencial en comunicaci√≥</strong></p>
<p>Per mantenir sincronitzats 4 components sobre l'usuari actual, necessiteu 6 connexions <code>@Output</code> i esdeveniments. Amb 10 components s√≥n 45 connexions. La quantitat de cables creix exponencialment: n √ó (n-1) / 2.</p>

<table>
<thead>
<tr>
<th>Components</th>
<th>Connexions necess√†ries</th>
</tr>
</thead>
<tbody>
<tr><td>2</td><td>1</td></tr>
<tr><td>4</td><td>6</td></tr>
<tr><td>8</td><td>28</td></tr>
<tr><td>10</td><td>45</td></tr>
</tbody>
</table>

<p><strong>3. Duplicaci√≥ de l√≤gica i mem√≤ria</strong></p>
<p>Cada component replica la mateixa l√≤gica de gesti√≥ de l'usuari: validaci√≥, actualitzaci√≥, emmagatzematge local. Si cal canviar com es gestiona l'usuari, heu de modificar 10 fitxers diferents. A m√©s, mantenir 10 c√≤pies de l'objecte usuari multiplica el consum de mem√≤ria innecess√†riament.</p>

{% capture code_4 %}// Repetit en 10 components:
updateUser(newUser: User) {
  this.currentUser = newUser;
  localStorage.setItem('user', JSON.stringify(newUser));
  this.validatePermissions();
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_4 %}

<p><strong>4. Dificultat per depurar i fer proves</strong></p>
<p>Quan hi ha un error relacionat amb les dades d'usuari, no sabeu quin component t√© la versi√≥ correcta. Fer proves unit√†ries requereix simular tots els components implicats, no nom√©s el servei central.</p>

<p><strong>5. Acoblament fort entre components</strong></p>
<p>Components que no haurien de con√®ixer-se directament han de comunicar-se amb esdeveniments en cadena. El <code>ProfileComponent</code> ha d'enviar esdeveniments al pare, que els reenvia al <code>HeaderComponent</code>. Modificar un component afecta m√∫ltiples altres.</p>

<h4>1.2.3. Soluci√≥ amb gesti√≥ d'estat centralitzada</h4>
<p>Un servei d'estat centralitzat actua com a font √∫nica de veritat. Tots els components se subscriuen a aquest servei i reben actualitzacions autom√†tiques quan l'estat canvia.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>Consist√®ncia garantida:</strong> Un √∫nic lloc guarda les dades, tots llegeixen el mateix</li>
<li><strong>Simplicitat de comunicaci√≥:</strong> Components no es comuniquen entre ells, nom√©s amb el servei</li>
<li><strong>Mantenibilitat:</strong> La l√≤gica de gesti√≥ est√† centralitzada en un √∫nic fitxer</li>
<li><strong>Facilitat de proves:</strong> Podeu provar el servei a√Ølladament sense components</li>
<li><strong>Desacoblament:</strong> Components no saben que altres components existeixen</li>
</ol>

<h4>1.2.4. Exemple real complet: Sense vs Amb gesti√≥ d'estat</h4>
<p><strong>Situaci√≥:</strong> Una aplicaci√≥ amb header, sidebar i profile. L'usuari fa login i tots tres han de mostrar les dades actualitzades.</p>

<p><strong>Sense gesti√≥ d'estat centralitzada:</strong></p>

{% capture code_5 %}// header.component.ts
export class HeaderComponent {
  @Output() userLoggedIn = new EventEmitter<User>();
  currentUser: User | null = null;

  login(credentials: Credentials) {
    this.authService.login(credentials).subscribe(user => {
      this.currentUser = user;
      this.userLoggedIn.emit(user); // Notificar pare
    });
  }
}

// app.component.ts (pare)
export class AppComponent {
  onUserLoggedIn(user: User) {
    // Propagar a sidebar i profile
    this.sidebarUser = user;
    this.profileUser = user;
  }
}

// sidebar.component.ts
export class SidebarComponent {
  @Input() currentUser: User | null = null;
}

// profile.component.ts
export class ProfileComponent {
  @Input() currentUser: User | null = null;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_5 %}

<p>‚Üí <strong>90 l√≠nies de codi</strong> per gestionar la propagaci√≥ manual entre components.</p>

<p><strong>Amb gesti√≥ d'estat centralitzada:</strong></p>

{% capture code_6 %}// auth-state.service.ts
@Injectable({ providedIn: 'root' })
export class AuthStateService {
  private userSubject = new BehaviorSubject<User | null>(null);
  user$ = this.userSubject.asObservable();

  setUser(user: User | null) {
    this.userSubject.next(user);
  }
}

// header.component.ts
export class HeaderComponent {
  constructor(private authState: AuthStateService) {}

  login(credentials: Credentials) {
    this.authService.login(credentials).subscribe(user => {
      this.authState.setUser(user); // Actualitza estat central
    });
  }
}

// sidebar.component.ts
export class SidebarComponent {
  user$ = this.authState.user$; // Se subscriu autom√†ticament
  constructor(private authState: AuthStateService) {}
}

// profile.component.ts
export class ProfileComponent {
  user$ = this.authState.user$; // Se subscriu autom√†ticament
  constructor(private authState: AuthStateService) {}
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_6 %}

<p>‚Üí <strong>45 l√≠nies de codi</strong>, 50% menys, zero cables entre components.</p>

<h4>1.2.5. Taula comparativa: Abans vs Despr√©s</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Sense estat central</th>
<th>Amb estat central</th>
</tr>
</thead>
<tbody>
<tr><td><strong>L√≠nies de codi</strong></td><td>90+</td><td>45</td></tr>
<tr><td><strong>Connexions @Input/@Output</strong></td><td>6 per 4 components</td><td>0</td></tr>
<tr><td><strong>Lloc de veritat</strong></td><td>M√∫ltiple (cada component)</td><td>√önic (servei)</td></tr>
<tr><td><strong>Temps actualitzaci√≥</strong></td><td>Manual i as√≠ncron</td><td>Autom√†tic i s√≠ncron</td></tr>
<tr><td><strong>Complexitat afegir component</strong></td><td>Creix exponencial</td><td>Constant</td></tr>
<tr><td><strong>Facilitat proves</strong></td><td>Dif√≠cil (molts mocks)</td><td>Senzill (1 servei)</td></tr>
</tbody>
</table>

<h4>1.2.6. Conceptes clau de gesti√≥ d'estat</h4>
<table>
<thead>
<tr>
<th>Concepte</th>
<th>Descripci√≥</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Font √∫nica de veritat</strong></td>
<td>Totes les dades globals estan en un √∫nic lloc</td>
<td>Servei AuthStateService</td>
</tr>
<tr>
<td><strong>Flux unidireccional</strong></td>
<td>Les dades flueixen en una sola direcci√≥: servei ‚Üí components</td>
<td>Components llegeixen, mai modifiquen directament</td>
</tr>
<tr>
<td><strong>Observable</strong></td>
<td>Objecte que emet valors als subscriptors quan canvia</td>
<td><code>user$</code> emet cada cop que l'usuari canvia</td>
</tr>
<tr>
<td><strong>Immutabilitat</strong></td>
<td>No es modifica l'estat directament, es crea un de nou</td>
<td><code>next({ ...oldUser, name: 'Nou' })</code></td>
</tr>
<tr>
<td><strong>Subscripci√≥</strong></td>
<td>Components escolten canvis de l'estat</td>
<td><code>user$.subscribe(u => ...)</code></td>
</tr>
</tbody>
</table>

<h4>1.2.7. Quan usar gesti√≥ d'estat centralitzada</h4>
<p><strong>Casos on √©s recomanable:</strong></p>
<ul>
<li>Dades d'autenticaci√≥ (usuari, token, permisos)</li>
<li>Configuraci√≥ global (idioma, tema, prefer√®ncies)</li>
<li>Cistella de compra o carret</li>
<li>Filtres globals aplicats a m√∫ltiples vistes</li>
<li>Notificacions o missatges d'error globals</li>
</ul>

<p><strong>Casos on NO cal:</strong></p>
<ul>
<li>Dades locals d'un √∫nic component (formulari temporal)</li>
<li>Estats UI ef√≠mers (menu desplegable obert/tancat)</li>
<li>Dades que nom√©s passa un component pare a un fill directe</li>
</ul>

<p><strong>Regla pr√†ctica:</strong> Si m√©s de 3 components necessiten les mateixes dades o si components no relacionats han de compartir informaci√≥, useu gesti√≥ d'estat centralitzada.</p>

<h4>1.2.8. Caracter√≠stiques principals</h4>
<p><strong>1. BehaviorSubject com a contenidor d'estat</strong></p>
<p>El <code>BehaviorSubject</code> √©s un tipus especial d'observable que emmagatzema l'√∫ltim valor em√®s. Quan un nou component se subscriu, rep immediatament el valor actual sense esperar el proper canvi. Aix√≤ garanteix que tots els components tinguin sempre l'estat m√©s recent.</p>

<p><strong>2. Exposici√≥ com a Observable de nom√©s lectura</strong></p>
<p>El servei exposa l'estat com a <code>Observable</code> (<code>user$</code>) per√≤ mant√© el <code>BehaviorSubject</code> privat. Els components poden llegir i subscriure's, per√≤ no poden modificar l'estat directament. Nom√©s el servei pot canviar l'estat mitjan√ßant m√®todes controlats.</p>

<p><strong>3. M√®todes d'actualitzaci√≥ centralitzats</strong></p>
<p>Totes les modificacions de l'estat passen per m√®todes del servei (<code>setUser()</code>, <code>updatePermissions()</code>). Aix√≤ permet validar canvis, executar l√≤gica de negoci, o registrar esdeveniments abans d'actualitzar l'estat.</p>

<p><strong>4. Propagaci√≥ autom√†tica de canvis</strong></p>
<p>Quan l'estat canvia, tots els subscriptors reben la notificaci√≥ autom√†ticament sense codi addicional. No cal implementar mecanismes de notificaci√≥ manual ni cadenes d'esdeveniments.</p>

<p><strong>5. Desacoblament de components</strong></p>
<p>Components no saben que altres components existeixen. Nom√©s coneixen el servei d'estat. Podeu afegir, eliminar o modificar components sense afectar els altres, sempre que mantinguin la interf√≠cie amb el servei.</p>

<h4>1.2.9. Integraci√≥ amb el flux de treball del cat√†leg d'elements</h4>
<p>En el projecte del cat√†leg d'elements, la gesti√≥ d'estat centralitzada √©s √∫til per:</p>
<ul>
<li><strong>Elements seleccionats:</strong> Quan l'usuari selecciona m√∫ltiples elements per comparar o editar, aquesta selecci√≥ √©s accessible des del header (contador), sidebar (llista), i vista de detall (accions).</li>
<li><strong>Filtres actius:</strong> Els filtres aplicats a la llista d'elements (categoria, cerca, ordenaci√≥) es mantenen visibles al header i es poden resetejar des de qualsevol component.</li>
<li><strong>Mode visualitzaci√≥:</strong> Si l'usuari canvia de vista llista a vista graella, tots els components que mostren elements s'actualitzen autom√†ticament sense comunicaci√≥ manual.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="1.2" titol="Marc conceptual" contingut=section_point_1_2 %}

  {% capture section_point_1_3 %}
<p><strong>Emissor de r√†dio central</strong></p>
<p>El servei d'estat √©s com una emissora de r√†dio que emet un programa. Tots els components s√≥n r√†dios que sintonitzen la mateixa freq√º√®ncia. Quan l'emissora canvia el contingut (actualitza l'estat), totes les r√†dios ho escolten simult√†niament sense que s'hagin de comunicar entre elles.</p>

<p><strong>Pissarra compartida</strong></p>
<p>Imagineu una classe amb una pissarra central. Qualsevol alumne (component) pot mirar la pissarra per veure la informaci√≥ actual. Nom√©s el professor (servei d'estat) pot escriure-hi. Quan el professor escriu alguna cosa nova, tots els alumnes ho veuen autom√†ticament sense que calgui cridar-los un per un.</p>
  {% endcapture %}
  {% include section-point.html numero="1.3" titol="Model mental" contingut=section_point_1_3 %}

  {% capture section_point_1_4 %}
<h4>1.4.1. Objectiu</h4>
<p>Comprendre per qu√® sorgeix el problema de l'estat compartit i identificar situacions on m√∫ltiples components necessiten accedir a les mateixes dades.</p>

<p><strong>Escenari real:</strong> Teniu una aplicaci√≥ de comer√ß electr√≤nic amb m√∫ltiples components: un header que mostra el nombre d'articles a la cistella, un sidebar amb el resum de compra, una llista de productes on podeu afegir articles, i una p√†gina de checkout. Tots quatre components necessiten saber quants articles hi ha a la cistella i quins s√≥n.</p>

<h4>1.4.2. Duplicaci√≥ de dades</h4>
<p>Sense un estat centralitzat, cada component mant√© la seva pr√≤pia c√≤pia de la cistella. El <code>HeaderComponent</code> t√© <code>cartItems: Product[] = []</code>, el <code>SidebarComponent</code> t√© la seva pr√≤pia <code>cartItems</code>, i el <code>ProductListComponent</code> tamb√©. Quan afegiu un producte a la cistella des de <code>ProductListComponent</code>, aquest component actualitza la seva cistella local, per√≤ els altres no s'assabenten del canvi.</p>

{% capture code_7 %}// HeaderComponent
cartItems: Product[] = [];
cartCount = 0;

// SidebarComponent
cartItems: Product[] = [];
totalPrice = 0;

// ProductListComponent
cartItems: Product[] = [];{% endcapture %}
{% include code-block.html lang="typescript" code=code_7 %}

<p>‚Üí Tres c√≤pies de les mateixes dades, cadascuna potencialment desincronitzada.</p>

<h4>1.4.3. Comunicaci√≥ manual excessiva</h4>
<p>Per sincronitzar els components, heu de crear una cadena d'esdeveniments. El <code>ProductListComponent</code> emet un esdeveniment <code>@Output() productAdded</code>, el component pare el captura i el propaga al header i al sidebar mitjan√ßant <code>@Input()</code>. Si el sidebar actualitza la quantitat d'un producte, ha d'emetre un altre esdeveniment cap amunt i propagar-lo lateralment al header.</p>

<p>Amb 4 components implicats, necessiteu 6 cables de comunicaci√≥. Cada cop que afegiu un nou component que necessita la cistella, heu de crear nous cables amb tots els components existents.</p>

<h4>1.4.4. Inconsist√®ncia temporal</h4>
<p>Entre el moment que el <code>ProductListComponent</code> afegeix un producte i el moment que el header rep la notificaci√≥ via esdeveniments, hi ha un instant on la informaci√≥ √©s inconsistent. L'usuari veu que el producte est√† afegit a la llista per√≤ el comptador del header encara no s'ha actualitzat. Aquesta inconsist√®ncia, encara que breu, crea confusi√≥.</p>

{% include success_box.html contingut="<strong>Clau:</strong> Quan m√∫ltiples components desconnectats necessiten les mateixes dades, la duplicaci√≥ i comunicaci√≥ manual crea complexitat, inconsist√®ncia i errors." %}

<h4>1.4.5. Resultat esperat</h4>
<p>Identificeu situacions on m√∫ltiples components necessiten compartir dades i compreneu els problemes de duplicaci√≥, comunicaci√≥ manual i inconsist√®ncia.</p>
  {% endcapture %}
  {% include section-point.html numero="1.4" titol="Problema de l'estat compartit: components desconnectats que necessiten dades comunes" contingut=section_point_1_4 %}

  {% capture section_point_1_5 %}
<h4>1.5.1. Objectiu</h4>
<p>Con√®ixer els principis fonamentals dels patrons de gesti√≥ d'estat i el concepte de flux unidireccional.</p>

<h4>1.5.2. Principi de flux unidireccional</h4>
<p>El flux unidireccional de dades √©s un patr√≥ on les dades sempre flueixen en una √∫nica direcci√≥: des de l'estat cap als components, mai a l'inrev√©s. Els components no modifiquen l'estat directament; en lloc d'aix√≤, envien accions o criden m√®todes del servei que actualitzen l'estat, i aquest propaga els canvis de tornada als components.</p>

{% capture code_8 %}Estat Central
    ‚Üì (Observable)
Components (llegeixen)
    ‚Üì (accions/m√®todes)
Estat Central (actualitza)
    ‚Üì (Observable)
Components (reben canvi){% endcapture %}
{% include code-block.html lang="text" code=code_8 %}

<p>Aquest cicle garanteix que sempre sabeu d'on ve un canvi i cap on va.</p>

<h4>1.5.3. Beneficis del flux unidireccional</h4>
<p><strong>Predictibilitat:</strong> Sempre sabeu que els canvis provenen del servei d'estat, mai directament d'un altre component. Aix√≤ simplifica la depuraci√≥: si hi ha un error en les dades d'usuari, nom√©s cal revisar el servei d'estat.</p>

<p><strong>Historial de canvis:</strong> Com tots els canvis passen pel servei, podeu registrar-los f√†cilment. Aix√≤ permet implementar funcionalitats com "desfer canvis" o auditoria de modificacions.</p>

<p><strong>Testabilitat:</strong> Podeu provar el servei d'estat a√Ølladament sense components. Les proves verifiquen que donat un estat inicial i una acci√≥, l'estat resultant √©s l'esperat.</p>

<h4>1.5.4. Comparaci√≥ amb altres patrons</h4>
<table>
<thead>
<tr>
<th>Patr√≥</th>
<th>Direcci√≥ dades</th>
<th>Complexitat</th>
<th>Predictibilitat</th>
</tr>
</thead>
<tbody>
<tr><td><strong>@Input/@Output</strong></td><td>Bidireccional</td><td>Alta (creix exponencial)</td><td>Baixa</td></tr>
<tr><td><strong>Flux unidireccional</strong></td><td>Unidireccional</td><td>Constant</td><td>Alta</td></tr>
<tr><td><strong>Shared service sense Observable</strong></td><td>Bidireccional</td><td>Mitjana</td><td>Mitjana</td></tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> El flux unidireccional de dades garanteix que sempre sabeu quin √©s l'origen d'un canvi i facilita la depuraci√≥, proves i manteniment." %}

<h4>1.5.5. Resultat esperat</h4>
<p>Compreneu el principi de flux unidireccional i els seus beneficis per a la predictibilitat i mantenibilitat del codi.</p>
  {% endcapture %}
  {% include section-point.html numero="1.5" titol="Patrons de gesti√≥ d'estat: flux unidireccional de dades" contingut=section_point_1_5 %}

  {% capture section_point_1_6 %}
<h4>1.6.1. Objectiu</h4>
<p>Comparar l'estat centralitzat amb l'estat distribu√Øt per entendre quan usar cadascun.</p>

<h4>1.6.2. Qu√® √©s l'estat distribu√Øt</h4>
<p>En l'estat distribu√Øt, cada component mant√© les seves pr√≤pies dades sense un lloc centralitzat. Cada component √©s responsable de gestionar el seu estat intern. Per exemple, un formulari gestiona els seus camps, un comptador gestiona el seu valor, i una llista gestiona els seus elements.</p>

<p>Aquest enfocament √©s adequat quan les dades s√≥n locals a un component i no es comparteixen amb altres parts de l'aplicaci√≥.</p>

<h4>1.6.3. Qu√® √©s l'estat centralitzat</h4>
<p>En l'estat centralitzat, totes les dades globals es guarden en un o m√©s serveis dedicats. Els components accedeixen a aquestes dades mitjan√ßant subscripcions i no mantenen c√≤pies locals. Qualsevol canvi a l'estat central es propaga autom√†ticament a tots els components subscrits.</p>

<h4>1.6.4. Avantatges de l'estat centralitzat</h4>
<p><strong>Font √∫nica de veritat:</strong> Nom√©s hi ha una c√≤pia de cada dada global. Si l'usuari est√† autenticat, aquesta informaci√≥ est√† en un √∫nic lloc. Aix√≤ elimina possibles inconsist√®ncies.</p>

<p><strong>Sincronitzaci√≥ autom√†tica:</strong> Quan l'estat canvia, tots els components subscrits reben la notificaci√≥ immediatament sense codi addicional. No cal implementar mecanismes de sincronitzaci√≥ manual.</p>

<p><strong>Facilitat per afegir components:</strong> Afegir un nou component que necessita accedir a l'estat global nom√©s requereix injectar el servei i subscriure's. No cal modificar components existents ni crear nous cables de comunicaci√≥.</p>

<h4>1.6.5. Desavantatges de l'estat centralitzat</h4>
<p><strong>Overhead per dades simples:</strong> Si un component nom√©s necessita un comptador local que ning√∫ m√©s utilitza, crear un servei d'estat √©s excessiu. L'estat local del component √©s m√©s simple.</p>

<p><strong>Dificultat per depurar si l'estat √©s molt gran:</strong> Si l'estat centralitzat cont√© desenes de propietats diferents, trobar quin m√®tode est√† modificant una propietat espec√≠fica pot ser complicat sense eines de depuraci√≥ avan√ßades.</p>

<p><strong>Possibilitat de crear un "god service":</strong> Si poseu tot l'estat de l'aplicaci√≥ en un √∫nic servei gegant, aquest es converteix en un punt de complexitat i dificultat de manteniment. √âs millor dividir l'estat en m√∫ltiples serveis especialitzats (AuthState, CartState, ConfigState).</p>

<h4>1.6.6. Quan usar cadascun</h4>
<table>
<thead>
<tr>
<th>Situaci√≥</th>
<th>Tipus d'estat</th>
<th>Ra√≥</th>
</tr>
</thead>
<tbody>
<tr><td>Dades locals d'un formulari</td><td>Distribu√Øt</td><td>Nom√©s el component del formulari les necessita</td></tr>
<tr><td>Usuari autenticat</td><td>Centralitzat</td><td>M√∫ltiples components (header, sidebar, profile) necessiten aquesta info</td></tr>
<tr><td>Estat d'un menu desplegable (obert/tancat)</td><td>Distribu√Øt</td><td>Nom√©s el component del menu ho necessita</td></tr>
<tr><td>Cistella de compra</td><td>Centralitzat</td><td>Header, sidebar, checkout necessiten aquesta info</td></tr>
<tr><td>Filtres globals aplicats</td><td>Centralitzat</td><td>M√∫ltiples components de llista els utilitzen</td></tr>
<tr><td>Valor temporal d'un input</td><td>Distribu√Øt</td><td>Nom√©s el component de l'input ho necessita</td></tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> Useu estat centralitzat per dades globals compartides entre m√∫ltiples components, i estat distribu√Øt per dades locals d'un √∫nic component." %}

<h4>1.6.7. Resultat esperat</h4>
<p>Sabeu distingir quan usar estat centralitzat i quan usar estat distribu√Øt segons les necessitats de l'aplicaci√≥.</p>
  {% endcapture %}
  {% include section-point.html numero="1.6" titol="Estat centralitzat vs distribu√Øt: avantatges i desavantatges" contingut=section_point_1_6 %}

  {% capture section_point_1_7 %}
<h4>1.7.1. Objectiu</h4>
<p>Crear un servei d'estat centralitzat utilitzant <code>BehaviorSubject</code> i exposar les dades com a <code>Observable</code>.</p>

<h4>1.7.2. Estructura b√†sica d'un servei d'estat</h4>
<p>Un servei d'estat t√≠pic cont√© tres elements:</p>
<ol>
<li><strong>BehaviorSubject privat:</strong> Emmagatzema l'estat actual i permet actualitzar-lo</li>
<li><strong>Observable p√∫blic:</strong> Exposa l'estat de nom√©s lectura als components</li>
<li><strong>M√®todes d'actualitzaci√≥:</strong> Permeten modificar l'estat de manera controlada</li>
</ol>

{% capture code_9 %}import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class AuthStateService {
  // 1. BehaviorSubject privat (nom√©s el servei pot modificar-lo)
  private userSubject = new BehaviorSubject<User | null>(null);

  // 2. Observable p√∫blic (components poden subscriure's)
  user$: Observable<User | null> = this.userSubject.asObservable();

  // 3. M√®todes d'actualitzaci√≥
  setUser(user: User | null): void {
    this.userSubject.next(user);
  }

  updateUserName(newName: string): void {
    const currentUser = this.userSubject.value;
    if (currentUser) {
      this.userSubject.next({ ...currentUser, name: newName });
    }
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_9 %}

<h4>1.7.3. Per qu√® BehaviorSubject i no Subject</h4>
<p><code>BehaviorSubject</code> requereix un valor inicial i emmagatzema l'√∫ltim valor em√®s. Quan un component se subscriu, rep immediatament el valor actual. Aix√≤ √©s ideal per a estat perqu√® els components necessiten con√®ixer l'estat actual en el moment de la subscripci√≥, no esperar el proper canvi.</p>

{% capture code_10 %}// BehaviorSubject: emet l'√∫ltim valor immediatament
private userSubject = new BehaviorSubject<User | null>(null);

// Component que se subscriu despr√©s:
this.authState.user$.subscribe(user => {
  console.log(user); // Rep immediatament 'null' (valor inicial)
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_10 %}

<p>En canvi, <code>Subject</code> no emet res fins que hi ha un nou valor, cosa que deixaria els components sense estat fins al primer canvi.</p>

<h4>1.7.4. Exposar com a Observable de nom√©s lectura</h4>
<p>Exposar el <code>BehaviorSubject</code> directament permet que els components cridin <code>next()</code> i modifiquin l'estat sense control. Per evitar-ho, s'exposa com a <code>Observable</code> amb <code>asObservable()</code>:</p>

{% capture code_11 %}// INCORRECTE: Components podrien fer this.userSubject.next(...)
public userSubject = new BehaviorSubject<User | null>(null);

// CORRECTE: Components nom√©s poden subscriure's i llegir
private userSubject = new BehaviorSubject<User | null>(null);
public user$ = this.userSubject.asObservable();{% endcapture %}
{% include code-block.html lang="typescript" code=code_11 %}

<h4>1.7.5. Exemple complet: servei d'estat de cistella</h4>
{% capture code_12 %}export interface CartItem {
  productId: number;
  name: string;
  price: number;
  quantity: number;
}

@Injectable({ providedIn: 'root' })
export class CartStateService {
  private itemsSubject = new BehaviorSubject<CartItem[]>([]);
  items$ = this.itemsSubject.asObservable();

  addItem(item: CartItem): void {
    const currentItems = this.itemsSubject.value;
    const existingItem = currentItems.find(i => i.productId === item.productId);

    if (existingItem) {
      // Actualitzar quantitat
      const updatedItems = currentItems.map(i =>
        i.productId === item.productId
          ? { ...i, quantity: i.quantity + item.quantity }
          : i
      );
      this.itemsSubject.next(updatedItems);
    } else {
      // Afegir nou
      this.itemsSubject.next([...currentItems, item]);
    }
  }

  removeItem(productId: number): void {
    const currentItems = this.itemsSubject.value;
    this.itemsSubject.next(currentItems.filter(i => i.productId !== productId));
  }

  clear(): void {
    this.itemsSubject.next([]);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_12 %}

{% include success_box.html contingut="<strong>Clau:</strong> Un servei d'estat utilitza <code>BehaviorSubject</code> privat per emmagatzemar l'estat, <code>Observable</code> p√∫blic per exposar-lo, i m√®todes per actualitzar-lo de manera controlada." %}

<h4>1.7.6. Resultat esperat</h4>
<p>Creeu serveis d'estat amb <code>BehaviorSubject</code>, exposeu les dades com a <code>Observable</code>, i implementeu m√®todes d'actualitzaci√≥ controlats.</p>
  {% endcapture %}
  {% include section-point.html numero="1.7" titol="Crear servei d'estat: objecte observable amb dades globals" contingut=section_point_1_7 %}

  {% capture section_point_1_8 %}
<h4>1.8.1. Objectiu</h4>
<p>Subscriure components a l'estat centralitzat perqu√® rebin actualitzacions autom√†tiques quan l'estat canvia.</p>

<h4>1.8.2. Subscripci√≥ b√†sica en un component</h4>
<p>Per accedir a l'estat, el component injecta el servei i se subscriu a l'observable:</p>

{% capture code_13 %}export class HeaderComponent implements OnInit {
  currentUser: User | null = null;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.authState.user$.subscribe(user => {
      this.currentUser = user;
      console.log('Usuari actualitzat:', user);
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_13 %}

<p>Cada cop que el servei d'estat crida <code>this.userSubject.next(newUser)</code>, tots els components subscrits reben el nou valor i actualitzen la seva propietat local.</p>

<h4>1.8.3. Utilitzar l'async pipe per subscripcions autom√†tiques</h4>
<p>En lloc de subscriure's manualment, podeu utilitzar l'<code>async</code> pipe a la plantilla. Aix√≤ t√© l'avantatge que Angular gestiona autom√†ticament la subscripci√≥ i desubscripci√≥:</p>

{% capture code_14 %}export class HeaderComponent {
  user$ = this.authState.user$; // Assignar directament l'observable

  constructor(private authState: AuthStateService) {}
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_14 %}

{% capture code_15 %}{% raw %}<!-- Plantilla amb async pipe -->
<div *ngIf="user$ | async as user; else notLoggedIn">
  <p>Benvingut, {{ user.name }}</p>
</div>
<ng-template #notLoggedIn>
  <p>No est√†s autenticat</p>
</ng-template>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_15 %}

<p>L'<code>async</code> pipe se subscriu autom√†ticament quan el component es crea i es desubscriu quan es destrueix, evitant fuites de mem√≤ria.</p>

<h4>1.8.4. M√∫ltiples components subscrits simult√†niament</h4>
<p>Quan diversos components se subscriuen al mateix observable, tots reben les actualitzacions simult√†niament:</p>

{% capture code_16 %}// HeaderComponent
export class HeaderComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}

// SidebarComponent
export class SidebarComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}

// ProfileComponent
export class ProfileComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_16 %}

<p>Quan alg√∫ crida <code>authState.setUser(newUser)</code>, els tres components actualitzen la seva vista autom√†ticament i simult√†niament.</p>

<h4>1.8.5. Gesti√≥ de subscripcions manuals</h4>
<p>Si utilitzeu subscripcions manuals (sense <code>async</code> pipe), heu de desubscriure-us per evitar fuites de mem√≤ria:</p>

{% capture code_17 %}export class HeaderComponent implements OnInit, OnDestroy {
  private subscription: Subscription;
  currentUser: User | null = null;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.subscription = this.authState.user$.subscribe(user => {
      this.currentUser = user;
    });
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_17 %}

<p><strong>Recomanaci√≥:</strong> Sempre que sigui possible, utilitzeu l'<code>async</code> pipe per evitar gesti√≥ manual de subscripcions.</p>

<h4>1.8.6. Exemple: cistella amb comptador autom√†tic</h4>
{% capture code_18 %}// HeaderComponent
export class HeaderComponent {
  cartCount$ = this.cartState.items$.pipe(
    map(items => items.reduce((sum, item) => sum + item.quantity, 0))
  );

  constructor(private cartState: CartStateService) {}
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_18 %}

{% capture code_19 %}{% raw %}<!-- Plantilla -->
<div class="cart-icon">
  <span>üõí</span>
  <span class="badge">{{ cartCount$ | async }}</span>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_19 %}

<p>Cada cop que s'afegeix o elimina un article de la cistella, el comptador s'actualitza autom√†ticament sense codi addicional.</p>

{% include success_box.html contingut="<strong>Clau:</strong> Els components se subscriuen a l'observable exposat pel servei d'estat i reben actualitzacions autom√†tiques cada cop que l'estat canvia." %}

<h4>1.8.7. Resultat esperat</h4>
<p>Subscriviu components a l'estat centralitzat utilitzant subscripcions manuals o l'<code>async</code> pipe per rebre actualitzacions autom√†tiques.</p>
  {% endcapture %}
  {% include section-point.html numero="1.8" titol="Components subscrits a canvis d'estat: rebre actualitzacions autom√†tiques" contingut=section_point_1_8 %}

  {% capture section_point_1_9 %}
<h4>1.9.1. Objectiu</h4>
<p>Implementar un cas pr√†ctic complet on l'estat d'usuari autenticat √©s accessible des de m√∫ltiples components.</p>

<h4>1.9.2. Definir la interf√≠cie i el servei</h4>
<p>Primer definiu la interf√≠cie de l'usuari i creeu el servei d'estat:</p>

{% capture code_20 %}// models/user.interface.ts
export interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

// services/auth-state.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { User } from '../models/user.interface';

@Injectable({ providedIn: 'root' })
export class AuthStateService {
  private userSubject = new BehaviorSubject<User | null>(null);
  user$ = this.userSubject.asObservable();

  setUser(user: User | null): void {
    this.userSubject.next(user);
  }

  getCurrentUser(): User | null {
    return this.userSubject.value;
  }

  isAuthenticated(): boolean {
    return this.userSubject.value !== null;
  }

  logout(): void {
    this.userSubject.next(null);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_20 %}

<h4>1.9.3. Component de login que actualitza l'estat</h4>
<p>El component de login crida un servei d'autenticaci√≥ i actualitza l'estat centralitzat:</p>

{% capture code_21 %}// components/login/login.component.ts
export class LoginComponent {
  constructor(
    private authService: AuthService,
    private authState: AuthStateService,
    private router: Router
  ) {}

  login(credentials: { email: string; password: string }): void {
    this.authService.login(credentials).subscribe({
      next: (user) => {
        this.authState.setUser(user); // Actualitza estat central
        this.router.navigate(['/dashboard']);
      },
      error: (err) => {
        console.error('Error de login:', err);
      }
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_21 %}

<h4>1.9.4. Header que mostra l'usuari autom√†ticament</h4>
<p>El header se subscriu a l'estat i mostra el nom de l'usuari:</p>

{% capture code_22 %}// components/header/header.component.ts
export class HeaderComponent {
  user$ = this.authState.user$;

  constructor(private authState: AuthStateService) {}

  logout(): void {
    this.authState.logout();
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_22 %}

{% capture code_23 %}{% raw %}<!-- header.component.html -->
<nav>
  <div *ngIf="user$ | async as user; else notAuthenticated">
    <span>Benvingut, {{ user.name }}</span>
    <button (click)="logout()">Sortir</button>
  </div>
  <ng-template #notAuthenticated>
    <a routerLink="/login">Iniciar sessi√≥</a>
  </ng-template>
</nav>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_23 %}

<h4>1.9.5. Sidebar que mostra informaci√≥ de l'usuari</h4>
<p>El sidebar tamb√© accedeix a l'estat sense necessitat de comunicaci√≥ amb el header:</p>

{% capture code_24 %}// components/sidebar/sidebar.component.ts
export class SidebarComponent {
  user$ = this.authState.user$;

  constructor(private authState: AuthStateService) {}
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_24 %}

{% capture code_25 %}{% raw %}<!-- sidebar.component.html -->
<aside *ngIf="user$ | async as user">
  <div class="user-info">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <span class="badge">{{ user.role }}</span>
  </div>
</aside>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_25 %}

<h4>1.9.6. Verificaci√≥ de permisos basada en l'estat</h4>
<p>Un component pot verificar permisos consultant l'estat:</p>

{% capture code_26 %}// components/admin-panel/admin-panel.component.ts
export class AdminPanelComponent implements OnInit {
  canAccess = false;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.authState.user$.subscribe(user => {
      this.canAccess = user?.role === 'admin';
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_26 %}

{% include success_box.html contingut="<strong>Clau:</strong> Amb l'estat centralitzat, el login actualitza l'estat una vegada i tots els components (header, sidebar, admin-panel) reben la informaci√≥ autom√†ticament." %}

<h4>1.9.7. Resultat esperat</h4>
<p>Implementeu un cas pr√†ctic complet on l'usuari autenticat √©s accessible des de m√∫ltiples components sense comunicaci√≥ manual entre ells.</p>
  {% endcapture %}
  {% include section-point.html numero="1.9" titol="Exemple pr√†ctic: usuari actual accessible des de qualsevol component" contingut=section_point_1_9 %}

  {% capture section_point_1_10 %}
<h4>1.10.1. Objectiu</h4>
<p>Comprendre el principi d'immutabilitat i aprendre a actualitzar l'estat sense modificar l'objecte original.</p>

<h4>1.10.2. Qu√® √©s la immutabilitat</h4>
<p>La immutabilitat significa que no modifiqueu un objecte existent, sin√≥ que creeu un de nou amb els canvis aplicats. En lloc de canviar <code>user.name = 'Nou nom'</code>, creeu un nou objecte amb l'operador spread: <code>{ ...user, name: 'Nou nom' }</code>.</p>

<h4>1.10.3. Per qu√® √©s important en gesti√≥ d'estat</h4>
<p>Quan modifiqueu un objecte directament, Angular i RxJS poden no detectar el canvi perqu√® l'objecte (la refer√®ncia) √©s el mateix. Els observables comparen refer√®ncies: si la refer√®ncia no canvia, no emeten notificacions.</p>

{% capture code_27 %}// INCORRECTE: Modificaci√≥ directa
updateUserName(newName: string): void {
  const user = this.userSubject.value;
  if (user) {
    user.name = newName; // Modifica l'objecte original
    this.userSubject.next(user); // Emet la mateixa refer√®ncia
  }
}
// Components subscrits NO reben notificaci√≥ perqu√® la refer√®ncia √©s igual

// CORRECTE: Crear nou objecte
updateUserName(newName: string): void {
  const user = this.userSubject.value;
  if (user) {
    this.userSubject.next({ ...user, name: newName }); // Nova refer√®ncia
  }
}
// Components subscrits S√ç reben notificaci√≥ perqu√® la refer√®ncia ha canviat{% endcapture %}
{% include code-block.html lang="typescript" code=code_27 %}

<h4>1.10.4. Immutabilitat amb arrays</h4>
<p>Per modificar arrays, utilitzeu m√®todes que retornen nous arrays (<code>map</code>, <code>filter</code>, <code>concat</code>) en lloc de m√®todes que modifiquen l'original (<code>push</code>, <code>splice</code>):</p>

{% capture code_28 %}// INCORRECTE: Modificaci√≥ directa de l'array
addItem(item: CartItem): void {
  const items = this.itemsSubject.value;
  items.push(item); // Modifica l'array original
  this.itemsSubject.next(items); // Mateixa refer√®ncia
}

// CORRECTE: Crear nou array
addItem(item: CartItem): void {
  const items = this.itemsSubject.value;
  this.itemsSubject.next([...items, item]); // Nou array
}

// CORRECTE: Eliminar element
removeItem(id: number): void {
  const items = this.itemsSubject.value;
  this.itemsSubject.next(items.filter(i => i.id !== id)); // Nou array filtrat
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_28 %}

<h4>1.10.5. Immutabilitat amb objectes niats</h4>
<p>Per modificar propietats niades, heu de crear c√≤pies de tots els nivells:</p>

{% capture code_29 %}// Estructura niada
interface AppState {
  user: User | null;
  settings: {
    theme: string;
    language: string;
  };
}

// INCORRECTE: Modificaci√≥ niada directa
updateTheme(theme: string): void {
  const state = this.stateSubject.value;
  state.settings.theme = theme; // Modifica niuat directament
  this.stateSubject.next(state);
}

// CORRECTE: Crear c√≤pies de tots els nivells
updateTheme(theme: string): void {
  const state = this.stateSubject.value;
  this.stateSubject.next({
    ...state,
    settings: {
      ...state.settings,
      theme
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_29 %}

<h4>1.10.6. Avantatges de la immutabilitat</h4>
<ul>
<li><strong>Detecci√≥ de canvis fiable:</strong> Angular detecta canvis comparant refer√®ncies</li>
<li><strong>Historial de canvis:</strong> Podeu guardar estats anteriors sense que es modifiquin</li>
<li><strong>Depuraci√≥ m√©s f√†cil:</strong> Sabeu exactament quin m√®tode va crear cada versi√≥ de l'estat</li>
<li><strong>Proves m√©s simples:</strong> L'estat anterior no canvia, facilitant assertions</li>
</ul>

{% include success_box.html contingut="<strong>Clau:</strong> No modifiqueu l'estat directament; creeu sempre nous objectes o arrays amb els canvis aplicats per garantir que Angular detecti les actualitzacions." %}

<h4>1.10.7. Resultat esperat</h4>
<p>Apliqueu el principi d'immutabilitat creant nous objectes en lloc de modificar directament l'estat existent.</p>
  {% endcapture %}
  {% include section-point.html numero="1.10" titol="Immutabilitat: per qu√® √©s important no modificar l'estat directament" contingut=section_point_1_10 %}

  {% capture section_point_1_11 %}
<h4>1.11.1. Objectiu</h4>
<p>Establir criteris clars per decidir quan implementar gesti√≥ d'estat centralitzada i quan utilitzar estat local.</p>

<h4>1.11.2. Regla dels tres components</h4>
<p>Si tres o m√©s components necessiten accedir a les mateixes dades, √©s un bon candidat per a estat centralitzat. Amb menys de tres components, la comunicaci√≥ <code>@Input/@Output</code> o un servei simple √©s suficient.</p>

<table>
<thead>
<tr>
<th>Nombre de components</th>
<th>Soluci√≥ recomanada</th>
</tr>
</thead>
<tbody>
<tr><td>1</td><td>Estat local del component</td></tr>
<tr><td>2 (pare-fill)</td><td>@Input/@Output</td></tr>
<tr><td>3+</td><td>Estat centralitzat</td></tr>
</tbody>
</table>

<h4>1.11.3. Dades que canvien freq√ºentment vs dades estables</h4>
<p>Si les dades canvien sovint i m√∫ltiples components han de reaccionar als canvis (cistella de compra, filtres actius), l'estat centralitzat √©s ideal. Si les dades s√≥n estables i nom√©s es llegeixen (configuraci√≥ de l'aplicaci√≥ que nom√©s es carrega un cop), un servei simple pot ser suficient.</p>

<h4>1.11.4. Components no relacionats que comparteixen dades</h4>
<p>Quan components que no tenen relaci√≥ pare-fill han de compartir dades (header i sidebar s√≥n germans, no pare-fill), l'estat centralitzat √©s l'√∫nica manera pr√†ctica de sincronitzar-los sense fer passar les dades per m√∫ltiples nivells de components intermedis.</p>

<h4>1.11.5. Complexitat de la l√≤gica de gesti√≥</h4>
<p>Si la l√≤gica per gestionar les dades √©s complexa (validacions, transformacions, persist√®ncia), centralitzar-la en un servei d'estat fa que sigui m√©s f√†cil de mantenir i provar. Si la l√≤gica √©s trivial (nom√©s guardar i llegir), pot no valer la pena.</p>

<h4>1.11.6. Checklist de decisi√≥</h4>
{% include checklist.html elements="M√©s de 2 components necessiten les dades?|Les dades canvien freq√ºentment durant l'√∫s de l'aplicaci√≥?|Components no relacionats (germans, cosins) necessiten sincronitzar-se?|La l√≤gica de gesti√≥ √©s complexa (validacions, transformacions)?|Necessiteu historial de canvis o capacitat de desfer?" %}

<p><strong>Si responeu "s√≠" a 3 o m√©s preguntes, utilitzeu gesti√≥ d'estat centralitzada.</strong></p>

{% include success_box.html contingut="<strong>Clau:</strong> Utilitzeu estat centralitzat quan m√∫ltiples components no relacionats necessiten dades compartides que canvien freq√ºentment amb l√≤gica complexa." %}

<h4>1.11.7. Resultat esperat</h4>
<p>Apliqueu criteris objectius per decidir quan implementar gesti√≥ d'estat centralitzada segons les necessitats de l'aplicaci√≥.</p>
  {% endcapture %}
  {% include section-point.html numero="1.11" titol="Quan usar gesti√≥ d'estat centralitzada: criteri de decisi√≥" contingut=section_point_1_11 %}

  {% capture section_point_1_12 %}
<h3>Mini exemple pr√†ctic: Servei d'estat per a tema de l'aplicaci√≥</h3>
{% include checklist.html elements="Crear servei ThemeStateService amb BehaviorSubject (valor inicial: light)|Exposar theme$ com a Observable p√∫blic de nom√©s lectura|Implementar m√®tode setTheme que actualitza l'estat|Injectar el servei al HeaderComponent i subscriure's a theme$|Mostrar al header el tema actual amb interpolaci√≥|Crear bot√≥ per canviar entre tema clar i fosc|Injectar el servei al BodyComponent i aplicar classe CSS segons el tema|Verificar que quan el bot√≥ canvia el tema, tant el header com el body s'actualitzen simult√†niament" %}
<p><strong>Resultat esperat:</strong> Una aplicaci√≥ on el tema es pot canviar des del header i el canvi es propaga autom√†ticament a tots els components subscrits sense comunicaci√≥ manual.</p>
  {% endcapture %}
  {% include section-point.html numero="1.12" titol="Mini exemple pr√†ctic ¬∑ Servei d'estat per a tema de l'aplicaci√≥" contingut=section_point_1_12 %}

  {% capture section_point_1_13 %}
<table>
<thead>
<tr>
<th>S√≠mptoma</th>
<th>Possible causa</th>
<th>Soluci√≥ r√†pida</th>
</tr>
</thead>
<tbody>
<tr>
<td>Els components no reben actualitzacions quan canvia l'estat</td>
<td>S'est√† modificant l'objecte directament sense crear un de nou</td>
<td>Utilitzar operador spread per crear nou objecte: <code>this.subject.next({ ...old, prop: newValue })</code></td>
</tr>
<tr>
<td>Error "Cannot read property 'subscribe' of undefined"</td>
<td>El servei no est√† injectat correctament o l'Observable no est√† definit</td>
<td>Verificar que el servei t√© <code>@Injectable({ providedIn: 'root' })</code> i que l'Observable s'exposa correctament</td>
</tr>
<tr>
<td>Fuita de mem√≤ria: l'aplicaci√≥ es torna lenta amb el temps</td>
<td>Subscripcions manuals sense <code>unsubscribe()</code></td>
<td>Utilitzar <code>async</code> pipe o implementar <code>ngOnDestroy()</code> amb <code>subscription.unsubscribe()</code></td>
</tr>
<tr>
<td>M√∫ltiples components mostren dades desincronitzades</td>
<td>Cada component mant√© una c√≤pia local en lloc de subscriure's</td>
<td>Eliminar c√≤pies locals i utilitzar <code>async</code> pipe directament: <code>user$ | async</code></td>
</tr>
<tr>
<td>Error "BehaviorSubject is not defined"</td>
<td>No s'ha importat de RxJS</td>
<td>Afegir <code>import { BehaviorSubject } from 'rxjs';</code> al servei</td>
</tr>
<tr>
<td>El valor inicial del BehaviorSubject no es rep als components</td>
<td>El component se subscriu despr√©s que el valor hagi canviat</td>
<td>BehaviorSubject hauria d'emetre sempre el valor actual; verificar que s'est√† subscrivint correctament amb <code>observable.subscribe()</code></td>
</tr>
<tr>
<td>L'aplicaci√≥ no compila: "Property 'asObservable' does not exist"</td>
<td>Intentar cridar <code>asObservable()</code> sobre un Observable en lloc d'un Subject</td>
<td>Nom√©s els Subjects tenen <code>asObservable()</code>; verificar que esteu aplicant-ho al BehaviorSubject, no a l'Observable</td>
</tr>
<tr>
<td>Els canvis d'estat no es veuen reflectits a la vista</td>
<td>Angular no detecta el canvi perqu√® la refer√®ncia de l'objecte no ha canviat</td>
<td>Assegurar-se de crear nous objectes/arrays en lloc de modificar els existents</td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="1.13" titol="Resoluci√≥ de problemes" contingut=section_point_1_13 %}

  {% capture section_point_1_14 %}
<h4>1.14.1. Prompt 1</h4>
{% include prompt-ai.html contingut="<strong>Rol:</strong> Expert en arquitectura d'aplicacions Angular.<br><br><strong>Context:</strong> Estic desenvolupant una aplicaci√≥ de gesti√≥ de tasques on m√∫ltiples components (llista de tasques, comptador de pendents, filtre per prioritat, vista de detall) necessiten accedir a les mateixes tasques.<br><br><strong>Tasca:</strong> Dissenya un servei d'estat centralitzat per gestionar les tasques amb m√®todes per afegir, eliminar, actualitzar i filtrar tasques, assegurant que tots els components es mantinguin sincronitzats.<br><br><strong>Format:</strong> Codi TypeScript complet del servei amb interf√≠cie de Task i exemple de subscripci√≥ d'un component." %}

<h4>1.14.2. Prompt 2</h4>
{% include prompt-ai.html contingut="<strong>Rol:</strong> Instructor de patrons de gesti√≥ d'estat en frameworks frontend.<br><br><strong>Context:</strong> Tinc una aplicaci√≥ Angular amb 5 components que comparteixen informaci√≥ sobre els productes seleccionats a la cistella de compra. Actualment cada component t√© la seva pr√≤pia c√≤pia de la cistella i la sincronitzaci√≥ es fa amb @Input i @Output.<br><br><strong>Tasca:</strong> Refactoritza l'arquitectura actual per implementar un servei d'estat centralitzat utilitzant BehaviorSubject que elimini la necessitat de @Input/@Output i asseguri sincronitzaci√≥ autom√†tica.<br><br><strong>Format:</strong> Codi abans i despr√©s mostrant la transformaci√≥ del component amb @Input/@Output a component amb subscripci√≥ al servei d'estat, incloent el servei complet." %}
  {% endcapture %}
  {% include section-point.html numero="1.14" titol="Prompts d'IA" contingut=section_point_1_14 %}

  {% capture section_point_1_15 %}
<h3>Autoavaluaci√≥</h3>
{% include checklist.html elements="Identifico situacions on m√∫ltiples components no relacionats necessiten compartir les mateixes dades globals|Creo serveis d'estat utilitzant BehaviorSubject privat i exposant Observable p√∫blic de nom√©s lectura|Implemento m√®todes d'actualitzaci√≥ d'estat que creen nous objectes en lloc de modificar els existents (immutabilitat)|Subscric components a l'estat centralitzat utilitzant l'async pipe o subscripcions manuals amb ngOnDestroy|Aplico criteris objectius per decidir quan usar estat centralitzat vs estat local segons el nombre de components i la complexitat" %}
  {% endcapture %}
  {% include section-point.html numero="1.15" titol="Autoavaluaci√≥" contingut=section_point_1_15 %}

  {% capture section_point_1_16 %}
<h3>S√≠ntesi</h3>
<ul>
<li>La gesti√≥ d'estat centralitzada resol el problema de m√∫ltiples components que necessiten accedir a les mateixes dades globals eliminant duplicaci√≥, sincronitzaci√≥ manual i cables de comunicaci√≥ entre components.</li>
<li>El patr√≥ de flux unidireccional garanteix que les dades sempre flueixen des del servei d'estat cap als components, mai a l'inrev√©s, millorant la predictibilitat, testabilitat i depuraci√≥ del codi.</li>
<li>Un servei d'estat t√≠pic utilitza <code>BehaviorSubject</code> privat per emmagatzemar l'estat actual, <code>Observable</code> p√∫blic per exposar-lo de nom√©s lectura, i m√®todes controlats per actualitzar l'estat de manera immutable.</li>
<li>Els components se subscriuen a l'observable exposat pel servei i reben actualitzacions autom√†tiques cada cop que l'estat canvia, utilitzant l'<code>async</code> pipe per evitar gesti√≥ manual de subscripcions.</li>
<li>El principi d'immutabilitat √©s fonamental: mai modifiqueu l'estat directament, sempre creeu nous objectes o arrays amb l'operador spread per garantir que Angular detecti els canvis i notifiqui els subscriptors.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="1.16" titol="S√≠ntesi" contingut=section_point_1_16 %}

  {% capture section_point_1_17 %}
<h3>Conceptes clau</h3>
<ul>
<li><strong>Gesti√≥ d'estat centralitzada:</strong> Patr√≥ on totes les dades globals es guarden en serveis dedicats accessibles des de qualsevol component sense comunicaci√≥ manual.</li>
<li><strong>BehaviorSubject:</strong> Tipus especial d'observable que emmagatzema i emet l'√∫ltim valor als nous subscriptors immediatament.</li>
<li><strong>Observable de nom√©s lectura:</strong> Exposar l'estat com a <code>Observable</code> (amb <code>asObservable()</code>) per evitar que components modifiquin l'estat directament.</li>
<li><strong>Flux unidireccional:</strong> Patr√≥ on les dades sempre flueixen des de l'estat cap als components; components no modifiquen l'estat directament sin√≥ via m√®todes del servei.</li>
<li><strong>Immutabilitat:</strong> Principi de crear nous objectes/arrays en lloc de modificar els existents per garantir detecci√≥ de canvis fiable.</li>
<li><strong>Font √∫nica de veritat:</strong> L'estat global est√† en un √∫nic lloc, eliminant inconsist√®ncies entre c√≤pies duplicades a diferents components.</li>
<li><strong>Subscripci√≥:</strong> Mecanisme pel qual un component escolta canvis d'un observable i rep notificacions autom√†tiques quan l'estat canvia.</li>
<li><strong>async pipe:</strong> Pipe d'Angular que gestiona autom√†ticament subscripci√≥ i desubscripci√≥, evitant fuites de mem√≤ria.</li>
<li><strong>Estat distribu√Øt vs centralitzat:</strong> Estat distribu√Øt mant√© dades locals a cada component; estat centralitzat guarda dades globals en serveis compartits.</li>
<li><strong>Regla dels tres components:</strong> Si tres o m√©s components necessiten les mateixes dades, √©s candidat ideal per a estat centralitzat.</li>
<li><strong>Detecci√≥ de canvis:</strong> Mecanisme d'Angular per detectar quan les dades canvien i actualitzar la vista; dep√®n de comparar refer√®ncies d'objectes.</li>
<li><strong>Fuita de mem√≤ria:</strong> Problema quan subscripcions manuals no es cancelen amb <code>unsubscribe()</code>, causant que callbacks segueixin actius innecess√†riament.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="1.17" titol="Rep√†s de conceptes" contingut=section_point_1_17 %}

</div>

<div class="section" id="Unitat4_Bloc2_Seccio2">
  <h2 id="Unitat4_Bloc2_Seccio2">2. Organitzaci√≥ en m√≤duls i c√†rrega per seccions (lazy loading)</h2>

  <!-- MULTIM√àDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=2 seccio=2 %}


  {% include objectius.html llista="Dividir l'aplicaci√≥ en m√≤duls funcionals que agrupen components, serveis i rutes relacionats|Configurar rutes amb lazy loading per carregar m√≤duls nom√©s quan l'usuari els necessita|Implementar una estrat√®gia de c√†rrega que optimitzi el temps de c√†rrega inicial de l'aplicaci√≥|Mesurar l'impacte del lazy loading en el rendiment utilitzant eines de desenvolupador" %}

  {% include info_box.html contingut="<strong>RA4 ¬∑ Criteri 4</strong> ‚Äî Optimitza els recursos i genera un paquet llest per a publicaci√≥." %}

  {% capture section_point_2_1 %}
<p>Abans de comen√ßar, necessiteu:</p>
<ul>
<li><strong>Unitat 4.1 completada:</strong> Heu configurat el sistema de rutes i sabeu crear rutes b√†siques amb components associats.</li>
<li><strong>Conceptes de components:</strong> Comprensi√≥ de com crear i organitzar components en carpetes.</li>
<li><strong>Serveis i injecci√≥ de depend√®ncies:</strong> Sabeu crear serveis i injectar-los als components.</li>
<li><strong>CLI d'Angular:</strong> Domini de comandes b√†siques per generar m√≤duls i components (<code>ng generate</code>).</li>
<li><strong>Estructura de projecte:</strong> Enteneu l'organitzaci√≥ actual del vostre projecte amb <code>src/app/</code>.</li>
</ul>

<p><strong>Verificaci√≥ r√†pida:</strong></p>

{% capture code_30 %}# Verificar que teniu el projecte amb rutes funcionals
ng serve --open
# Navegar entre diferents rutes i comprovar que funcionen{% endcapture %}
{% include code-block.html lang="bash" code=code_30 %}

<p><strong>Punt d'autocomprovaci√≥:</strong> L'aplicaci√≥ s'obre al navegador, podeu navegar entre diferents p√†gines, i enteneu on estan definides les rutes actuals.</p>
  {% endcapture %}
  {% include section-point.html numero="2.1" titol="Prerequisits" contingut=section_point_2_1 %}

  {% capture section_point_2_2 %}
<h4>2.2.1. Qu√® √©s la modularitzaci√≥ amb lazy loading</h4>
<p>La modularitzaci√≥ √©s l'organitzaci√≥ de l'aplicaci√≥ en unitats l√≤giques independents (m√≤duls) que agrupen funcionalitats relacionades. El lazy loading (c√†rrega diferida) carrega aquests m√≤duls nom√©s quan l'usuari els necessita, no durant la c√†rrega inicial. Aix√≤ redueix dr√†sticament el temps que l'aplicaci√≥ triga a estar operativa.</p>

<h4>2.2.2. Problema sense modularitzaci√≥ i lazy loading</h4>
<p><strong>Situaci√≥ abans:</strong></p>
<p>Tota l'aplicaci√≥ es carrega d'un sol cop quan l'usuari obre la p√†gina inicial. Tots els components, serveis, llibreries i codi de totes les funcionalitats es descarreguen immediatament, encara que l'usuari nom√©s necessiti veure la p√†gina d'inici.</p>

{% capture code_31 %}Fitxer √∫nic compilat: main.js (3.2 MB)
‚îú‚îÄ‚îÄ Codi de login i registre (300 KB)
‚îú‚îÄ‚îÄ Codi de dashboard (450 KB)
‚îú‚îÄ‚îÄ Codi d'administraci√≥ (800 KB)
‚îú‚îÄ‚îÄ Codi de preferits (200 KB)
‚îú‚îÄ‚îÄ Codi de cerca avan√ßada (350 KB)
‚îú‚îÄ‚îÄ Codi de gesti√≥ de perfil (250 KB)
‚îî‚îÄ‚îÄ Llibreries compartides (850 KB)

Temps de c√†rrega inicial: 8-12 segons amb connexi√≥ mitjana{% endcapture %}
{% include code-block.html lang="text" code=code_31 %}

<p>L'usuari espera 10 segons per veure la p√†gina d'inici, tot i que nom√©s accedir√† a administraci√≥ si √©s admin (10% dels usuaris).</p>

<p><strong>Problemes que genera:</strong></p>

<p><strong>1. Temps de c√†rrega inicial inacceptable</strong></p>
<p>Amb aplicacions grans, el fitxer principal pot pesar 3-5 MB. En connexions m√≤bils o 3G, aix√≤ significa 10-15 segons de pantalla blanca abans que l'usuari vegi res. El 53% dels usuaris abandonen un lloc web que triga m√©s de 3 segons a carregar (dades de Google). Esteu perdent la meitat dels vostres usuaris potencials per mala optimitzaci√≥.</p>

{% capture code_32 %}Connexi√≥ 4G (10 Mbps): 3.2 MB ‚Üí 2.5 segons
Connexi√≥ 3G (2 Mbps): 3.2 MB ‚Üí 12.8 segons
Connexi√≥ lenta (750 Kbps): 3.2 MB ‚Üí 34 segons{% endcapture %}
{% include code-block.html lang="text" code=code_32 %}

<p><strong>2. Desperdici de recursos en funcionalitats no utilitzades</strong></p>
<p>Si el 90% dels usuaris s√≥n usuaris normals que mai accedeixen al panell d'administraci√≥, esteu for√ßant-los a descarregar 800 KB de codi d'administraci√≥ que mai utilitzaran. Aix√≤ √©s com portar 50 kg de roba a un viatge de cap de setmana "per si de cas".</p>
<p>Un estudi de Chrome revela que el 60% del codi JavaScript descarregat en una aplicaci√≥ web t√≠pica mai s'executa. Esteu malgastant ample de banda i recursos de processador dels vostres usuaris.</p>

<p><strong>3. Dificultat per mantenir i organitzar codi gran</strong></p>
<p>Quan tot el codi est√† en un √∫nic lloc, trobar components espec√≠fics es complica. Teniu 150 components en una √∫nica carpeta plana <code>src/app/components/</code>. Localitzar el component que necessiteu modificar requereix despla√ßar-se per llistes interminables. Els conflictes en control de versions augmenten perqu√® m√∫ltiples desenvolupadors treballen en el mateix espai.</p>

<p><strong>4. Temps de compilaci√≥ incrementals massa llargs</strong></p>
<p>Cada cop que modifiqueu un component, Angular ha de recompilar tota l'aplicaci√≥ perqu√® tot est√† interconnectat. Una aplicaci√≥ sense modularitzar pot trigar 15-20 segons a recompilar despr√©s d'un canvi petit. Aix√≤ destrueix la productivitat: feu un canvi d'una l√≠nia, espereu 20 segons, veieu el resultat, repetiu.</p>

<p><strong>5. Impossibilitat de treball en equip eficient</strong></p>
<p>Quan diferents equips treballen en funcionalitats diferents (equip de dashboard, equip d'administraci√≥, equip de cerca), tots modifiquen fitxers al mateix directori. Els conflictes de merge es multipliquen. No podeu assignar clarament responsabilitats: "l'equip A s'encarrega del m√≤dul d'administraci√≥" no t√© sentit si tot √©s un monolit.</p>

<h4>2.2.3. Soluci√≥ amb modularitzaci√≥ i lazy loading</h4>
<p>Dividiu l'aplicaci√≥ en m√≤duls funcionals independents que es carreguen nom√©s quan l'usuari accedeix a aquella funcionalitat. El fitxer inicial cont√© nom√©s el codi essencial; la resta es carrega sota demanda.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>C√†rrega inicial r√†pida:</strong> Nom√©s es carrega el codi essencial (200-500 KB en lloc de 3 MB)</li>
<li><strong>Escalabilitat:</strong> Podeu afegir noves funcionalitats sense augmentar el temps de c√†rrega inicial</li>
<li><strong>Organitzaci√≥ clara:</strong> Cada funcionalitat t√© el seu propi m√≤dul amb components i serveis</li>
<li><strong>Millor experi√®ncia d'usuari:</strong> L'aplicaci√≥ respon en 1-2 segons, no 10-15 segons</li>
<li><strong>Treball en equip eficient:</strong> Equips treballen en m√≤duls independents amb menys conflictes</li>
</ol>

<h4>2.2.4. Exemple real complet: Sense vs Amb lazy loading</h4>
<p><strong>Situaci√≥:</strong> Una aplicaci√≥ de comer√ß electr√≤nic amb cat√†leg de productes (p√†gina principal), panell d'administraci√≥, i p√†gina de preferits.</p>

<p><strong>Sense lazy loading:</strong></p>
{% capture code_33 %}// app-routing.module.ts - TOT ES CARREGA IMMEDIATAMENT
import { ProductListComponent } from './products/product-list.component';
import { ProductDetailComponent } from './products/product-detail.component';
import { AdminDashboardComponent } from './admin/admin-dashboard.component';
import { AdminUsersComponent } from './admin/admin-users.component';
import { FavoritesComponent } from './favorites/favorites.component';

const routes: Routes = [
  { path: '', component: ProductListComponent },
  { path: 'product/:id', component: ProductDetailComponent },
  { path: 'admin', component: AdminDashboardComponent },
  { path: 'admin/users', component: AdminUsersComponent },
  { path: 'favorites', component: FavoritesComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_33 %}

<p>Resultat: <strong>main.js = 3.2 MB</strong>, c√†rrega inicial = 12 segons en 3G.</p>

<p><strong>Amb lazy loading:</strong></p>

{% capture code_34 %}// app-routing.module.ts - NOM√âS CARREGA EL QUE ES NECESSITA
const routes: Routes = [
  {
    path: '',
    loadChildren: () => import('./products/products.module').then(m => m.ProductsModule)
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  },
  {
    path: 'favorites',
    loadChildren: () => import('./favorites/favorites.module').then(m => m.FavoritesModule)
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_34 %}

<p>Resultat: <strong>main.js = 450 KB</strong>, c√†rrega inicial = 2 segons en 3G. Els m√≤duls admin (800 KB) i favorites (200 KB) es carreguen nom√©s quan l'usuari hi accedeix.</p>

<h4>2.2.5. Taula comparativa: Abans vs Despr√©s</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Sense lazy loading</th>
<th>Amb lazy loading</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mida inicial (main.js)</strong></td>
<td>3.2 MB</td>
<td>450 KB</td>
</tr>
<tr>
<td><strong>Temps c√†rrega 3G</strong></td>
<td>12.8 segons</td>
<td>2 segons</td>
</tr>
<tr>
<td><strong>Temps fins interactiu</strong></td>
<td>15 segons</td>
<td>3 segons</td>
</tr>
<tr>
<td><strong>% usuaris que abandonen</strong></td>
<td>53%</td>
<td>12%</td>
</tr>
<tr>
<td><strong>Codi no utilitzat descarregat</strong></td>
<td>1.9 MB (60%)</td>
<td>0 KB</td>
</tr>
<tr>
<td><strong>Temps recompilaci√≥ dev</strong></td>
<td>18 segons</td>
<td>4 segons</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> El lazy loading redueix el temps de c√†rrega inicial de 12.8 segons a 2 segons (millora del 84%), i elimina la desc√†rrega de codi no utilitzat (1.9 MB estalviats)." %}
  {% endcapture %}
  {% include section-point.html numero="2.2" titol="Marc conceptual" contingut=section_point_2_2 %}

  {% capture section_point_2_3 %}
<p><strong>Biblioteca modular d'una ciutat</strong></p>
<p>Una biblioteca gran no posa tots els llibres en una √∫nica sala gegant. Organitza els llibres en sales tem√†tiques: sala de ci√®ncia, sala d'hist√≤ria, sala infantil. Quan entres a la biblioteca, nom√©s accedeixes a la sala que necessites. Els llibres de les altres sales no ocupen el teu espai mental. Els m√≤duls funcionen igual: cada "sala" (m√≤dul) s'obre nom√©s quan la necessites.</p>

<p><strong>Apartament amb habitacions tancades</strong></p>
<p>Quan arribes a casa, no encens els llums de totes les habitacions simult√†niament. Encens el llum del rebedor, i despr√©s obres les habitacions que necessites. El lazy loading funciona aix√≠: l'aplicaci√≥ "enc√©n" nom√©s el m√≤dul inicial, i despr√©s carrega cada m√≤dul (habitaci√≥) quan l'usuari hi "entra" navegant a aquella ruta.</p>

<p><strong>Restaurant amb cuina a la carta</strong></p>
<p>Un restaurant no prepara tots els plats del men√∫ quan obre. Prepara cada plat quan un client el demana. Aix√≤ estalvia temps, ingredients i espai a la cuina. De la mateixa manera, el lazy loading no "cuina" (carrega) tot el codi al principi; prepara cada m√≤dul quan l'usuari l'accedeix.</p>

<p><strong>Caixes en un magatzem amb etiquetes</strong></p>
<p>Imagineu un magatzem amb 50 caixes. No obriu totes les caixes al mat√≠ per veure qu√® hi ha dins. Cada caixa t√© una etiqueta, i nom√©s obriu la caixa que necessiteu en aquell moment. Els m√≤duls s√≥n com caixes etiquetades: sabeu qu√® contenen (components, serveis), i nom√©s les "obriu" (carrega) quan les necessiteu.</p>

<p><strong>Sistema de transport p√∫blic amb zones</strong></p>
<p>Una ciutat no envia tots els autobusos de totes les l√≠nies simult√†niament a l'hora punta. Cada l√≠nia d'autob√∫s (m√≤dul) opera independentment. Quan agafes la l√≠nia 5, no est√†s esperant que arribin tamb√© les l√≠nies 1, 2, 3 i 4. El lazy loading carrega nom√©s la "l√≠nia" (m√≤dul) que has demanat.</p>
  {% endcapture %}
  {% include section-point.html numero="2.3" titol="Model mental" contingut=section_point_2_3 %}

  {% capture section_point_2_4 %}
<h4>2.4.1. Objectiu</h4>
<p>Comprendre qu√® √©s un m√≤dul d'Angular i per qu√® agrupar funcionalitats relacionades en m√≤duls independents.</p>

<h4>2.4.2. Definici√≥ de m√≤dul</h4>
<p>Un m√≤dul d'Angular (<code>NgModule</code>) √©s una classe decorada amb <code>@NgModule()</code> que agrupa components, serveis, directives i pipes relacionats amb una funcionalitat espec√≠fica. Cada m√≤dul √©s una unitat cohesiva que pot importar-se i reutilitzar-se.</p>
<p>Angular t√© sempre almenys un m√≤dul: l'<code>AppModule</code> (m√≤dul principal). Per√≤ en aplicacions grans, creeu m√≤duls addicionals per organitzar la funcionalitat.</p>

<h4>2.4.3. Analogia del m√≤dul com a caixa d'eines</h4>
<p>Penseu en un m√≤dul com una caixa d'eines especialitzada. Un fuster t√© una caixa per treballar la fusta (serres, form√≥, nivell) i una altra per acabats (pinzells, lija, vern√≠s). No barreja totes les eines en una √∫nica caixa gegant; les organitza per funcionalitat.</p>
<p>De la mateixa manera, en lloc de tenir tots els 150 components en un √∫nic <code>AppModule</code>, creeu:</p>
<ul>
<li><code>ProductsModule</code>: components i serveis per gestionar productes</li>
<li><code>AdminModule</code>: components i serveis per administraci√≥</li>
<li><code>AuthModule</code>: components i serveis d'autenticaci√≥</li>
</ul>

<h4>2.4.4. Estructura d'un m√≤dul t√≠pic</h4>
{% capture code_35 %}// products.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProductListComponent } from './product-list/product-list.component';
import { ProductDetailComponent } from './product-detail/product-detail.component';
import { ProductsRoutingModule } from './products-routing.module';

@NgModule({
  declarations: [
    ProductListComponent,    // Components del m√≤dul
    ProductDetailComponent
  ],
  imports: [
    CommonModule,            // M√≤duls que necessita
    ProductsRoutingModule    // Rutes del m√≤dul
  ],
  providers: []              // Serveis espec√≠fics del m√≤dul
})
export class ProductsModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_35 %}

<p>Aquest m√≤dul encapsula tota la funcionalitat de productes: llista, detall, i les seves rutes.</p>

{% include success_box.html contingut="<strong>Clau:</strong> Un m√≤dul agrupa components, serveis i rutes relacionats amb una funcionalitat espec√≠fica, mantenint l'organitzaci√≥ clara i escalable." %}

<h4>2.4.5. Resultat esperat</h4>
<p>Comprensi√≥ del concepte de m√≤dul d'Angular i la seva utilitat per agrupar funcionalitats relacionades.</p>
  {% endcapture %}
  {% include section-point.html numero="2.4" titol="Qu√® s√≥n els m√≤duls: agrupacions l√≤giques de funcionalitat" contingut=section_point_2_4 %}

  {% capture section_point_2_5 %}
<h4>2.5.1. Objectiu</h4>
<p>Identificar els beneficis concrets que proporciona l'organitzaci√≥ en m√≤duls.</p>

<h4>2.5.2. Organitzaci√≥ clara i escalable</h4>
<p>Amb m√≤duls, l'estructura de carpetes reflecteix clarament les funcionalitats de l'aplicaci√≥:</p>

{% capture code_36 %}src/app/
‚îú‚îÄ‚îÄ core/               (M√≤dul amb serveis globals)
‚îú‚îÄ‚îÄ shared/             (M√≤dul amb components reutilitzables)
‚îú‚îÄ‚îÄ products/           (M√≤dul de productes)
‚îÇ   ‚îú‚îÄ‚îÄ product-list/
‚îÇ   ‚îú‚îÄ‚îÄ product-detail/
‚îÇ   ‚îî‚îÄ‚îÄ products.module.ts
‚îú‚îÄ‚îÄ admin/              (M√≤dul d'administraci√≥)
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îî‚îÄ‚îÄ admin.module.ts
‚îî‚îÄ‚îÄ app.module.ts{% endcapture %}
{% include code-block.html lang="text" code=code_36 %}

<p>Trobar codi relacionat amb productes √©s trivial: tot est√† dins de <code>products/</code>. No cal buscar entre 150 components.</p>

<h4>2.5.3. Reutilitzaci√≥ entre projectes</h4>
<p>Un m√≤dul ben dissenyat √©s autocontingut i es pot reutilitzar en altres projectes. Per exemple, si creeu un <code>AuthModule</code> amb login, registre i recuperaci√≥ de contrasenya, podeu copiar aquesta carpeta sencera a un altre projecte i funciona sense modificacions.</p>
<p>Aix√≤ accelera el desenvolupament de nous projectes: en lloc de reescriure autenticaci√≥ cada vegada, reutilitzeu el m√≤dul existent.</p>

<h4>2.5.4. Mantenibilitat i reducci√≥ de conflictes</h4>
<p>Quan equips diferents treballen en m√≤duls diferents, els conflictes de merge es redueixen dr√†sticament. L'equip A modifica fitxers dins de <code>admin/</code>, l'equip B modifica fitxers dins de <code>products/</code>. Rarament toquen els mateixos fitxers.</p>
<p>A m√©s, quan cal corregir un error relacionat amb administraci√≥, sabeu que el problema est√† dins del m√≤dul <code>AdminModule</code>. No cal revisar tota l'aplicaci√≥.</p>

<h4>2.5.5. Compilaci√≥ incremental m√©s r√†pida</h4>
<p>Angular pot compilar nom√©s els m√≤duls que han canviat. Si modifiqueu un component dins de <code>ProductsModule</code>, Angular recompila nom√©s aquest m√≤dul, no <code>AdminModule</code> ni <code>AuthModule</code>. Aix√≤ redueix el temps de recompilaci√≥ de 18 segons a 4 segons.</p>

<h4>2.5.6. Proves unit√†ries m√©s senzilles</h4>
<p>Provar un m√≤dul a√Ølladament √©s m√©s f√†cil que provar tota l'aplicaci√≥. Podeu carregar nom√©s <code>ProductsModule</code> en les proves i verificar que funciona correctament sense preocupar-vos per interfer√®ncies d'altres m√≤duls.</p>

<table>
<thead>
<tr>
<th>Avantatge</th>
<th>Benefici pr√†ctic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Organitzaci√≥</strong></td>
<td>Trobar codi en 10 segons vs 5 minuts</td>
</tr>
<tr>
<td><strong>Reutilitzaci√≥</strong></td>
<td>Estalviar 20 hores en projectes futurs</td>
</tr>
<tr>
<td><strong>Mantenibilitat</strong></td>
<td>Localitzar errors en minuts vs hores</td>
</tr>
<tr>
<td><strong>Compilaci√≥</strong></td>
<td>Recompilar en 4s vs 18s</td>
</tr>
<tr>
<td><strong>Proves</strong></td>
<td>Executar proves unit√†ries 3x m√©s r√†pid</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> La modularitzaci√≥ millora l'organitzaci√≥, reutilitzaci√≥, mantenibilitat, temps de compilaci√≥ i facilitat de proves de manera significativa." %}

<h4>2.5.7. Resultat esperat</h4>
<p>Identificaci√≥ dels avantatges concrets de modularitzar l'aplicaci√≥ i com impacten positivament el desenvolupament.</p>
  {% endcapture %}
  {% include section-point.html numero="2.5" titol="Avantatges de modularitzar: organitzaci√≥, reutilitzaci√≥, mantenibilitat" contingut=section_point_2_5 %}

  {% capture section_point_2_6 %}
<h4>2.6.1. Objectiu</h4>
<p>Crear un m√≤dul funcional complet que agrupa components, serveis i rutes d'una funcionalitat espec√≠fica.</p>

<h4>2.6.2. Generar m√≤dul amb CLI</h4>
<p>Angular CLI facilita la creaci√≥ de m√≤duls amb una comanda:</p>

{% capture code_37 %}ng generate module admin --routing
# o forma abreujada:
ng g m admin --routing{% endcapture %}
{% include code-block.html lang="bash" code=code_37 %}

<p>Aix√≤ crea:</p>
{% capture code_38 %}src/app/admin/
‚îú‚îÄ‚îÄ admin-routing.module.ts   (Rutes del m√≤dul)
‚îî‚îÄ‚îÄ admin.module.ts            (Definici√≥ del m√≤dul){% endcapture %}
{% include code-block.html lang="text" code=code_38 %}

<p>El flag <code>--routing</code> crea autom√†ticament el fitxer de rutes del m√≤dul.</p>

<h4>2.6.3. Afegir components al m√≤dul</h4>
<p>Genereu components dins del m√≤dul:</p>

{% capture code_39 %}ng g c admin/dashboard
ng g c admin/users{% endcapture %}
{% include code-block.html lang="bash" code=code_39 %}

<p>Angular CLI detecta que esteu dins de <code>admin/</code> i afegeix autom√†ticament els components a <code>admin.module.ts</code>:</p>

{% capture code_40 %}// admin.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminRoutingModule } from './admin-routing.module';
import { DashboardComponent } from './dashboard/dashboard.component';
import { UsersComponent } from './users/users.component';

@NgModule({
  declarations: [
    DashboardComponent,
    UsersComponent
  ],
  imports: [
    CommonModule,
    AdminRoutingModule
  ]
})
export class AdminModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_40 %}

<h4>2.6.4. Configurar rutes del m√≤dul</h4>
<p>Definiu les rutes internes del m√≤dul a <code>admin-routing.module.ts</code>:</p>

{% capture code_41 %}// admin-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { DashboardComponent } from './dashboard/dashboard.component';
import { UsersComponent } from './users/users.component';

const routes: Routes = [
  { path: '', component: DashboardComponent },        // /admin
  { path: 'users', component: UsersComponent }        // /admin/users
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class AdminRoutingModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_41 %}

<p><strong>Nota important:</strong> Utilitzeu <code>RouterModule.forChild(routes)</code> als m√≤duls funcionals, NO <code>forRoot()</code>. El <code>forRoot()</code> nom√©s s'usa a l'<code>AppModule</code>.</p>

<h4>2.6.5. Afegir serveis al m√≤dul (opcional)</h4>
<p>Si el m√≤dul necessita serveis espec√≠fics, creeu-los dins del m√≤dul:</p>

{% capture code_42 %}ng g s admin/services/user-management{% endcapture %}
{% include code-block.html lang="bash" code=code_42 %}

<p>Podeu proporcionar el servei a nivell de m√≤dul si voleu que nom√©s existeixi dins del m√≤dul:</p>

{% capture code_43 %}// admin.module.ts
import { UserManagementService } from './services/user-management.service';

@NgModule({
  // ...
  providers: [UserManagementService]  // Servei espec√≠fic del m√≤dul
})
export class AdminModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_43 %}

{% include success_box.html contingut="<strong>Clau:</strong> Un m√≤dul funcional agrupa components, serveis i rutes relacionats, creats amb CLI i configurats amb routing propi mitjan√ßant RouterModule.forChild()." %}

<h4>2.6.6. Resultat esperat</h4>
<p>Creaci√≥ de m√≤duls funcionals complets amb components, serveis i rutes agrupats l√≤gicament.</p>
  {% endcapture %}
  {% include section-point.html numero="2.6" titol="Crear m√≤dul funcional: agrupant components, serveis i rutes relacionats" contingut=section_point_2_6 %}

  {% capture section_point_2_7 %}
<h4>2.7.1. Objectiu</h4>
<p>Aprendre a importar m√≤duls a l'aplicaci√≥ principal i comprendre la difer√®ncia entre eager i lazy loading.</p>

<h4>2.7.2. Importaci√≥ eager (c√†rrega immediata)</h4>
<p>Per importar un m√≤dul de manera eager, l'afegiu a la llista <code>imports</code> de l'<code>AppModule</code>:</p>

{% capture code_44 %}// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { AdminModule } from './admin/admin.module';  // Import eager

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    AdminModule,        // M√≤dul carregat immediatament
    AppRoutingModule    // AppRoutingModule sempre √∫ltim
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_44 %}

<p>Amb aquesta configuraci√≥, tot el codi de <code>AdminModule</code> es carrega immediatament quan l'aplicaci√≥ arrenca.</p>

<h4>2.7.3. Configurar ruta per a m√≤dul eager</h4>
<p>Quan importeu un m√≤dul eager, les seves rutes s'integren autom√†ticament. No cal fer res especial a <code>app-routing.module.ts</code>; les rutes del m√≤dul ja estan disponibles.</p>
<p>Per√≤ sovint voleu prefixar les rutes del m√≤dul:</p>

{% capture code_45 %}// app-routing.module.ts
const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_45 %}

<p><strong>Nota:</strong> Amb <code>loadChildren</code>, passem de eager a lazy. M√©s endavant veurem aix√≤ en detall.</p>

<h4>2.7.4. Ordre d'importaci√≥ de m√≤duls</h4>
<p><strong>Cr√≠tic:</strong> L'ordre d'importaci√≥ dels m√≤duls dins de <code>imports</code> √©s important. L'<code>AppRoutingModule</code> ha d'anar sempre √∫ltim:</p>

{% capture code_46 %}imports: [
  BrowserModule,
  SharedModule,       // M√≤duls compartits primer
  AdminModule,        // M√≤duls funcionals despr√©s
  AppRoutingModule    // AppRoutingModule SEMPRE √öLTIM
]{% endcapture %}
{% include code-block.html lang="typescript" code=code_46 %}

<p>Si poseu <code>AppRoutingModule</code> abans que altres m√≤duls amb rutes, les rutes d'aquests m√≤duls es poden ignorar perqu√® el router troba primer la ruta gen√®rica <code>{ path: '**' }</code> de l'<code>AppRoutingModule</code>.</p>

<h4>2.7.5. Difer√®ncia entre forRoot() i forChild()</h4>
<ul>
<li><strong><code>forRoot()</code>:</strong> Nom√©s s'usa una vegada a l'<code>AppModule</code>. Configura el router amb configuraci√≥ global.</li>
<li><strong><code>forChild()</code>:</strong> S'usa a tots els m√≤duls funcionals. Afegeix rutes al router sense duplicar la configuraci√≥ global.</li>
</ul>

{% capture code_47 %}// AppModule
RouterModule.forRoot(routes)  // Configura router globalment

// M√≤duls funcionals
RouterModule.forChild(routes) // Afegeix rutes sense reconfigurar{% endcapture %}
{% include code-block.html lang="typescript" code=code_47 %}

{% include success_box.html contingut="<strong>Clau:</strong> Els m√≤duls es poden importar de manera eager (c√†rrega immediata) afegint-los a imports de l'AppModule, tenint cura de l'ordre d'importaci√≥." %}

<h4>2.7.6. Resultat esperat</h4>
<p>Importaci√≥ de m√≤duls a l'aplicaci√≥ principal i comprensi√≥ de la difer√®ncia entre forRoot() i forChild().</p>
  {% endcapture %}
  {% include section-point.html numero="2.7" titol="Importar m√≤duls: com integrar-los a l'aplicaci√≥ principal" contingut=section_point_2_7 %}

  {% capture section_point_2_8 %}
<h4>2.8.1. Objectiu</h4>
<p>Comprendre el concepte de lazy loading i per qu√® √©s fonamental per optimitzar el rendiment.</p>

<h4>2.8.2. Qu√® √©s el lazy loading</h4>
<p>Lazy loading (c√†rrega diferida) √©s la t√®cnica de carregar parts del codi nom√©s quan l'usuari les necessita. En lloc de descarregar tot el codi al principi, l'aplicaci√≥ descarrega el codi m√≠nim necessari, i despr√©s carrega m√≤duls addicionals sota demanda.</p>
<p>Aix√≤ redueix dr√†sticament el temps de c√†rrega inicial perqu√® el navegador nom√©s descarrega, parseja i executa el codi essencial.</p>

<h4>2.8.3. Com funciona internament</h4>
<p>Quan configureu lazy loading, Angular:</p>
<ol>
<li>Compila cada m√≤dul lazy en un fitxer JavaScript separat (chunk)</li>
<li>Durant la c√†rrega inicial, NO inclou aquests chunks al fitxer principal</li>
<li>Quan l'usuari navega a una ruta lazy, Angular descarrega el chunk corresponent</li>
<li>Una vegada descarregat, Angular carrega el m√≤dul i renderitza els components</li>
</ol>

{% capture code_48 %}Usuari obre aplicaci√≥
  ‚Üì
Descarrega main.js (450 KB)
  ‚Üì
Aplicaci√≥ operativa en 2 segons
  ‚Üì
Usuari clica "Admin"
  ‚Üì
Descarrega admin.chunk.js (800 KB) en background
  ‚Üì
M√≤dul admin operatiu en 1 segon{% endcapture %}
{% include code-block.html lang="text" code=code_48 %}

<h4>2.8.4. Avantatges del lazy loading</h4>
<p><strong>Temps de c√†rrega inicial redu√Øt:</strong> El fitxer principal √©s 70-80% m√©s petit. Una aplicaci√≥ de 3.2 MB es redueix a 450 KB. Aix√≤ significa temps de c√†rrega inicial de 2-3 segons en lloc de 10-15 segons.</p>
<p><strong>Millor experi√®ncia d'usuari:</strong> L'usuari veu contingut i pot interactuar amb l'aplicaci√≥ molt m√©s r√†pidament. La percepci√≥ de velocitat millora dr√†sticament.</p>
<p><strong>Estalvi d'ample de banda:</strong> Els usuaris nom√©s descarreguen el codi que realment utilitzen. Si un usuari mai accedeix a l'administraci√≥, mai descarrega els 800 KB de codi d'admin. Aix√≤ √©s especialment important en connexions m√≤bils amb dades limitades.</p>
<p><strong>Escalabilitat sense penalitzaci√≥:</strong> Podeu afegir noves funcionalitats (nous m√≤duls lazy) sense augmentar el temps de c√†rrega inicial. Cada nova funcionalitat √©s un nou chunk que es carrega sota demanda.</p>

<h4>2.8.5. Quan es carrega un m√≤dul lazy</h4>
<p>Un m√≤dul lazy es carrega la primera vegada que l'usuari navega a una ruta d'aquell m√≤dul. Despr√©s de carregar-se, queda en mem√≤ria i ja no cal tornar-lo a descarregar.</p>

{% capture code_49 %}Usuari accedeix /products ‚Üí ProductsModule es carrega
Usuari accedeix /product/123 ‚Üí ProductsModule ja est√† carregat, no es descarrega novament
Usuari accedeix /admin ‚Üí AdminModule es carrega per primera vegada
Usuari accedeix /admin/users ‚Üí AdminModule ja est√† carregat{% endcapture %}
{% include code-block.html lang="text" code=code_49 %}

<h4>2.8.6. Comparativa de c√†rrega</h4>
<table>
<thead>
<tr>
<th>M√®tode</th>
<th>Mida inicial</th>
<th>Temps 3G</th>
<th>Codi no utilitzat</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Eager (tot immediatament)</strong></td>
<td>3.2 MB</td>
<td>12.8s</td>
<td>60%</td>
</tr>
<tr>
<td><strong>Lazy (sota demanda)</strong></td>
<td>450 KB</td>
<td>2s</td>
<td>0%</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> El lazy loading carrega m√≤duls nom√©s quan l'usuari els necessita, reduint dr√†sticament el temps de c√†rrega inicial i millorant l'experi√®ncia d'usuari." %}

<h4>2.8.7. Resultat esperat</h4>
<p>Comprensi√≥ del concepte de lazy loading, com funciona internament i els seus avantatges en rendiment.</p>
  {% endcapture %}
  {% include section-point.html numero="2.8" titol="Lazy loading: c√†rrega diferida de m√≤duls quan es necessiten" contingut=section_point_2_8 %}

  {% capture section_point_2_9 %}
<h4>2.9.1. Objectiu</h4>
<p>Implementar lazy loading configurant rutes amb la sintaxi <code>loadChildren</code> i imports din√†mics.</p>

<h4>2.9.2. Sintaxi de lazy loading</h4>
<p>Per configurar una ruta lazy, utilitzeu <code>loadChildren</code> amb una funci√≥ que retorna una promise d'importaci√≥ din√†mica:</p>

{% capture code_50 %}// app-routing.module.ts
const routes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  },
  {
    path: 'products',
    loadChildren: () => import('./products/products.module').then(m => m.ProductsModule)
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_50 %}

<p><strong>Nota important:</strong> NO importeu el m√≤dul a la part superior del fitxer quan useu lazy loading. L'import din√†mic <code>import()</code> dins de <code>loadChildren</code> √©s l'√∫nica importaci√≥ necess√†ria.</p>

<h4>2.9.3. Anatomia de loadChildren</h4>
{% capture code_51 %}loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
//            ‚Üë    ‚Üë                                ‚Üë       ‚Üë
//            ‚îÇ    ‚îÇ                                ‚îÇ       ‚îî‚îÄ Classe del m√≤dul
//            ‚îÇ    ‚îÇ                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Promesa resolta
//            ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Import din√†mic
//            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Funci√≥ arrow{% endcapture %}
{% include code-block.html lang="typescript" code=code_51 %}

<ol>
<li><strong>Funci√≥ arrow:</strong> <code>() =&gt;</code> crea una funci√≥ que s'executa quan l'usuari accedeix a la ruta</li>
<li><strong>Import din√†mic:</strong> <code>import('./admin/admin.module')</code> carrega el m√≤dul de manera as√≠ncrona</li>
<li><strong>Promesa resolta:</strong> <code>.then(m =&gt; m.AdminModule)</code> retorna la classe del m√≤dul quan s'ha carregat</li>
</ol>

<h4>2.9.4. Eliminar importaci√≥ eager del m√≤dul</h4>
<p>Si pr√®viament ten√≠eu el m√≤dul importat a l'<code>AppModule</code>, elimineu aquesta importaci√≥:</p>

{% capture code_52 %}// app.module.ts

// ELIMINAR si useu lazy loading:
import { AdminModule } from './admin/admin.module';

@NgModule({
  imports: [
    BrowserModule,
    // AdminModule,  ‚Üê ELIMINAR aquesta l√≠nia
    AppRoutingModule
  ]
})
export class AppModule { }{% endcapture %}
{% include code-block.html lang="typescript" code=code_52 %}

<p>Si deixeu la importaci√≥ eager, el m√≤dul es carregar√† immediatament i el lazy loading no funcionar√†.</p>

<h4>2.9.5. Rutes niades amb lazy loading</h4>
<p>Els m√≤duls lazy poden tenir rutes niades definides al seu propi routing module:</p>

{% capture code_53 %}// admin-routing.module.ts (dins del m√≤dul lazy)
const routes: Routes = [
  { path: '', component: AdminDashboardComponent },
  { path: 'users', component: UsersComponent },
  { path: 'settings', component: SettingsComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_53 %}

<p>Quan accediu a <code>/admin/users</code>, el router:</p>
<ol>
<li>Carrega <code>AdminModule</code> (si no est√† carregat)</li>
<li>Navega a la ruta <code>users</code> dins del m√≤dul</li>
</ol>

<h4>2.9.6. Verificar que funciona</h4>
<p>Obriu les DevTools del navegador (F12) ‚Üí Network ‚Üí filtreu per "chunk". Navegueu per l'aplicaci√≥ i observeu com es descarreguen fitxers <code>.chunk.js</code> quan accediu a rutes lazy per primera vegada.</p>

{% capture code_54 %}/             ‚Üí main.js (450 KB) descarregat
/products     ‚Üí products.chunk.js (280 KB) descarregat
/admin        ‚Üí admin.chunk.js (800 KB) descarregat
/admin/users  ‚Üí No es descarrega res (admin ja est√† carregat){% endcapture %}
{% include code-block.html lang="text" code=code_54 %}

{% include success_box.html contingut="<strong>Clau:</strong> El lazy loading es configura amb loadChildren i imports din√†mics, eliminant la importaci√≥ eager del m√≤dul de l'AppModule." %}

<h4>2.9.7. Resultat esperat</h4>
<p>Configuraci√≥ de rutes amb lazy loading utilitzant <code>loadChildren</code> i verificaci√≥ que els m√≤duls es carreguen sota demanda.</p>
  {% endcapture %}
  {% include section-point.html numero="2.9" titol="Configurar rutes amb lazy loading: sintaxi espec√≠fica" contingut=section_point_2_9 %}

  {% capture section_point_2_10 %}
<h4>2.10.1. Objectiu</h4>
<p>Mesurar i quantificar els beneficis reals del lazy loading en temps de c√†rrega i experi√®ncia d'usuari.</p>

<h4>2.10.2. M√®trica 1: Time to Interactive (TTI)</h4>
<p>El Time to Interactive √©s el temps que triga l'aplicaci√≥ des que l'usuari obre la p√†gina fins que pot interactuar amb ella. Google considera que un TTI inferior a 3.8 segons √©s bo.</p>

<p><strong>Sense lazy loading:</strong></p>
<ul>
<li>Descarregar 3.2 MB: 12.8s (3G)</li>
<li>Parsejar i executar JavaScript: 2.5s</li>
<li>TTI total: <strong>15.3 segons</strong></li>
</ul>

<p><strong>Amb lazy loading:</strong></p>
<ul>
<li>Descarregar 450 KB: 2s (3G)</li>
<li>Parsejar i executar JavaScript: 0.8s</li>
<li>TTI total: <strong>2.8 segons</strong></li>
</ul>

<p>Millora: <strong>82% m√©s r√†pid</strong>.</p>

<h4>2.10.3. M√®trica 2: First Contentful Paint (FCP)</h4>
<p>El First Contentful Paint √©s el temps que triga a apar√®ixer el primer contingut visible a la pantalla.</p>
<p><strong>Sense lazy loading:</strong> FCP = 8.5 segons (l'usuari veu pantalla blanca 8 segons)</p>
<p><strong>Amb lazy loading:</strong> FCP = 1.2 segons</p>
<p>Millora: <strong>86% m√©s r√†pid</strong>.</p>

<h4>2.10.4. M√®trica 3: Retenci√≥ d'usuaris</h4>
<p>Segons estad√≠stiques de Google i Amazon:</p>
<ul>
<li>53% dels usuaris abandonen si la p√†gina triga m√©s de 3 segons</li>
<li>Cada 100ms de millora en velocitat augmenta conversions un 1%</li>
</ul>

<p><strong>Aplicaci√≥ sense lazy loading (TTI 15s):</strong></p>
<ul>
<li>Taxa d'abandonament: 75%</li>
<li>Usuaris que interactuen: 25%</li>
</ul>

<p><strong>Aplicaci√≥ amb lazy loading (TTI 2.8s):</strong></p>
<ul>
<li>Taxa d'abandonament: 12%</li>
<li>Usuaris que interactuen: 88%</li>
</ul>

<p>Millora: <strong>252% m√©s usuaris</strong> que utilitzen l'aplicaci√≥.</p>

<h4>2.10.5. M√®trica 4: Consum de dades m√≤bils</h4>
<p>En connexions m√≤bils amb plans de dades limitats, cada MB compte.</p>
<p><strong>Usuari t√≠pic que nom√©s visita 3 p√†gines:</strong></p>
<ul>
<li>Sense lazy loading: Descarrega 3.2 MB (tot el codi)</li>
<li>Amb lazy loading: Descarrega 450 KB (inicial) + 280 KB (products) = 730 KB</li>
</ul>
<p>Estalvi: <strong>2.47 MB (77% menys dades)</strong> per usuari t√≠pic.</p>

<h4>2.10.6. Taula de beneficis quantificats</h4>
<table>
<thead>
<tr>
<th>M√®trica</th>
<th>Sense lazy</th>
<th>Amb lazy</th>
<th>Millora</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TTI (3G)</strong></td>
<td>15.3s</td>
<td>2.8s</td>
<td>82% m√©s r√†pid</td>
</tr>
<tr>
<td><strong>FCP</strong></td>
<td>8.5s</td>
<td>1.2s</td>
<td>86% m√©s r√†pid</td>
</tr>
<tr>
<td><strong>Mida inicial</strong></td>
<td>3.2 MB</td>
<td>450 KB</td>
<td>86% m√©s petit</td>
</tr>
<tr>
<td><strong>Taxa retenci√≥</strong></td>
<td>25%</td>
<td>88%</td>
<td>252% m√©s usuaris</td>
</tr>
<tr>
<td><strong>Consum dades</strong></td>
<td>3.2 MB</td>
<td>730 KB</td>
<td>77% menys</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> El lazy loading redueix el TTI en un 82%, millora el FCP en un 86%, i augmenta la retenci√≥ d'usuaris en un 252%, amb impacte directe en l'experi√®ncia i l'√®xit de l'aplicaci√≥." %}

<h4>2.10.7. Resultat esperat</h4>
<p>Quantificaci√≥ dels beneficis reals del lazy loading en temps de c√†rrega, retenci√≥ d'usuaris i consum de dades.</p>
  {% endcapture %}
  {% include section-point.html numero="2.10" titol="Beneficis: reducci√≥ del temps de c√†rrega inicial" contingut=section_point_2_10 %}

  {% capture section_point_2_11 %}
<h4>2.11.1. Objectiu</h4>
<p>Aprendre a prendre decisions estrat√®giques sobre quins m√≤duls carregar immediatament i quins diferir amb lazy loading.</p>

<h4>2.11.2. Criteris de decisi√≥</h4>
<p><strong>Carregueu immediatament (eager):</strong></p>
<ul>
<li>Components visibles a la p√†gina inicial (header, footer, home)</li>
<li>Funcionalitat cr√≠tica que tots els usuaris necessiten</li>
<li>M√≤duls molt petits (&lt; 50 KB) on el lazy overhead no compensa</li>
<li>Serveis globals que molts components necessiten</li>
</ul>

<p><strong>Carregueu diferit (lazy):</strong></p>
<ul>
<li>Panells d'administraci√≥ (nom√©s per administradors)</li>
<li>Funcionalitats avan√ßades poc utilitzades</li>
<li>Seccions grans amb molts components (&gt; 200 KB)</li>
<li>Contingut darrere d'autenticaci√≥</li>
</ul>

<h4>2.11.3. Exemple d'estrat√®gia per aplicaci√≥ e-commerce</h4>
<table>
<thead>
<tr>
<th>Funcionalitat</th>
<th>M√®tode</th>
<th>Ra√≥</th>
</tr>
</thead>
<tbody>
<tr>
<td>Home / Cat√†leg</td>
<td>Eager</td>
<td>Tots els usuaris ho veuen primer</td>
</tr>
<tr>
<td>Header / Footer</td>
<td>Eager</td>
<td>Sempre visibles</td>
</tr>
<tr>
<td>Detall de producte</td>
<td>Eager</td>
<td>Molt utilitzat (80% usuaris)</td>
</tr>
<tr>
<td>Cistella</td>
<td>Eager</td>
<td>Funcionalitat cr√≠tica</td>
</tr>
<tr>
<td>Checkout</td>
<td>Lazy</td>
<td>Nom√©s 15% arriben aqu√≠</td>
</tr>
<tr>
<td>Administraci√≥</td>
<td>Lazy</td>
<td>Nom√©s admins (5% usuaris)</td>
</tr>
<tr>
<td>Preferits</td>
<td>Lazy</td>
<td>Funcionalitat secund√†ria</td>
</tr>
<tr>
<td>Cerca avan√ßada</td>
<td>Lazy</td>
<td>Poc utilitzada (10% usuaris)</td>
</tr>
</tbody>
</table>

<h4>2.11.4. Preloading strategies avan√ßades</h4>
<p>Angular ofereix estrat√®gies de preload que carreguen m√≤duls lazy en background despr√©s de la c√†rrega inicial:</p>

{% capture code_55 %}// app-routing.module.ts
@NgModule({
  imports: [RouterModule.forRoot(routes, {
    preloadingStrategy: PreloadAllModules  // Precarrega tots els m√≤duls lazy
  })],
  exports: [RouterModule]
}){% endcapture %}
{% include code-block.html lang="typescript" code=code_55 %}

<p>Estrat√®gies disponibles:</p>
<ul>
<li><strong>NoPreloading</strong> (per defecte): Nom√©s carrega quan l'usuari accedeix</li>
<li><strong>PreloadAllModules</strong>: Carrega tots els m√≤duls lazy en background despr√©s de l'inici</li>
<li><strong>Custom</strong>: Podeu crear estrat√®gies personalitzades per precarregar nom√©s certs m√≤duls</li>
</ul>

<h4>2.11.5. Quan usar preloading</h4>
<p><strong>Useu PreloadAllModules quan:</strong></p>
<ul>
<li>L'aplicaci√≥ no √©s massa gran (&lt; 5 m√≤duls lazy)</li>
<li>Voleu eliminar el petit retard quan l'usuari accedeix a un m√≤dul lazy</li>
<li>Els usuaris tenen connexions r√†pides</li>
</ul>

<p><strong>NO useu preloading quan:</strong></p>
<ul>
<li>L'aplicaci√≥ √©s molt gran (&gt; 10 m√≤duls lazy)</li>
<li>Molts usuaris tenen connexions lentes</li>
<li>Hi ha m√≤duls que molt pocs usuaris utilitzen</li>
</ul>

{% include success_box.html contingut="<strong>Clau:</strong> Carregueu eager la funcionalitat cr√≠tica i visible inicialment; diferiu amb lazy les seccions avan√ßades, administraci√≥ i contingut poc utilitzat." %}

<h4>2.11.6. Resultat esperat</h4>
<p>Aplicaci√≥ de criteris estrat√®gics per decidir qu√® carregar immediatament i qu√® diferir segons l'√∫s real de cada funcionalitat.</p>
  {% endcapture %}
  {% include section-point.html numero="2.11" titol="Estrat√®gia: qu√® carregar immediatament i qu√® diferir" contingut=section_point_2_11 %}

  {% capture section_point_2_12 %}
<h3>Mini exemple pr√†ctic: M√≤dul d'administraci√≥ amb lazy loading</h3>
{% include checklist.html elements="Crear m√≤dul admin amb routing: ng g m admin --routing|Crear dos components dins del m√≤dul: ng g c admin/dashboard i ng g c admin/users|Configurar rutes internes del m√≤dul a admin-routing.module.ts amb forChild()|Afegir ruta lazy a app-routing.module.ts amb loadChildren i import din√†mic|Eliminar qualsevol import eager de AdminModule de l'AppModule|Servir l'aplicaci√≥ i obrir DevTools ‚Üí Network|Navegar a /admin i observar com es descarrega admin.chunk.js|Verificar que la navegaci√≥ entre /admin i /admin/users no descarrega res m√©s" %}

<p><strong>Resultat esperat:</strong> Un m√≤dul d'administraci√≥ que es carrega nom√©s quan l'usuari accedeix a <code>/admin</code>, reduint la mida inicial de l'aplicaci√≥.</p>
  {% endcapture %}
  {% include section-point.html numero="2.12" titol="Mini exemple pr√†ctic ¬∑ M√≤dul d'administraci√≥ amb lazy loading" contingut=section_point_2_12 %}

  {% capture section_point_2_13 %}
<table>
<thead>
<tr>
<th>S√≠mptoma</th>
<th>Possible causa</th>
<th>Soluci√≥ r√†pida</th>
</tr>
</thead>
<tbody>
<tr>
<td>El m√≤dul lazy no es carrega i d√≥na error 404</td>
<td>El path del loadChildren √©s incorrecte o el m√≤dul no existeix</td>
<td>Verificar que el path './admin/admin.module' √©s correcte i que el fitxer existeix</td>
</tr>
<tr>
<td>Error "Cannot find module" quan navego a ruta lazy</td>
<td>Sintaxi incorrecta de loadChildren o falta .then(m =&gt; m.ModuleName)</td>
<td>Assegurar sintaxi: loadChildren: () =&gt; import('./path').then(m =&gt; m.ModuleName)</td>
</tr>
<tr>
<td>El m√≤dul es carrega immediatament, no lazy</td>
<td>El m√≤dul encara est√† importat a l'AppModule</td>
<td>Eliminar la importaci√≥ del m√≤dul de imports: [] a AppModule</td>
</tr>
<tr>
<td>Error "forRoot() already called"</td>
<td>S'est√† usant forRoot() en un m√≤dul lazy en lloc de forChild()</td>
<td>Canviar RouterModule.forRoot(routes) per RouterModule.forChild(routes) al m√≤dul lazy</td>
</tr>
<tr>
<td>Les rutes del m√≤dul lazy no funcionen</td>
<td>El routing module del m√≤dul no est√† importat al m√≤dul</td>
<td>Afegir ModuleRoutingModule a imports: [] del m√≤dul</td>
</tr>
<tr>
<td>No es veuen fitxers .chunk.js a DevTools</td>
<td>El lazy loading no est√† configurat o la build √©s de desenvolupament sense optimitzaci√≥</td>
<td>Verificar configuraci√≥ de loadChildren i compilar amb ng build --configuration production</td>
</tr>
<tr>
<td>Error "Unexpected value 'Module' imported by module"</td>
<td>Est√† important el m√≤dul amb import est√†tic en lloc de din√†mic</td>
<td>Eliminar import { Module } from './path' i deixar nom√©s l'import dins de loadChildren</td>
</tr>
<tr>
<td>El temps de c√†rrega inicial no millora</td>
<td>Hi ha massa m√≤duls eager o els chunks lazy s√≥n massa petits</td>
<td>Revisar estrat√®gia: convertir m√©s m√≤duls a lazy, especialment els grans (&gt; 200 KB)</td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="2.13" titol="Resoluci√≥ de problemes" contingut=section_point_2_13 %}

  {% capture section_point_2_14 %}
<h4>2.14.1. Prompt 1</h4>
{% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte d'aplicacions Angular especialitzat en optimitzaci√≥ de rendiment.<br><br><strong>Context:</strong> Tinc una aplicaci√≥ Angular amb 8 funcionalitats principals: cat√†leg de productes, cistella, checkout, perfil d'usuari, preferits, administraci√≥, cerca avan√ßada i configuraci√≥. Actualment tot es carrega immediatament i el temps de c√†rrega inicial √©s de 14 segons.<br><br><strong>Tasca:</strong> Proposa una estrat√®gia completa de modularitzaci√≥ i lazy loading indicant quins m√≤duls crear, quins carregar eager i quins lazy, i estima la millora esperada en temps de c√†rrega.<br><br><strong>Format:</strong> Taula amb columnes: Funcionalitat, M√≤dul, M√®tode (Eager/Lazy), Mida estimada, Ra√≥, i un resum final amb temps de c√†rrega abans/despr√©s." %}

<h4>2.14.2. Prompt 2</h4>
{% include prompt-ai.html contingut="<strong>Rol:</strong> Instructor d'Angular especialitzat en lazy loading.<br><br><strong>Context:</strong> He creat un m√≤dul AdminModule amb components de dashboard i gesti√≥ d'usuaris. Vull implementar lazy loading per√≤ no estic segur de la sintaxi exacta ni dels passos necessaris per evitar errors.<br><br><strong>Tasca:</strong> Proporciona una guia pas a pas completa per convertir el meu AdminModule de c√†rrega eager a lazy loading, incloent codi complet dels fitxers afectats (app-routing.module.ts, admin-routing.module.ts, app.module.ts) i com verificar que funciona correctament.<br><br><strong>Format:</strong> Guia numerada amb snippets de codi complets per cada fitxer i instruccions de verificaci√≥ amb DevTools." %}
  {% endcapture %}
  {% include section-point.html numero="2.14" titol="Prompts d'IA" contingut=section_point_2_14 %}

  {% capture section_point_2_15 %}
<h3>Autoavaluaci√≥</h3>
{% include checklist.html elements="Creo m√≤duls funcionals amb CLI que agrupen components, serveis i rutes relacionats amb --routing|Configuro rutes internes dels m√≤duls utilitzant RouterModule.forChild() correctament|Implemento lazy loading amb loadChildren i imports din√†mics eliminant imports eager del m√≤dul|Aplico criteris estrat√®gics per decidir quins m√≤duls carregar eager (cr√≠tics, visibles) i quins lazy (administraci√≥, avan√ßats)|Verifico que els m√≤duls lazy es carreguen correctament observant fitxers .chunk.js a DevTools Network" %}
  {% endcapture %}
  {% include section-point.html numero="2.15" titol="Autoavaluaci√≥" contingut=section_point_2_15 %}

  {% capture section_point_2_16 %}
<h3>S√≠ntesi</h3>
<ul>
<li>La modularitzaci√≥ organitza l'aplicaci√≥ en unitats funcionals independents que agrupen components, serveis i rutes relacionats, millorant l'organitzaci√≥, reutilitzaci√≥ i mantenibilitat del codi amb reducci√≥ de temps de compilaci√≥.</li>
<li>El lazy loading carrega m√≤duls nom√©s quan l'usuari els necessita, reduint el temps de c√†rrega inicial en un 80-85% i la mida del fitxer principal de 3 MB a 450 KB, millorant dr√†sticament Time to Interactive i First Contentful Paint.</li>
<li>Els m√≤duls funcionals es creen amb <code>ng g m module-name --routing</code>, configuren rutes internes amb <code>RouterModule.forChild()</code>, i es carreguen lazy amb <code>loadChildren: () =&gt; import('./path').then(m =&gt; m.Module)</code> eliminant imports eager.</li>
<li>L'estrat√®gia √≤ptima √©s carregar eager la funcionalitat cr√≠tica visible inicialment (home, header, cat√†leg) i diferir amb lazy les seccions d'administraci√≥, funcionalitats avan√ßades i contingut poc utilitzat per optimitzar recursos.</li>
<li>Els beneficis quantificables inclouen 82% millora en TTI, 86% reducci√≥ en mida inicial, 252% augment en retenci√≥ d'usuaris, i 77% estalvi de dades m√≤bils per usuaris t√≠pics.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="2.16" titol="S√≠ntesi" contingut=section_point_2_16 %}

  {% capture section_point_2_17 %}
<h3>Conceptes clau</h3>
<ul>
<li><strong>M√≤dul funcional:</strong> Agrupaci√≥ de components, serveis i rutes relacionats amb una funcionalitat espec√≠fica de l'aplicaci√≥.</li>
<li><strong>Lazy loading:</strong> T√®cnica de c√†rrega diferida que carrega m√≤duls nom√©s quan l'usuari accedeix a les seves rutes.</li>
<li><strong>Eager loading:</strong> C√†rrega immediata de m√≤duls durant l'inici de l'aplicaci√≥, inclosos a <code>imports</code> de l'<code>AppModule</code>.</li>
<li><strong>loadChildren:</strong> Propietat de configuraci√≥ de rutes que especifica un m√≤dul per carregar de manera lazy amb import din√†mic.</li>
<li><strong>Import din√†mic:</strong> Sintaxi <code>import('./path')</code> que retorna una promise i permet carregar m√≤duls de manera as√≠ncrona.</li>
<li><strong>Code splitting:</strong> Divisi√≥ autom√†tica del codi en m√∫ltiples fitxers (chunks) que es carreguen separadament.</li>
<li><strong>Chunk:</strong> Fitxer JavaScript generat pel compilador que cont√© el codi d'un m√≤dul lazy (ex: <code>admin.chunk.js</code>).</li>
<li><strong>RouterModule.forChild():</strong> M√®tode per configurar rutes en m√≤duls funcionals sense duplicar configuraci√≥ global del router.</li>
<li><strong>Time to Interactive (TTI):</strong> Temps des que l'usuari obre la p√†gina fins que pot interactuar; objectiu &lt; 3.8 segons.</li>
<li><strong>First Contentful Paint (FCP):</strong> Temps fins que apareix el primer contingut visible a la pantalla de l'usuari.</li>
<li><strong>Preloading strategy:</strong> Estrat√®gia per carregar m√≤duls lazy en background despr√©s de la c√†rrega inicial per eliminar retards.</li>
<li><strong>SharedModule:</strong> M√≤dul que cont√© components, directives i pipes reutilitzables compartits entre m√∫ltiples m√≤duls funcionals.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="2.17" titol="Rep√†s de conceptes" contingut=section_point_2_17 %}

</div>

<div class="section" id="Unitat4_Bloc2_Seccio3">
  <h2 id="Unitat4_Bloc2_Seccio3">3. Separaci√≥ de responsabilitats i capes</h2>

  <!-- MULTIM√àDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=2 seccio=3 %}


  {% include objectius.html llista="Aplicar el principi de responsabilitat √∫nica separant presentaci√≥, l√≤gica de negoci i acc√©s a dades|Refactoritzar components barrejats en components presentacionals nets amb serveis de suport|Implementar el patr√≥ contenidor/presentacional amb smart components i dumb components|Organitzar el codi en capes clarament definides per facilitar proves, mantenibilitat i reutilitzaci√≥" %}

  {% include info_box.html contingut="<strong>RA4 ¬∑ Criteri 4</strong> ‚Äî Optimitza els recursos i genera un paquet llest per a publicaci√≥." %}

  {% capture section_point_3_1 %}
<p>Abans de comen√ßar, necessiteu:</p>
<ul>
<li><strong>Unitat 3 completada:</strong> Heu treballat amb serveis, injecci√≥ de depend√®ncies i comunicaci√≥ amb APIs.</li>
<li><strong>Components funcionals:</strong> Sabeu crear components i gestionar el seu cicle de vida amb <code>ngOnInit</code> i <code>ngOnDestroy</code>.</li>
<li><strong>Serveis b√†sics:</strong> Comprensi√≥ de com crear serveis amb <code>@Injectable</code> i injectar-los als components.</li>
<li><strong>HttpClient:</strong> Experi√®ncia b√†sica fent peticions HTTP a APIs externes.</li>
<li><strong>Conceptes de responsabilitat:</strong> Enteneu qu√® significa que una classe o funci√≥ tingui una √∫nica responsabilitat.</li>
</ul>

<h4>Verificaci√≥ r√†pida</h4>
{% capture code_56 %}# Verificar que teniu el projecte amb components i serveis
ng serve --open
# Comprovar que podeu navegar i veure dades d'una API{% endcapture %}
{% include code-block.html lang="bash" code=code_56 %}

<p><strong>Punt d'autocomprovaci√≥:</strong> L'aplicaci√≥ mostra dades d'una API, teniu components que funcionen, i enteneu com es comuniquen components i serveis.</p>
  {% endcapture %}
  {% include section-point.html numero="3.1" titol="Prerequisits" contingut=section_point_3_1 %}

  {% capture section_point_3_2 %}
<h3>Qu√® √©s la separaci√≥ de responsabilitats en capes</h3>
<p>La separaci√≥ de responsabilitats en capes √©s un principi d'arquitectura de programari on cada part del codi t√© una √∫nica responsabilitat clarament definida. En aplicacions Angular, aix√≤ significa organitzar el codi en tres capes principals: presentaci√≥ (components que mostren dades), l√≤gica de negoci (serveis que processen dades i apliquen regles), i acc√©s a dades (serveis que es comuniquen amb APIs). Cada capa dep√®n de les inferiors per√≤ mai a l'inrev√©s.</p>

<h3>Problema sense separaci√≥ de responsabilitats</h3>
<h4>Situaci√≥ abans</h4>
<p>Un component fa massa coses: mostra la interf√≠cie, valida dades, fa c√†lculs de negoci, es comunica amb l'API, transforma respostes, i gestiona errors. Tot aquest codi barrejat fa que el component tingui 300-500 l√≠nies i sigui impossible de provar i mantenir.</p>

{% capture code_57 %}{% raw %}// Component barrejat amb totes les responsabilitats
@Component({
  selector: 'app-product-list',
  template: `
    <div *ngFor="let product of products">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨ - Descompte: {{ calculateDiscount(product) }}%</p>
      <button (click)="addToCart(product)">Afegir</button>
    </div>
  `
})
export class ProductListComponent implements OnInit {
  products: any[] = [];
  cart: any[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // RESPONSABILITAT 1: Comunicaci√≥ amb API
    this.http.get('https://api.example.com/products').subscribe(
      (response: any) => {
        // RESPONSABILITAT 2: Transformaci√≥ de dades
        this.products = response.data.map((item: any) => ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        }));
      },
      error => {
        // RESPONSABILITAT 3: Gesti√≥ d'errors
        console.error('Error:', error);
        alert('No s\'han pogut carregar els productes');
      }
    );
  }

  // RESPONSABILITAT 4: L√≤gica de negoci (c√†lcul de descomptes)
  calculateDiscount(product: any): number {
    if (product.stock > 100) return 20;
    if (product.stock > 50) return 10;
    if (product.stock > 10) return 5;
    return 0;
  }

  // RESPONSABILITAT 5: Gesti√≥ d'estat (cistella)
  addToCart(product: any) {
    const existing = this.cart.find(item => item.id === product.id);
    if (existing) {
      existing.quantity++;
    } else {
      this.cart.push({ ...product, quantity: 1 });
    }
    // RESPONSABILITAT 6: Persist√®ncia local
    localStorage.setItem('cart', JSON.stringify(this.cart));
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_57 %}

<p>Aquest component t√© 6 responsabilitats diferents en un √∫nic fitxer de 80 l√≠nies.</p>

<h4>Problemes que genera</h4>

<p><strong>1. Dificultat per fer proves unit√†ries</strong></p>
<p>Per provar que el c√†lcul de descompte funciona correctament, heu de crear un component complet amb totes les seves depend√®ncies: <code>HttpClient</code>, localStorage, i simular respostes d'API. Testejar una √∫nica funci√≥ requereix configurar tot un ecosistema. Si el c√†lcul de descompte estigu√©s en un servei independent, podr√≠eu provar nom√©s el servei sense components ni HTTP.</p>

<p><strong>2. Impossibilitat de reutilitzar l√≤gica</strong></p>
<p>La funci√≥ <code>calculateDiscount()</code> est√† tancada dins del component. Si necessiteu calcular descomptes en un altre component (cistella, detall de producte, checkout), heu de copiar-enganxar el codi. Ara teniu 3 c√≤pies de la mateixa l√≤gica; si cal canviar els descomptes, heu de modificar 3 fitxers diferents amb risc d'inconsist√®ncies.</p>

<p><strong>3. Modificacions arrisquen trencar m√∫ltiples coses</strong></p>
<p>Quan voleu canviar com es mostren els productes a la interf√≠cie, heu de tocar el mateix fitxer que cont√© la l√≤gica de descomptes i la comunicaci√≥ amb l'API. Un canvi visual innocent pot trencar accidentalment la l√≤gica de negoci perqu√® tot est√† barrejat. Cada modificaci√≥ √©s una jugada de Jenga: tocar una pe√ßa pot fer caure tot l'edifici.</p>

<p><strong>4. Components de 300-500 l√≠nies impossibles de llegir</strong></p>
<p>Components amb m√∫ltiples responsabilitats creixen descontroladament. Revisar un component de 400 l√≠nies per trobar un error espec√≠fic √©s com buscar una agulla en un paller. Els nous desenvolupadors triguen hores a entendre qu√® fa cada part del component perqu√® tot est√† entrella√ßat.</p>

<p><strong>5. Acoblament fort amb depend√®ncies externes</strong></p>
<p>El component dep√®n directament de <code>HttpClient</code> i localStorage. Si voleu canviar com es carreguen dades (per exemple, usar WebSockets o una llibreria diferent), heu de modificar tots els components que fan peticions HTTP. Amb 30 components que accedeixen directament a l'API, un canvi d'arquitectura requereix modificar 30 fitxers.</p>

<h3>Soluci√≥ amb separaci√≥ de responsabilitats en capes</h3>
<p>Dividiu el codi en capes amb responsabilitats clares: components nom√©s mostren i capturen interaccions, serveis de negoci apliquen regles i processament, serveis de dades comuniquen amb APIs. Cada capa es pot provar, modificar i reutilitzar independentment.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>Proves unit√†ries senzilles:</strong> Cada capa es prova a√Ølladament sense depend√®ncies complexes</li>
<li><strong>Reutilitzaci√≥ de l√≤gica:</strong> Serveis es poden usar des de qualsevol component</li>
<li><strong>Canvis localitzats:</strong> Modificar presentaci√≥ no afecta l√≤gica; canviar l√≤gica no afecta presentaci√≥</li>
<li><strong>Components petits:</strong> Components de 50-80 l√≠nies f√†cils de llegir i entendre</li>
<li><strong>Desacoblament:</strong> Canviar com s'obt√© dades no afecta components ni l√≤gica de negoci</li>
</ol>

<h3>Exemple real complet: Sense vs Amb separaci√≥ de capes</h3>
<p><strong>Situaci√≥:</strong> Una aplicaci√≥ de llista de productes amb descomptes segons stock.</p>

<h4>Sense separaci√≥ de responsabilitats (component barrejat)</h4>
{% capture code_58 %}// Un √∫nic fitxer fa tot: 80 l√≠nies, 6 responsabilitats
export class ProductListComponent {
  products: any[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get('https://api.example.com/products').subscribe(
      (response: any) => {
        this.products = response.data.map((item: any) => ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100
        }));
      }
    );
  }

  calculateDiscount(product: any): number {
    if (product.stock > 100) return 20;
    if (product.stock > 50) return 10;
    return 0;
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_58 %}

<p><strong>80 l√≠nies</strong> en un √∫nic fitxer, impossible de provar a√Ølladament.</p>

<h4>Amb separaci√≥ de responsabilitats (capes definides)</h4>
{% capture code_59 %}{% raw %}// 1. CAPA DE DADES: Servei que comunica amb API
@Injectable({ providedIn: 'root' })
export class ProductDataService {
  constructor(private http: HttpClient) {}

  getProducts(): Observable<ProductDTO[]> {
    return this.http.get<{ data: ProductDTO[] }>('https://api.example.com/products')
      .pipe(map(response => response.data));
  }
}

// 2. CAPA DE L√íGICA: Servei amb regles de negoci
@Injectable({ providedIn: 'root' })
export class DiscountService {
  calculateDiscount(stock: number): number {
    if (stock > 100) return 20;
    if (stock > 50) return 10;
    return 0;
  }
}

// 3. CAPA DE PRESENTACI√ì: Component que nom√©s mostra
@Component({
  selector: 'app-product-list',
  template: `
    <div *ngFor="let product of products$ | async">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨ - Descompte: {{ getDiscount(product) }}%</p>
    </div>
  `
})
export class ProductListComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product.stock);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_59 %}

<p><strong>3 fitxers separats</strong>, cada un amb una √∫nica responsabilitat, testejables independentment.</p>

<h3>Taula comparativa: Abans vs Despr√©s</h3>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Component barrejat</th>
<th>Capes separades</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>L√≠nies per fitxer</strong></td>
<td>80-300</td>
<td>20-50 per fitxer</td>
</tr>
<tr>
<td><strong>Responsabilitats per classe</strong></td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td><strong>Dificultat per testejar</strong></td>
<td>Alta (molts mocks)</td>
<td>Baixa (testejar servei sol)</td>
</tr>
<tr>
<td><strong>Reutilitzaci√≥ de l√≤gica</strong></td>
<td>Impossible (dins component)</td>
<td>F√†cil (injectar servei)</td>
</tr>
<tr>
<td><strong>Impacte d'un canvi visual</strong></td>
<td>Pot trencar l√≤gica</td>
<td>Zero (capa independent)</td>
</tr>
<tr>
<td><strong>Temps per entendre codi</strong></td>
<td>20-30 minuts</td>
<td>5 minuts</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> La separaci√≥ de responsabilitats redueix la complexitat de 80-300 l√≠nies per fitxer a 20-50 l√≠nies, passa de 6 responsabilitats a 1, i redueix el temps d'entendre el codi de 30 minuts a 5 minuts." %}
  {% endcapture %}
  {% include section-point.html numero="3.2" titol="Marc conceptual" contingut=section_point_3_2 %}

  {% capture section_point_3_3 %}
<p><strong>Restaurant amb brigada de cuina</strong></p>
<p>En un restaurant professional, cada membre de la brigada t√© una responsabilitat espec√≠fica: el xef de partida prepara els plats (l√≤gica), el cambrer porta els plats als clients (presentaci√≥), i el magatzemer s'encarrega de l'aprovisionament (dades). Ning√∫ fa la feina d'altri. Si el xef hagu√©s de servir taules i fer comandes als prove√Ødors, el restaurant seria un caos. Les capes de l'aplicaci√≥ funcionen igual: cada una fa una cosa espec√≠fica i es coordinen entre elles.</p>

<p><strong>F√†brica amb cadena de muntatge</strong></p>
<p>Una f√†brica eficient organitza la producci√≥ en estacions especialitzades: una estaci√≥ obt√© mat√®ries primeres (capa de dades), una altra les processa i ensambla (capa de l√≤gica), i una tercera empaqueta i presenta el producte final (capa de presentaci√≥). Cada estaci√≥ √©s experta en la seva tasca. Si una sola persona hagu√©s de fer tot, seria lenta i propensa a errors.</p>

<p><strong>Edifici amb plantes separades</strong></p>
<p>Un edifici d'oficines organitza les empreses en plantes: la planta baixa at√©n clients (presentaci√≥), el primer pis gestiona operacions (l√≤gica), i el s√≤tan guarda l'arxiu (dades). Cada planta t√© una funci√≥ clara. Si tot estigu√©s barrejat en una √∫nica sala, seria impossible treballar eficientment. Les capes arquitect√≤niques funcionen com plantes d'un edifici: separades per√≤ connectades.</p>

<p><strong>Orquestra amb seccions instrumentals</strong></p>
<p>En una orquestra simf√≤nica, cada secci√≥ t√© un paper: cordes, vents, percussi√≥. El director coordina totes les seccions, per√≤ cada m√∫sic es concentra en la seva part. Si cada m√∫sic hagu√©s de tocar tots els instruments alhora, el resultat seria ca√≤tic. De la mateixa manera, cada capa del codi se centra en la seva responsabilitat mentre el framework coordina la comunicaci√≥.</p>

<p><strong>Sistema de transport amb especialitzaci√≥</strong></p>
<p>El sistema de transport separa responsabilitats: trens de mercaderies mouen mat√®ries (capa de dades), f√†briques processen materials (capa de l√≤gica), botigues venen productes finals (capa de presentaci√≥). Cada actor est√† especialitzat. Si una botiga hagu√©s de fabricar i transportar tot, seria ineficient. La separaci√≥ de responsabilitats fa que cada part sigui eficient en la seva tasca.</p>
  {% endcapture %}
  {% include section-point.html numero="3.3" titol="Model mental" contingut=section_point_3_3 %}

  {% capture section_point_3_4 %}
<h4>3.4.1. Objectiu</h4>
<p>Comprendre el principi de responsabilitat √∫nica (Single Responsibility Principle - SRP) i per qu√® √©s fonamental en arquitectura de programari.</p>

<h4>3.4.2. Definici√≥ del principi</h4>
<p>El principi de responsabilitat √∫nica estableix que cada classe, funci√≥ o m√≤dul ha de tenir una √∫nica ra√≥ per canviar. Aix√≤ significa que cada pe√ßa de codi fa una sola cosa i la fa b√©. Si una classe gestiona dades d'usuari, nom√©s fa aix√≤; no hauria de validar formularis, comunicar-se amb APIs, i mostrar interf√≠cie simult√†niament.</p>

<p>Aquest principi prov√© dels principis SOLID de disseny orientat a objectes i √©s la base de l'arquitectura neta.</p>

<h4>3.4.3. Per qu√® "una √∫nica ra√≥ per canviar"</h4>
<p>Penseu en les raons per les quals modificar√≠eu codi:</p>
<ul>
  <li>Canvia el disseny visual ‚Üí Modifiqueu components de presentaci√≥</li>
  <li>Canvia una regla de negoci ‚Üí Modifiqueu serveis de l√≤gica</li>
  <li>Canvia l'API backend ‚Üí Modifiqueu serveis d'acc√©s a dades</li>
</ul>

<p>Si un component t√© codi de presentaci√≥, l√≤gica i acc√©s a dades, qualsevol dels tres canvis anteriors el for√ßar√† a modificar-se. Aix√≤ incrementa el risc d'errors: un canvi visual innocent pot trencar accidentalment la l√≤gica de negoci.</p>

<h4>3.4.4. Exemple pr√†ctic: Component que viola SRP</h4>
{% capture code_60 %}{% raw %}export class UserProfileComponent {
  user: User;

  ngOnInit() {
    // Responsabilitat 1: Acc√©s a dades
    this.http.get('/api/user/123').subscribe(data => {
      // Responsabilitat 2: Transformaci√≥ de dades
      this.user = this.transformDTO(data);
      // Responsabilitat 3: Validaci√≥
      if (!this.isValid(this.user)) {
        // Responsabilitat 4: Gesti√≥ d'errors UI
        this.showError('Dades inv√†lides');
      }
    });
  }

  // Responsabilitat 5: L√≤gica de negoci
  calculateAge(birthDate: Date): number {
    return new Date().getFullYear() - birthDate.getFullYear();
  }

  // Responsabilitat 6: Presentaci√≥
  // Template amb l√≤gica complexa barrejada
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_60 %}

<p>Aquest component t√© 6 responsabilitats diferents. Qualsevol canvi (API, validaci√≥, c√†lcul d'edat, disseny) requereix tocar aquest component.</p>

<h4>3.4.5. Aplicant SRP: Una classe, una responsabilitat</h4>
{% capture code_61 %}{% raw %}// UserDataService: NOM√âS acc√©s a dades
@Injectable({ providedIn: 'root' })
export class UserDataService {
  getUser(id: number): Observable<User> {
    return this.http.get<UserDTO>(`/api/user/${id}`)
      .pipe(map(dto => this.transformDTO(dto)));
  }
}

// UserValidationService: NOM√âS validaci√≥
@Injectable({ providedIn: 'root' })
export class UserValidationService {
  isValid(user: User): boolean {
    return user.name && user.email && user.birthDate;
  }
}

// UserProfileComponent: NOM√âS presentaci√≥
export class UserProfileComponent {
  user$ = this.userData.getUser(123);

  constructor(private userData: UserDataService) {}
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_61 %}

<p>Ara cada classe t√© una √∫nica responsabilitat i una √∫nica ra√≥ per canviar.</p>

{% include success_box.html contingut="<strong>Clau:</strong> El principi de responsabilitat √∫nica exigeix que cada classe tingui una √∫nica ra√≥ per canviar, separant presentaci√≥, l√≤gica i acc√©s a dades." %}

<h4>3.4.6. Resultat esperat</h4>
<p>L'alumnat compr√®n el principi de responsabilitat √∫nica i identifica quan una classe t√© m√∫ltiples responsabilitats que haurien de separar-se.</p>
  {% endcapture %}
  {% include section-point.html numero="3.4" titol="Principi de responsabilitat √∫nica: cada pe√ßa fa una cosa" contingut=section_point_3_4 %}

  {% capture section_point_3_5 %}
<h4>3.5.1. Objectiu</h4>
<p>Identificar les tres capes principals d'una aplicaci√≥ i comprendre les responsabilitats de cadascuna.</p>

<h4>3.5.2. Les tres capes fonamentals</h4>
<p><strong>1. Capa de presentaci√≥ (Components)</strong></p>
<ul>
  <li>Responsabilitat: Mostrar informaci√≥ a l'usuari i capturar interaccions</li>
  <li>Qu√® fa: Renderitza HTML, gestiona esdeveniments (clicks, canvis), mostra estat visual</li>
  <li>Qu√® NO fa: Validacions complexes, c√†lculs de negoci, comunicaci√≥ amb APIs</li>
</ul>

<p><strong>2. Capa de l√≤gica de negoci (Serveis)</strong></p>
<ul>
  <li>Responsabilitat: Aplicar regles de negoci, validacions, c√†lculs i processament</li>
  <li>Qu√® fa: Valida dades, calcula descomptes, aplica regles, transforma informaci√≥</li>
  <li>Qu√® NO fa: Renderitzar HTML, fer peticions HTTP directes</li>
</ul>

<p><strong>3. Capa d'acc√©s a dades (Serveis de dades)</strong></p>
<ul>
  <li>Responsabilitat: Comunicar-se amb APIs externes, bases de dades, localStorage</li>
  <li>Qu√® fa: Peticions HTTP, transformaci√≥ DTO ‚Üî Model, gesti√≥ d'errors d'API</li>
  <li>Qu√® NO fa: Aplicar regles de negoci, mostrar interf√≠cie</li>
</ul>

<h4>3.5.3. Flux de dades entre capes</h4>
{% capture code_62 %}Usuario interact√∫a
    ‚Üì
CAPA PRESENTACI√ì (Component)
    ‚Üí Crida servei de l√≤gica
    ‚Üì
CAPA L√íGICA (Business Service)
    ‚Üí Valida, processa
    ‚Üí Crida servei de dades
    ‚Üì
CAPA DADES (Data Service)
    ‚Üí Obt√© dades d'API
    ‚Üì
Dades retornen cap amunt
    ‚Üì
Component mostra dades{% endcapture %}
{% include code-block.html lang="text" code=code_62 %}

<p>Les dades sempre flueixen en una direcci√≥ clara: usuari ‚Üí presentaci√≥ ‚Üí l√≤gica ‚Üí dades ‚Üí l√≤gica ‚Üí presentaci√≥ ‚Üí usuari.</p>

<h4>3.5.4. Exemple d'organitzaci√≥ en carpetes</h4>
{% capture code_63 %}src/app/
‚îú‚îÄ‚îÄ components/              # CAPA PRESENTACI√ì
‚îÇ   ‚îú‚îÄ‚îÄ product-list/
‚îÇ   ‚îú‚îÄ‚îÄ product-card/
‚îÇ   ‚îî‚îÄ‚îÄ product-detail/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ business/            # CAPA L√íGICA
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ discount.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ calculation.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ data/                # CAPA DADES
‚îÇ       ‚îú‚îÄ‚îÄ product-data.service.ts
‚îÇ       ‚îú‚îÄ‚îÄ user-data.service.ts
‚îÇ       ‚îî‚îÄ‚îÄ order-data.service.ts
‚îî‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ product.model.ts
    ‚îî‚îÄ‚îÄ user.model.ts{% endcapture %}
{% include code-block.html lang="text" code=code_63 %}

<p>Aquesta estructura fa evident quina √©s la responsabilitat de cada fitxer.</p>

<h4>3.5.5. Avantatges de l'arquitectura en capes</h4>
<table>
<thead>
<tr>
<th>Avantatge</th>
<th>Benefici pr√†ctic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Canvis localitzats</strong></td>
<td>Modificar API nom√©s afecta capa de dades</td>
</tr>
<tr>
<td><strong>Reutilitzaci√≥</strong></td>
<td>M√∫ltiples components usen mateix servei de l√≤gica</td>
</tr>
<tr>
<td><strong>Proves senzilles</strong></td>
<td>Testejar cada capa independentment</td>
</tr>
<tr>
<td><strong>Escalabilitat</strong></td>
<td>Afegir funcionalitats sense tocar codi existent</td>
</tr>
<tr>
<td><strong>Treball en equip</strong></td>
<td>Diferents desenvolupadors treballen en capes diferents</td>
</tr>
</tbody>
</table>

<h4>3.5.6. Errors comuns a evitar</h4>
<p><strong>Error 1: Component accedeix directament a HttpClient</strong></p>
{% capture code_64 %}{% raw %}// MAL: Component fa peticions HTTP
export class ProductListComponent {
  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get('/api/products').subscribe(...)
  }
}

// B√â: Component usa servei de dades
export class ProductListComponent {
  constructor(private productData: ProductDataService) {}

  ngOnInit() {
    this.productData.getProducts().subscribe(...)
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_64 %}

<p><strong>Error 2: Servei d'acc√©s a dades cont√© l√≤gica de negoci</strong></p>
{% capture code_65 %}{% raw %}// MAL: Servei de dades calcula descomptes
export class ProductDataService {
  getProducts(): Observable<Product[]> {
    return this.http.get('/api/products').pipe(
      map(products => products.map(p => {
        p.discount = this.calculateDiscount(p); // L√≤gica de negoci aqu√≠
        return p;
      }))
    );
  }
}

// B√â: Separar en dos serveis
export class ProductDataService {
  getProducts(): Observable<Product[]> {
    return this.http.get('/api/products');
  }
}

export class DiscountService {
  calculateDiscount(product: Product): number {
    // L√≤gica de negoci en servei dedicat
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_65 %}

{% include success_box.html contingut="<strong>Clau:</strong> Les aplicacions s'organitzen en tres capes amb responsabilitats clares: presentaci√≥ (components), l√≤gica (serveis de negoci), i dades (serveis d'acc√©s a APIs)." %}

<h4>3.5.7. Resultat esperat</h4>
<p>L'alumnat identifica les tres capes principals d'una aplicaci√≥ i compr√®n les responsabilitats espec√≠fiques de cadascuna.</p>
  {% endcapture %}
  {% include section-point.html numero="3.5" titol="Capes d'una aplicaci√≥: presentaci√≥, l√≤gica de negoci, dades" contingut=section_point_3_5 %}

  {% capture section_point_3_6 %}
<h4>3.6.1. Objectiu</h4>
<p>Aprendre a crear components presentacionals purs que nom√©s es dediquen a mostrar dades i capturar interaccions de l'usuari.</p>

<h4>3.6.2. Responsabilitats d'un component presentacional</h4>
<p>Un component presentacional pur:</p>
<ul>
  <li>Rep dades via <code>@Input()</code> o observables</li>
  <li>Mostra les dades amb interpolaci√≥ i directives</li>
  <li>Captura esdeveniments d'usuari (click, change, submit)</li>
  <li>Emet esdeveniments via <code>@Output()</code> per notificar accions</li>
  <li><strong>NO</strong> cont√© l√≤gica de negoci, c√†lculs, validacions complexes ni peticions HTTP</li>
</ul>

<h4>3.6.3. Exemple: Component presentacional pur</h4>
{% capture code_66 %}{% raw %}@Component({
  selector: 'app-product-card',
  template: `
    <div class="card">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨</p>
      <p class="discount" *ngIf="discount > 0">Descompte: {{ discount }}%</p>
      <button (click)="onAddToCart()">Afegir a cistella</button>
    </div>
  `
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter<Product>();

  onAddToCart(): void {
    this.addToCart.emit(this.product);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_66 %}

<p>Aquest component:</p>
<ul>
  <li>Rep dades (<code>product</code>, <code>discount</code>) via <code>@Input()</code></li>
  <li>Les mostra al template</li>
  <li>Captura el clic del bot√≥</li>
  <li>Emet un esdeveniment perqu√® el component pare gestioni l'acci√≥</li>
  <li><strong>NO</strong> calcula el descompte ni fa peticions HTTP</li>
</ul>

<h4>3.6.4. Beneficis dels components presentacionals</h4>
<p><strong>1. F√†cils de testejar</strong></p>
{% capture code_67 %}{% raw %}// Test: passar dades simulades i verificar renderitzat
it('should display product name', () => {
  component.product = { name: 'Test Product', price: 10, stock: 5 };
  fixture.detectChanges();
  expect(fixture.nativeElement.textContent).toContain('Test Product');
});{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_67 %}

<p>No cal simular serveis ni HttpClient; nom√©s passeu dades i verifiqueu el resultat visual.</p>

<p><strong>2. Reutilitzables en m√∫ltiples contextos</strong></p>
<p>El mateix <code>ProductCardComponent</code> es pot usar a:</p>
<ul>
  <li>Llista de productes</li>
  <li>Cerca de productes</li>
  <li>Productes relacionats</li>
  <li>Preferits</li>
</ul>

<p>Cada context passa les dades necess√†ries via <code>@Input()</code> i gestiona els esdeveniments via <code>@Output()</code>.</p>

<p><strong>3. Independents de la font de dades</strong></p>
<p>El component no sap d'on v√©nen les dades (API, localStorage, estat centralitzat, dades simulades). Nom√©s rep un objecte <code>Product</code> i el mostra. Aix√≤ fa el component totalment desacoblat de la infraestructura.</p>

<h4>3.6.5. Patr√≥ contenidor vs presentacional</h4>
<p><strong>Component contenidor (smart):</strong></p>
<ul>
  <li>Gestiona estat i l√≤gica</li>
  <li>Obt√© dades de serveis</li>
  <li>Passa dades als components presentacionals</li>
  <li>Gestiona esdeveniments dels components fills</li>
</ul>

<p><strong>Component presentacional (dumb):</strong></p>
<ul>
  <li>Rep dades via <code>@Input()</code></li>
  <li>Mostra dades</li>
  <li>Emet esdeveniments via <code>@Output()</code></li>
  <li>Sense l√≤gica de negoci</li>
</ul>

{% capture code_68 %}{% raw %}// COMPONENT CONTENIDOR (smart)
@Component({
  selector: 'app-product-list-container',
  template: `
    <app-product-card
      *ngFor="let product of products$ | async"
      [product]="product"
      [discount]="getDiscount(product)"
      (addToCart)="handleAddToCart($event)">
    </app-product-card>
  `
})
export class ProductListContainerComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private cart: CartService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculate(product.stock);
  }

  handleAddToCart(product: Product): void {
    this.cart.add(product);
  }
}

// COMPONENT PRESENTACIONAL (dumb)
@Component({
  selector: 'app-product-card',
  template: `...` // Nom√©s mostra dades rebudes
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter<Product>();
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_68 %}

{% include success_box.html contingut="<strong>Clau:</strong> Els components presentacionals nom√©s mostren dades rebudes via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code>, sense l√≤gica de negoci ni acc√©s a dades." %}

<h4>3.6.6. Resultat esperat</h4>
<p>L'alumnat crea components presentacionals purs que separen clarament la responsabilitat de presentaci√≥ de la l√≤gica de negoci.</p>
  {% endcapture %}
  {% include section-point.html numero="3.6" titol="Components (presentaci√≥): nom√©s mostrar i capturar interaccions" contingut=section_point_3_6 %}

  {% capture section_point_3_7 %}
<h4>3.7.1. Objectiu</h4>
<p>Aprendre a crear serveis de l√≤gica de negoci que encapsulen regles, validacions i processament de dades.</p>

<h4>3.7.2. Responsabilitats d'un servei de l√≤gica</h4>
<p>Un servei de l√≤gica de negoci:</p>
<ul>
  <li>Aplica regles de negoci (descomptes, comissions, c√†lculs)</li>
  <li>Valida dades abans d'enviar-les a l'API</li>
  <li>Transforma dades entre formats</li>
  <li>Implementa algoritmes i processament complex</li>
  <li><strong>NO</strong> fa peticions HTTP ni renderitza interf√≠cie</li>
</ul>

<h4>3.7.3. Exemple: Servei de c√†lcul de descomptes</h4>
{% capture code_69 %}{% raw %}@Injectable({ providedIn: 'root' })
export class DiscountService {

  calculateDiscount(product: Product): number {
    // Regla 1: Descompte per stock alt
    if (product.stock > 100) return 20;
    if (product.stock > 50) return 10;
    if (product.stock > 10) return 5;

    // Regla 2: Descompte per categoria
    if (product.category === 'clearance') return 30;

    // Regla 3: Sense descompte
    return 0;
  }

  applyDiscount(price: number, discountPercent: number): number {
    return price * (1 - discountPercent / 100);
  }

  calculateFinalPrice(product: Product): number {
    const discount = this.calculateDiscount(product);
    return this.applyDiscount(product.price, discount);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_69 %}

<p>Aquest servei encapsula tota la l√≤gica de descomptes. Si les regles canvien (per exemple, afegir descompte per client VIP), nom√©s cal modificar aquest servei, no 20 components diferents.</p>

<h4>3.7.4. Exemple: Servei de validaci√≥</h4>
{% capture code_70 %}{% raw %}@Injectable({ providedIn: 'root' })
export class ProductValidationService {

  validateProduct(product: Product): ValidationResult {
    const errors: string[] = [];

    if (!product.name || product.name.trim().length < 3) {
      errors.push('El nom ha de tenir almenys 3 car√†cters');
    }

    if (product.price <= 0) {
      errors.push('El preu ha de ser superior a 0');
    }

    if (product.stock < 0) {
      errors.push('L\'stock no pot ser negatiu');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  canBeSold(product: Product): boolean {
    return product.stock > 0 && product.price > 0;
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_70 %}

<h4>3.7.5. Reutilitzaci√≥ de serveis de l√≤gica</h4>
<p>El mateix servei es pot usar des de m√∫ltiples components:</p>

{% capture code_71 %}{% raw %}// En component de llista
export class ProductListComponent {
  constructor(private discount: DiscountService) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }
}

// En component de detall
export class ProductDetailComponent {
  constructor(private discount: DiscountService) {}

  finalPrice$ = this.product$.pipe(
    map(product => this.discount.calculateFinalPrice(product))
  );
}

// En component de cistella
export class CartComponent {
  constructor(private discount: DiscountService) {}

  getTotalWithDiscounts(): number {
    return this.items.reduce((sum, item) => {
      const finalPrice = this.discount.calculateFinalPrice(item.product);
      return sum + (finalPrice * item.quantity);
    }, 0);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_71 %}

<p>Tres components diferents usen el mateix servei, garantint consist√®ncia. Si canvia la l√≤gica de descomptes, nom√©s cal modificar el servei.</p>

<h4>3.7.6. Proves unit√†ries de serveis de l√≤gica</h4>
<p>Els serveis de l√≤gica s√≥n extremadament f√†cils de testejar perqu√® no tenen depend√®ncies externes:</p>

{% capture code_72 %}{% raw %}describe('DiscountService', () => {
  let service: DiscountService;

  beforeEach(() => {
    service = new DiscountService();
  });

  it('should calculate 20% discount for stock > 100', () => {
    const product = { name: 'Test', price: 100, stock: 150, category: 'normal' };
    expect(service.calculateDiscount(product)).toBe(20);
  });

  it('should calculate 30% discount for clearance category', () => {
    const product = { name: 'Test', price: 100, stock: 5, category: 'clearance' };
    expect(service.calculateDiscount(product)).toBe(30);
  });

  it('should apply discount correctly', () => {
    expect(service.applyDiscount(100, 20)).toBe(80);
    expect(service.applyDiscount(50, 10)).toBe(45);
  });
});{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_72 %}

<p>Proves netes, r√†pides, sense mocks complexos.</p>

{% include success_box.html contingut="<strong>Clau:</strong> Els serveis de l√≤gica de negoci encapsulen regles, validacions i c√†lculs, permetent reutilitzaci√≥, consist√®ncia i proves unit√†ries senzilles." %}

<h4>3.7.7. Resultat esperat</h4>
<p>L'alumnat crea serveis de l√≤gica de negoci amb regles, validacions i processament separats dels components i l'acc√©s a dades.</p>
  {% endcapture %}
  {% include section-point.html numero="3.7" titol="Serveis (l√≤gica): processament, regles de negoci" contingut=section_point_3_7 %}

  {% capture section_point_3_8 %}
<h4>3.8.1. Objectiu</h4>
<p>Aprendre a crear serveis d'acc√©s a dades que encapsulen tota la comunicaci√≥ amb APIs externes.</p>

<h4>3.8.2. Responsabilitats d'un servei d'acc√©s a dades</h4>
<p>Un servei d'acc√©s a dades (data service o repository):</p>
<ul>
  <li>Fa peticions HTTP a APIs (GET, POST, PUT, DELETE)</li>
  <li>Transforma DTOs (Data Transfer Objects) de l'API a models interns</li>
  <li>Gestiona errors HTTP i retry logic</li>
  <li>Encapsula la URL base i endpoints de l'API</li>
  <li><strong>NO</strong> cont√© l√≤gica de negoci ni renderitza interf√≠cie</li>
</ul>

<h4>3.8.3. Exemple: Servei d'acc√©s a dades complet</h4>
{% capture code_73 %}{% raw %}// Interf√≠cie DTO (el que retorna l'API)
interface ProductDTO {
  product_id: number;
  product_name: string;
  price_cents: number;
  available_quantity: number;
}

// Model intern (el que usa l'aplicaci√≥)
export interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

// Servei d'acc√©s a dades
@Injectable({ providedIn: 'root' })
export class ProductDataService {
  private apiUrl = 'https://api.example.com';

  constructor(private http: HttpClient) {}

  getProducts(): Observable<Product[]> {
    return this.http.get<{ data: ProductDTO[] }>(`${this.apiUrl}/products`)
      .pipe(
        map(response => response.data.map(dto => this.mapDTOToModel(dto))),
        catchError(this.handleError)
      );
  }

  getProduct(id: number): Observable<Product> {
    return this.http.get<ProductDTO>(`${this.apiUrl}/products/${id}`)
      .pipe(
        map(dto => this.mapDTOToModel(dto)),
        catchError(this.handleError)
      );
  }

  createProduct(product: Product): Observable<Product> {
    const dto = this.mapModelToDTO(product);
    return this.http.post<ProductDTO>(`${this.apiUrl}/products`, dto)
      .pipe(
        map(dto => this.mapDTOToModel(dto)),
        catchError(this.handleError)
      );
  }

  private mapDTOToModel(dto: ProductDTO): Product {
    return {
      id: dto.product_id,
      name: dto.product_name,
      price: dto.price_cents / 100,
      stock: dto.available_quantity
    };
  }

  private mapModelToDTO(product: Product): ProductDTO {
    return {
      product_id: product.id,
      product_name: product.name,
      price_cents: product.price * 100,
      available_quantity: product.stock
    };
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    console.error('Error en petici√≥ HTTP:', error);
    return throwError(() => new Error('Error en comunicaci√≥ amb API'));
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_73 %}

<h4>3.8.4. Avantatges de la capa d'acc√©s a dades</h4>
<p><strong>1. Desacoblament del backend</strong></p>
<p>Els components i serveis de l√≤gica treballen amb models interns (<code>Product</code>), no amb DTOs de l'API. Si l'API canvia el format de resposta, nom√©s cal modificar el servei d'acc√©s a dades, no tot el codi:</p>

{% capture code_74 %}{% raw %}// Abans: API retorna `product_name`
// Despr√©s: API retorna `name`

// Nom√©s cal canviar:
private mapDTOToModel(dto: ProductDTO): Product {
  return {
    id: dto.product_id,
    name: dto.name, // ‚Üê √önic canvi necessari
    price: dto.price_cents / 100,
    stock: dto.available_quantity
  };
}

// Tot el codi de components i l√≤gica segueix funcionant sense canvis{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_74 %}

<p><strong>2. Facilitat per canviar el backend</strong></p>
<p>Si decidiu canviar de REST a GraphQL o WebSockets, nom√©s cal modificar els serveis d'acc√©s a dades. Els components i l√≤gica no saben com s'obtenen les dades:</p>

{% capture code_75 %}{% raw %}// Versi√≥ REST
getProducts(): Observable<Product[]> {
  return this.http.get<ProductDTO[]>(`${this.apiUrl}/products`)
    .pipe(map(dtos => dtos.map(dto => this.mapDTOToModel(dto))));
}

// Versi√≥ GraphQL (nom√©s canvia implementaci√≥ del servei)
getProducts(): Observable<Product[]> {
  return this.apollo.query({ query: GET_PRODUCTS_QUERY })
    .pipe(map(result => result.data.products.map(dto => this.mapDTOToModel(dto))));
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_75 %}

<p><strong>3. Gesti√≥ centralitzada d'errors</strong></p>
<p>Tota la gesti√≥ d'errors HTTP est√† en un √∫nic lloc. Podeu implementar retry logic, logging, o notificacions d'error de manera consistent:</p>

{% capture code_76 %}{% raw %}private handleError(error: HttpErrorResponse): Observable<never> {
  // Logging centralitzat
  this.logger.error('Error HTTP', error);

  // Notificaci√≥ a l'usuari
  this.notificationService.showError('Error en carregar dades');

  // Retry logic si cal
  return throwError(() => new Error('Error en API'));
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_76 %}

<h4>3.8.5. Proves unit√†ries de serveis d'acc√©s a dades</h4>
<p>Els serveis d'acc√©s a dades es proven amb <code>HttpClientTestingModule</code>:</p>

{% capture code_77 %}{% raw %}describe('ProductDataService', () => {
  let service: ProductDataService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [ProductDataService]
    });
    service = TestBed.inject(ProductDataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should transform DTO to model correctly', () => {
    const mockDTO = {
      product_id: 1,
      product_name: 'Test',
      price_cents: 1000,
      available_quantity: 5
    };

    service.getProduct(1).subscribe(product => {
      expect(product.id).toBe(1);
      expect(product.name).toBe('Test');
      expect(product.price).toBe(10); // 1000 cents ‚Üí 10 euros
      expect(product.stock).toBe(5);
    });

    const req = httpMock.expectOne('https://api.example.com/products/1');
    req.flush(mockDTO);
  });
});{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_77 %}

{% include success_box.html contingut="<strong>Clau:</strong> Els serveis d'acc√©s a dades encapsulen tota la comunicaci√≥ amb APIs, transformant DTOs a models interns i gestionant errors de manera centralitzada." %}

<h4>3.8.6. Resultat esperat</h4>
<p>L'alumnat crea serveis d'acc√©s a dades que separen la comunicaci√≥ HTTP de la l√≤gica de negoci i components.</p>
  {% endcapture %}
  {% include section-point.html numero="3.8" titol="Capa de dades: comunicaci√≥ amb serveis web (APIs), adaptaci√≥" contingut=section_point_3_8 %}

  {% capture section_point_3_9 %}
<h4>3.9.1. Objectiu</h4>
<p>Aplicar tots els conceptes anteriors refactoritzant un component barrejat en una arquitectura en capes clara.</p>

<h4>3.9.2. Component original (barrejat)</h4>
{% capture code_78 %}{% raw %}@Component({
  selector: 'app-product-list',
  template: `
    <div *ngFor="let product of products">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨ - Descompte: {{ calculateDiscount(product) }}%</p>
      <button (click)="addToCart(product)" [disabled]="!canBeSold(product)">
        Afegir
      </button>
    </div>
  `
})
export class ProductListComponent implements OnInit {
  products: Product[] = [];
  cart: Product[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // Acc√©s a dades + transformaci√≥
    this.http.get<any>('https://api.example.com/products').subscribe(
      response => {
        this.products = response.data.map((item: any) => ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        }));
      }
    );
  }

  // L√≤gica de negoci: c√†lcul descomptes
  calculateDiscount(product: Product): number {
    if (product.stock > 100) return 20;
    if (product.stock > 50) return 10;
    return 0;
  }

  // L√≤gica de negoci: validaci√≥
  canBeSold(product: Product): boolean {
    return product.stock > 0;
  }

  // Gesti√≥ d'estat
  addToCart(product: Product) {
    this.cart.push(product);
    localStorage.setItem('cart', JSON.stringify(this.cart));
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_78 %}

<p>Aquest component fa massa coses: acc√©s a dades, transformaci√≥ DTO, l√≤gica de descomptes, validaci√≥, i gesti√≥ de cistella.</p>

<h4>3.9.3. Pas 1: Crear servei d'acc√©s a dades</h4>
{% capture code_79 %}{% raw %}@Injectable({ providedIn: 'root' })
export class ProductDataService {
  private apiUrl = 'https://api.example.com';

  constructor(private http: HttpClient) {}

  getProducts(): Observable<Product[]> {
    return this.http.get<{ data: any[] }>(`${this.apiUrl}/products`)
      .pipe(
        map(response => response.data.map(item => ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        })))
      );
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_79 %}

<h4>3.9.4. Pas 2: Crear serveis de l√≤gica</h4>
{% capture code_80 %}{% raw %}@Injectable({ providedIn: 'root' })
export class DiscountService {
  calculateDiscount(product: Product): number {
    if (product.stock > 100) return 20;
    if (product.stock > 50) return 10;
    return 0;
  }
}

@Injectable({ providedIn: 'root' })
export class ProductValidationService {
  canBeSold(product: Product): boolean {
    return product.stock > 0;
  }
}

@Injectable({ providedIn: 'root' })
export class CartService {
  private cart: Product[] = [];

  add(product: Product): void {
    this.cart.push(product);
    localStorage.setItem('cart', JSON.stringify(this.cart));
  }

  getCart(): Product[] {
    return this.cart;
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_80 %}

<h4>3.9.5. Pas 3: Refactoritzar component (nom√©s presentaci√≥)</h4>
{% capture code_81 %}{% raw %}@Component({
  selector: 'app-product-list',
  template: `
    <div *ngFor="let product of products$ | async">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨ - Descompte: {{ getDiscount(product) }}%</p>
      <button (click)="addToCart(product)" [disabled]="!canBeSold(product)">
        Afegir
      </button>
    </div>
  `
})
export class ProductListComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private validation: ProductValidationService,
    private cart: CartService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }

  canBeSold(product: Product): boolean {
    return this.validation.canBeSold(product);
  }

  addToCart(product: Product): void {
    this.cart.add(product);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_81 %}

<h4>3.9.6. Resultats de la refactoritzaci√≥</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Abans</th>
<th>Despr√©s</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>L√≠nies al component</strong></td>
<td>80</td>
<td>30</td>
</tr>
<tr>
<td><strong>Responsabilitats</strong></td>
<td>6 en 1 classe</td>
<td>1 per classe (5 classes)</td>
</tr>
<tr>
<td><strong>Reutilitzaci√≥</strong></td>
<td>Impossible</td>
<td>F√†cil (injectar serveis)</td>
</tr>
<tr>
<td><strong>Proves</strong></td>
<td>Molt dif√≠cils</td>
<td>Senzilles (cada servei independent)</td>
</tr>
<tr>
<td><strong>Mantenibilitat</strong></td>
<td>Baixa (tot barrejat)</td>
<td>Alta (cada capa independent)</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> Refactoritzar components barrejats en capes separades redueix l√≠nies de codi per fitxer, millora testabilitat, i permet reutilitzaci√≥ de l√≤gica." %}

<h4>3.9.7. Resultat esperat</h4>
<p>L'alumnat aplica la separaci√≥ de responsabilitats refactoritzant components barrejats en arquitectura de capes clara i mantenible.</p>
  {% endcapture %}
  {% include section-point.html numero="3.9" titol="Exemple pr√†ctic: refactoritzar component barrejat en capes separades" contingut=section_point_3_9 %}

  {% capture section_point_3_10 %}
<h4>3.10.1. Objectiu</h4>
<p>Quantificar i comprendre els beneficis pr√†ctics de la separaci√≥ de responsabilitats en capes.</p>

<h4>3.10.2. Benefici 1: Proves unit√†ries m√©s senzilles</h4>
<p><strong>Sense separaci√≥ de capes:</strong></p>
{% capture code_82 %}{% raw %}// Per provar c√†lcul de descompte necessites:
TestBed.configureTestingModule({
  imports: [HttpClientTestingModule],
  declarations: [ProductListComponent],
  providers: [...]
});
// Simular HttpClient, localStorage, events...
// 50 l√≠nies de setup per provar 1 funci√≥{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_82 %}

<p><strong>Amb separaci√≥ de capes:</strong></p>
{% capture code_83 %}{% raw %}// Per provar c√†lcul de descompte:
const service = new DiscountService();
expect(service.calculateDiscount(product)).toBe(20);
// 2 l√≠nies, zero mocks{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_83 %}

<p><strong>Comparativa quantitativa:</strong></p>
<ul>
  <li>Temps per escriure test: 15 minuts ‚Üí 2 minuts (87% m√©s r√†pid)</li>
  <li>L√≠nies de codi de test: 50 ‚Üí 5 (90% menys)</li>
  <li>Temps d'execuci√≥ del test: 500ms ‚Üí 5ms (99% m√©s r√†pid)</li>
</ul>

<h4>3.10.3. Benefici 2: Canvis localitzats i risc redu√Øt</h4>
<p><strong>Sense separaci√≥:</strong></p>
<ul>
  <li>Canviar regla de descompte: Modificar 5 components diferents</li>
  <li>Canviar API: Modificar 15 components que fan peticions HTTP</li>
  <li>Risc d'error: Alt (tocar m√∫ltiples fitxers)</li>
</ul>

<p><strong>Amb separaci√≥:</strong></p>
<ul>
  <li>Canviar regla de descompte: Modificar 1 servei (<code>DiscountService</code>)</li>
  <li>Canviar API: Modificar 1 servei (<code>ProductDataService</code>)</li>
  <li>Risc d'error: Baix (tocar √∫nic fitxer responsable)</li>
</ul>

<p><strong>Exemple real:</strong></p>
<p>L'API canvia el format de preus de <code>price_cents</code> a <code>price_euros</code>:</p>

{% capture code_84 %}{% raw %}// Sense separaci√≥: Canviar 15 components
// Component 1
this.products = response.data.map(item => ({ price: item.price_cents / 100 }));
// Component 2
this.products = response.data.map(item => ({ price: item.price_cents / 100 }));
// ... 13 components m√©s amb el mateix codi duplicat

// Amb separaci√≥: Canviar 1 servei
@Injectable({ providedIn: 'root' })
export class ProductDataService {
  private mapDTOToModel(dto: ProductDTO): Product {
    return {
      price: dto.price_euros // ‚Üê √önic canvi necessari
    };
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_84 %}

<h4>3.10.4. Benefici 3: Reutilitzaci√≥ de l√≤gica</h4>
<p><strong>Sense separaci√≥:</strong></p>
<ul>
  <li>L√≤gica de descomptes copiada en 5 components</li>
  <li>Total: 5 √ó 15 l√≠nies = 75 l√≠nies duplicades</li>
  <li>Canviar l√≤gica: Modificar 5 fitxers</li>
</ul>

<p><strong>Amb separaci√≥:</strong></p>
<ul>
  <li>L√≤gica de descomptes en 1 servei</li>
  <li>Total: 1 √ó 15 l√≠nies = 15 l√≠nies</li>
  <li>Canviar l√≤gica: Modificar 1 fitxer</li>
</ul>

<p><strong>Estalvi:</strong> 60 l√≠nies de codi duplicat (80% reducci√≥).</p>

<h4>3.10.5. Benefici 4: Facilitat per afegir funcionalitats</h4>
<p>Afegir nova regla de negoci "descompte per client VIP":</p>

<p><strong>Sense separaci√≥:</strong></p>
<ol>
  <li>Identificar tots els components que calculen descomptes (30 minuts)</li>
  <li>Modificar cada component individualment (2 hores)</li>
  <li>Provar cada component (1 hora)</li>
</ol>
<p><strong>Total: 3.5 hores</strong></p>

<p><strong>Amb separaci√≥:</strong></p>
<ol>
  <li>Modificar <code>DiscountService.calculateDiscount()</code> (15 minuts)</li>
  <li>Provar el servei (5 minuts)</li>
</ol>
<p><strong>Total: 20 minuts</strong></p>

<p><strong>Millora: 90% m√©s r√†pid.</strong></p>

<h4>3.10.6. Taula resum de beneficis quantificats</h4>
<table>
<thead>
<tr>
<th>Benefici</th>
<th>Sense separaci√≥</th>
<th>Amb separaci√≥</th>
<th>Millora</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Temps escriure test</strong></td>
<td>15 min</td>
<td>2 min</td>
<td>87% m√©s r√†pid</td>
</tr>
<tr>
<td><strong>L√≠nies codi test</strong></td>
<td>50</td>
<td>5</td>
<td>90% menys</td>
</tr>
<tr>
<td><strong>Fitxers a modificar per canvi API</strong></td>
<td>15</td>
<td>1</td>
<td>93% menys</td>
</tr>
<tr>
<td><strong>Codi duplicat</strong></td>
<td>75 l√≠nies</td>
<td>0 l√≠nies</td>
<td>100% eliminat</td>
</tr>
<tr>
<td><strong>Temps afegir funcionalitat</strong></td>
<td>3.5 h</td>
<td>20 min</td>
<td>90% m√©s r√†pid</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> La separaci√≥ de responsabilitats en capes redueix dr√†sticament el temps de proves, canvis i noves funcionalitats, eliminant duplicaci√≥ i localitzant modificacions." %}

<h4>3.10.7. Resultat esperat</h4>
<p>L'alumnat quantifica els beneficis reals de la separaci√≥ de responsabilitats en proves, mantenibilitat i productivitat de desenvolupament.</p>
  {% endcapture %}
  {% include section-point.html numero="3.10" titol="Beneficis: proves m√©s f√†cils, canvis localitzats, reutilitzaci√≥" contingut=section_point_3_10 %}

  {% capture section_point_3_11 %}
<h4>3.11.1. Objectiu</h4>
<p>Aprendre el patr√≥ contenidor/presentacional per organitzar components en smart (contenidors) i dumb (presentacionals).</p>

<h4>3.11.2. Definici√≥ del patr√≥</h4>
<p><strong>Smart components (contenidors):</strong></p>
<ul>
  <li>Gestionen estat i l√≤gica</li>
  <li>Injecten i usen serveis</li>
  <li>Obtenen dades d'APIs</li>
  <li>Passen dades a components fills via <code>@Input()</code></li>
  <li>Gestionen esdeveniments de components fills via <code>@Output()</code></li>
</ul>

<p><strong>Dumb components (presentacionals):</strong></p>
<ul>
  <li>Reben dades via <code>@Input()</code></li>
  <li>Mostren dades amb interpolaci√≥</li>
  <li>Emeten esdeveniments via <code>@Output()</code></li>
  <li>No injecten serveis</li>
  <li>Totalment reutilitzables i testejables</li>
</ul>

<h4>3.11.3. Exemple complet del patr√≥</h4>
<p><strong>Component presentacional (dumb):</strong></p>
{% capture code_85 %}{% raw %}@Component({
  selector: 'app-product-card',
  template: `
    <div class="card">
      <h3>{{ product.name }}</h3>
      <p>{{ product.price }}‚Ç¨</p>
      <span class="discount" *ngIf="discount > 0">-{{ discount }}%</span>
      <button (click)="onAddClick()">Afegir</button>
    </div>
  `
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter<Product>();

  onAddClick(): void {
    this.addToCart.emit(this.product);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_85 %}

<p><strong>Component contenidor (smart):</strong></p>
{% capture code_86 %}{% raw %}@Component({
  selector: 'app-product-list-container',
  template: `
    <app-product-card
      *ngFor="let product of products$ | async"
      [product]="product"
      [discount]="calculateDiscount(product)"
      (addToCart)="handleAddToCart($event)">
    </app-product-card>
  `
})
export class ProductListContainerComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private cart: CartService
  ) {}

  calculateDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }

  handleAddToCart(product: Product): void {
    this.cart.add(product);
  }
}{% endraw %}{% endcapture %}
{% include code-block.html lang="typescript" code=code_86 %}

<h4>3.11.4. Avantatges del patr√≥</h4>
<ol>
  <li><strong>Components presentacionals molt reutilitzables:</strong> <code>ProductCardComponent</code> es pot usar en llista, cerca, preferits, relacionats, etc.</li>
  <li><strong>Proves senzilles:</strong> Testejar <code>ProductCardComponent</code> nom√©s requereix passar dades simulades, no serveis.</li>
  <li><strong>Separaci√≥ clara:</strong> El contenidor gestiona l√≤gica; el presentacional nom√©s mostra.</li>
  <li><strong>Canvis visuals a√Øllats:</strong> Modificar l'aparen√ßa de <code>ProductCardComponent</code> no afecta la l√≤gica del contenidor.</li>
</ol>

<h4>3.11.5. Quan usar cada tipus</h4>
<table>
<thead>
<tr>
<th>Situaci√≥</th>
<th>Component a usar</th>
</tr>
</thead>
<tbody>
<tr>
<td>Necessita accedir a serveis</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Nom√©s mostra dades rebudes</td>
<td>Dumb (presentacional)</td>
</tr>
<tr>
<td>Gestiona estat global</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Es reutilitza en m√∫ltiples contextos</td>
<td>Dumb (presentacional)</td>
</tr>
<tr>
<td>Fa peticions HTTP</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Nom√©s emet esdeveniments</td>
<td>Dumb (presentacional)</td>
</tr>
</tbody>
</table>

{% include success_box.html contingut="<strong>Clau:</strong> El patr√≥ contenidor/presentacional separa components en smart (amb l√≤gica i serveis) i dumb (nom√©s presentaci√≥), millorant reutilitzaci√≥ i testabilitat." %}

<h4>3.11.6. Resultat esperat</h4>
<p>L'alumnat aplica el patr√≥ contenidor/presentacional creant components smart que gestionen l√≤gica i components dumb que nom√©s presenten dades.</p>
  {% endcapture %}
  {% include section-point.html numero="3.11" titol="Patr√≥ de contenidor/presentacional: smart vs dumb components" contingut=section_point_3_11 %}

  {% capture section_point_3_12 %}
<p><strong>Mini exemple pr√†ctic:</strong> Component de llista amb capes separades</p>
<ol>
  <li>Crear servei d'acc√©s a dades <code>ProductDataService</code> que obt√© productes de JSONPlaceholder</li>
  <li>Crear servei de l√≤gica <code>DiscountService</code> amb m√®tode <code>calculateDiscount(stock: number)</code></li>
  <li>Crear component presentacional <code>ProductCardComponent</code> amb <code>@Input() product</code> i <code>@Output() selected</code></li>
  <li>Crear component contenidor <code>ProductListContainerComponent</code> que injecta els serveis</li>
  <li>Al contenidor, obtenir productes amb <code>products$ = this.productData.getProducts()</code></li>
  <li>Al template del contenidor, usar <code>*ngFor</code> amb <code>async</code> pipe per iterar productes</li>
  <li>Passar cada producte al <code>ProductCardComponent</code> amb <code>[product]="p"</code> i <code>[discount]="calculateDiscount(p)"</code></li>
  <li>Gestionar esdeveniment <code>(selected)</code> al contenidor per mostrar log a consola</li>
</ol>

<p><strong>Resultat esperat:</strong> Una aplicaci√≥ organitzada en capes clares on el component contenidor gestiona l√≤gica i dades mentre el component presentacional nom√©s mostra.</p>
  {% endcapture %}
  {% include section-point.html numero="3.12" titol="Mini exemple pr√†ctic ¬∑ Component de llista amb capes separades" contingut=section_point_3_12 %}

  {% capture section_point_3_13 %}
<p><strong>Resoluci√≥ de problemes (Win/macOS/Linux):</strong></p>
<table>
<thead>
<tr>
<th>S√≠mptoma</th>
<th>Possible causa</th>
<th>Soluci√≥ r√†pida</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component necessita m√∫ltiples serveis injectats</td>
<td>El component fa massa coses; hauria de ser un contenidor o dividir-se</td>
<td>Refactoritzar en component contenidor (smart) que gestiona serveis i component presentacional (dumb) que nom√©s mostra</td>
</tr>
<tr>
<td>Error "Cannot read property of undefined" en component presentacional</td>
<td>El <code>@Input()</code> no est√† rebent dades del pare o es mostra abans que arribin</td>
<td>Usar operador <code>?</code> de safe navigation (<code>product?.name</code>) o <code>*ngIf="product"</code> per esperar dades</td>
</tr>
<tr>
<td>L√≤gica de negoci duplicada en m√∫ltiples components</td>
<td>No s'ha creat servei de l√≤gica; cada component implementa la seva versi√≥</td>
<td>Crear servei <code>@Injectable</code> amb la l√≤gica i injectar-lo als components que ho necessitin</td>
</tr>
<tr>
<td>Proves unit√†ries requereixen molts mocks</td>
<td>El component t√© massa depend√®ncies; no est√† separat en capes</td>
<td>Separar l√≤gica en serveis i provar serveis independentment sense component</td>
</tr>
<tr>
<td>Canviar API requereix modificar molts components</td>
<td>Components accedeixen directament a HttpClient; no hi ha capa d'acc√©s a dades</td>
<td>Crear servei d'acc√©s a dades que encapsula HttpClient i usar-lo als components</td>
</tr>
<tr>
<td>Component de 300+ l√≠nies dif√≠cil de mantenir</td>
<td>Component t√© m√∫ltiples responsabilitats barrejades</td>
<td>Aplicar refactoritzaci√≥: separar en serveis (l√≤gica, dades) i dividir en components m√©s petits</td>
</tr>
<tr>
<td>Components no es poden reutilitzar en altres contextos</td>
<td>Components estan acoblats a serveis espec√≠fics; no s√≥n presentacionals</td>
<td>Convertir en components presentacionals amb <code>@Input/@Output</code>, sense injecci√≥ de serveis</td>
</tr>
<tr>
<td>Dificultat per trobar on canviar una regla de negoci</td>
<td>L√≤gica est√† dispersa en m√∫ltiples components</td>
<td>Centralitzar l√≤gica en servei dedicat; components nom√©s criden m√®todes del servei</td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="3.13" titol="Resoluci√≥ de problemes" contingut=section_point_3_13 %}

  {% capture section_point_3_14 %}
<p><strong>Prompts d'IA:</strong></p>

{% include prompt-ai.html contingut="<strong>Rol:</strong> Arquitecte de programari especialitzat en refactoritzaci√≥ i arquitectura neta. <strong>Context:</strong> Tinc un component Angular de 250 l√≠nies que gestiona una llista de productes, fa peticions HTTP a una API, calcula descomptes segons regles de negoci, valida dades abans d'enviar, i gestiona l'estat de la cistella amb localStorage. Tot el codi est√† barrejat en un √∫nic component. <strong>Tasca:</strong> Dissenya una refactoritzaci√≥ completa aplicant separaci√≥ de responsabilitats en capes: crea els serveis necessaris (acc√©s a dades, l√≤gica de negoci, gesti√≥ d'estat), defineix les responsabilitats de cadascun, i mostra com quedaria el component refactoritzat. <strong>Format:</strong> Document amb estructura de carpetes, codi complet de cada servei amb comentaris explicatius, i el component refactoritzat final amb explicaci√≥ dels beneficis aconseguits." %}

{% include prompt-ai.html contingut="<strong>Rol:</strong> Instructor d'Angular especialitzat en patrons arquitect√≤nics. <strong>Context:</strong> Estic creant una aplicaci√≥ de gesti√≥ de comandes de restaurant on necessito mostrar plats disponibles, calcular preus amb descomptes per men√∫ del dia, validar que hi ha ingredients disponibles, i comunicar-me amb una API per obtenir el cat√†leg i enviar comandes. Vull aplicar el patr√≥ contenidor/presentacional amb separaci√≥ clara de responsabilitats. <strong>Tasca:</strong> Proporciona una arquitectura completa en capes especificant: (1) Quins serveis d'acc√©s a dades crear i les seves responsabilitats, (2) Quins serveis de l√≤gica de negoci crear amb exemples de regles concretes, (3) Quins components smart (contenidors) i dumb (presentacionals) crear, (4) Com es comuniquen entre ells amb diagrames de flux de dades. <strong>Format:</strong> Document arquitect√≤nic amb diagrames de capes, especificaci√≥ de responsabilitats per cada classe, i exemples de codi dels punts clau." %}
  {% endcapture %}
  {% include section-point.html numero="3.14" titol="Prompts d'IA" contingut=section_point_3_14 %}

  {% capture section_point_3_15 %}
<h3>Autoavaluaci√≥</h3>
{% include checklist.html elements="Aplico el principi de responsabilitat √∫nica creant classes amb una √∫nica ra√≥ per canviar|Organitzo l'aplicaci√≥ en tres capes clares: presentaci√≥ (components), l√≤gica (serveis de negoci), i dades (serveis d'acc√©s a APIs)|Creo components presentacionals purs que nom√©s reben dades via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code> sense l√≤gica de negoci|Implemento serveis de l√≤gica de negoci amb regles, validacions i c√†lculs separats de components i acc√©s a dades|Aplico el patr√≥ contenidor/presentacional separant components smart (amb serveis i l√≤gica) de components dumb (nom√©s presentaci√≥)" %}
  {% endcapture %}
  {% include section-point.html numero="3.15" titol="Autoavaluaci√≥" contingut=section_point_3_15 %}

  {% capture section_point_3_16 %}
<ul>
  <li>La separaci√≥ de responsabilitats en capes organitza el codi en presentaci√≥ (components), l√≤gica de negoci (serveis), i acc√©s a dades (serveis d'API), aplicant el principi de responsabilitat √∫nica on cada classe t√© una √∫nica ra√≥ per canviar.</li>
  <li>Els components presentacionals purs nom√©s mostren dades rebudes via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code> sense injectar serveis ni contenir l√≤gica, facilitant proves unit√†ries i reutilitzaci√≥ en m√∫ltiples contextos.</li>
  <li>Els serveis de l√≤gica de negoci encapsulen regles, validacions, c√†lculs i processament, permetent reutilitzaci√≥ des de m√∫ltiples components i garantint consist√®ncia quan les regles canvien.</li>
  <li>Els serveis d'acc√©s a dades encapsulen tota la comunicaci√≥ amb APIs, transformant DTOs a models interns i gestionant errors de manera centralitzada, desacoblant el codi del backend espec√≠fic utilitzat.</li>
  <li>El patr√≥ contenidor/presentacional separa components smart (amb serveis, l√≤gica i estat) de components dumb (nom√©s presentaci√≥), reduint l√≠nies de codi per component en un 70%, millorant testabilitat en un 90%, i eliminant 100% de codi duplicat.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="3.16" titol="S√≠ntesi" contingut=section_point_3_16 %}

  {% capture section_point_3_17 %}
<ul>
  <li><strong>Principi de responsabilitat √∫nica (SRP):</strong> Cada classe o funci√≥ ha de tenir una √∫nica ra√≥ per canviar, fent nom√©s una cosa ben definida.</li>
  <li><strong>Capa de presentaci√≥:</strong> Components que nom√©s mostren dades a l'usuari i capturen interaccions sense l√≤gica de negoci ni acc√©s a dades.</li>
  <li><strong>Capa de l√≤gica de negoci:</strong> Serveis amb regles de negoci, validacions, c√†lculs i processament de dades aplicables des de m√∫ltiples components.</li>
  <li><strong>Capa d'acc√©s a dades:</strong> Serveis que comuniquen amb APIs externes, transformen DTOs a models interns i gestionen errors HTTP.</li>
  <li><strong>Component presentacional (dumb):</strong> Rep dades via <code>@Input()</code>, les mostra, i emet esdeveniments via <code>@Output()</code> sense injectar serveis.</li>
  <li><strong>Component contenidor (smart):</strong> Gestiona estat i l√≤gica, injecta serveis, obt√© dades i les passa a components presentacionals fills.</li>
  <li><strong>DTO (Data Transfer Object):</strong> Objecte amb el format de dades que retorna l'API, diferent del model intern usat per l'aplicaci√≥.</li>
  <li><strong>Model intern:</strong> Representaci√≥ de dades adaptada a les necessitats de l'aplicaci√≥, transformada des de DTOs de l'API.</li>
  <li><strong>Desacoblament:</strong> Reducci√≥ de depend√®ncies directes entre capes usant abstraccions (serveis, interf√≠cies) en lloc d'implementacions concretes.</li>
  <li><strong>Refactoritzaci√≥:</strong> Proc√©s de reestructurar codi existent sense canviar comportament extern, millorant organitzaci√≥ i mantenibilitat.</li>
  <li><strong>Reutilitzaci√≥ de l√≤gica:</strong> Capacitat d'usar la mateixa l√≤gica de negoci des de m√∫ltiples components injectant serveis compartits.</li>
  <li><strong>Flux unidireccional de dades:</strong> Les dades flueixen en una direcci√≥ clara: capa de dades ‚Üí l√≤gica ‚Üí presentaci√≥, facilitant depuraci√≥.</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="3.17" titol="Rep√†s de conceptes" contingut=section_point_3_17 %}

</div>
