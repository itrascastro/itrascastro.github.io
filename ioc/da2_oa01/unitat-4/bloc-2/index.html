<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>Bloc 2: Arquitectura i patrons | DA2_OA01 - Programació Avançada (Angular) - IOC</title>
    <meta name="description" content="Material educatiu - Institut Obert de Catalunya">
    <meta name="page-unitat" content="4">
    <meta name="page-bloc" content="2">
    
    <!-- SEO Tags -->
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Bloc 2: Arquitectura i patrons | DA2_OA01 - Programació Avançada (Angular)</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Bloc 2: Arquitectura i patrons" />
<meta property="og:locale" content="ca_ES" />
<meta name="description" content="Gestió d’estat, modularització i bones pràctiques arquitectòniques" />
<meta property="og:description" content="Gestió d’estat, modularització i bones pràctiques arquitectòniques" />
<link rel="canonical" href="http://localhost:4006/ioc/da2_OA01/unitat-4/bloc-2/" />
<meta property="og:url" content="http://localhost:4006/ioc/da2_OA01/unitat-4/bloc-2/" />
<meta property="og:site_name" content="DA2_OA01 - Programació Avançada (Angular)" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bloc 2: Arquitectura i patrons" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Gestió d’estat, modularització i bones pràctiques arquitectòniques","headline":"Bloc 2: Arquitectura i patrons","url":"http://localhost:4006/ioc/da2_OA01/unitat-4/bloc-2/"}</script>
<!-- End Jekyll SEO tag -->

    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="/ioc/da2_OA01/assets/css/style.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="canonical" href="http://localhost:4006/ioc/da2_OA01/unitat-4/bloc-2/">
    <!-- Rich editor styles (for embedded notes panel) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.snow.min.css">
    <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" disabled>
    <link rel="stylesheet" href="/ioc/da2_OA01/assets/css/quadern-rich-editor.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/ioc/da2_OA01/assets/images/favicon.ico">
    
    <!-- RSS Feed -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4006/ioc/da2_OA01/feed.xml" title="DA2_OA01 - Programació Avançada (Angular)" />

    <!-- Syntax Highlighting (Prism) -->
    <link id="prism-theme" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>

    <!-- Code Block Component -->
    <link rel="stylesheet" href="/ioc/da2_OA01/assets/css/code-block.css">
    <script src="/ioc/da2_OA01/assets/js/code-block.js"></script>

</head>

<body class="bloc-layout">
    <!-- Skip to content for accessibility -->
    <a class="skip-link" href="#main-content">Salta al contingut principal</a>


    
    <!-- Header fix -->
    <header class="header" role="banner" id="top">
        <div class="header-brand">
            <a href="/ioc/da2_OA01/" class="logo-link" aria-label="Inici">
                <img src="/ioc/da2_OA01/assets/images/logo_IOC_light.jpg" alt="Institut Obert de Catalunya" class="logo logo-light">
                <img src="/ioc/da2_OA01/assets/images/logo_IOC_dark.png" alt="Institut Obert de Catalunya" class="logo logo-dark">
            </a>
            <a href="/ioc/da2_OA01/" class="title-link">
                <h1>DA2_OA01 - DA2_OA01 - Programació Avançada (Angular)</h1>
            </a>
        </div>
        <div class="header-actions">
            <button class="theme-toggle" id="theme-toggle">Mode Fosc</button>
            <button class="nav-panel-toggle" type="button" aria-expanded="false" aria-label="Obre la navegació">
                <i class="bi bi-list" aria-hidden="true"></i>
                <span class="nav-panel-label">Navegació</span>
            </button>
        </div>
    </header>

    <div class="offcanvas-backdrop" hidden></div>
    <nav class="offcanvas-nav" aria-hidden="true" aria-label="Navegació del curs">
        <div class="offcanvas-header">
            <h2 class="offcanvas-title">Navegació</h2>
            <button class="offcanvas-close" type="button" aria-label="Tanca la navegació">
                <i class="bi bi-x-lg" aria-hidden="true"></i>
            </button>
        </div>
        <div class="offcanvas-body">
            <a href="/ioc/da2_OA01/" class="nav-dropdown-item ">Índex del Curs</a>
            
                
                    <a href="/ioc/da2_OA01/unitat-1/bloc-1/" class="nav-dropdown-item ">
                        Unitat 1 - Bloc 1: Conceptes fonamentals i instal·lació
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-1/bloc-2/" class="nav-dropdown-item ">
                        Unitat 1 - Bloc 2: Entorn de desenvolupament integrat
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-1/bloc-3/" class="nav-dropdown-item ">
                        Unitat 1 - Bloc 3: Creació del projecte base
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-1/bloc-4/" class="nav-dropdown-item ">
                        Unitat 1 - Bloc 4: Cas d'ús: Preparació de l'entorn
                    </a>
                
            
                
                    <a href="/ioc/da2_OA01/unitat-2/bloc-1/" class="nav-dropdown-item ">
                        Unitat 2 - Bloc 1: Components i comunicació bàsica
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-2/bloc-2/" class="nav-dropdown-item ">
                        Unitat 2 - Bloc 2: Data binding i events
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-2/bloc-3/" class="nav-dropdown-item ">
                        Unitat 2 - Bloc 3: Formularis amb vinculació bidireccional
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-2/bloc-4/" class="nav-dropdown-item ">
                        Unitat 2 - Bloc 4: Cas d'ús: Catàleg d'elements
                    </a>
                
            
                
                    <a href="/ioc/da2_OA01/unitat-3/bloc-1/" class="nav-dropdown-item ">
                        Unitat 3 - Bloc 1: Serveis i separació de responsabilitats
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-3/bloc-2/" class="nav-dropdown-item ">
                        Unitat 3 - Bloc 2: Gestió d'estat i comunicació entre components
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-3/bloc-3/" class="nav-dropdown-item ">
                        Unitat 3 - Bloc 3: Optimització i bones pràctiques
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-3/bloc-4/" class="nav-dropdown-item ">
                        Unitat 3 - Bloc 4: Cas d'ús: Catàleg amb API REST
                    </a>
                
            
                
                    <a href="/ioc/da2_OA01/unitat-4/bloc-1/" class="nav-dropdown-item ">
                        Unitat 4 - Bloc 1: Sistema de rutes i navegació
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-4/bloc-2/" class="nav-dropdown-item current">
                        Unitat 4 - Bloc 2: Arquitectura escalable
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-4/bloc-3/" class="nav-dropdown-item ">
                        Unitat 4 - Bloc 3: Optimització de rendiment
                    </a>
                
                    <a href="/ioc/da2_OA01/unitat-4/bloc-4/" class="nav-dropdown-item ">
                        Unitat 4 - Bloc 4: Cas d'ús: Aplicació completa
                    </a>
                
            
        </div>
    </nav>

    <div class="container">
        <!-- Sidebar Navegació -->
        
        <aside class="sidebar">
            <button class="sidebar-toggle" type="button" aria-expanded="false">
                <span>Contingut del bloc</span>
                <i class="bi bi-chevron-down" aria-hidden="true"></i>
            </button>
            <div class="sidebar-scroll">
                <!-- Contingut d'aquest Bloc -->
                <div class="sidebar-section">
                    <h3>Contingut del Bloc</h3>
                    

    
    
    
    
    
        
        
        
        
        
        
        
        <div class="nav-item">
            <a href="#Unitat4_Bloc2_Seccio1" class="nav-link" data-section="Unitat4_Bloc2_Seccio1">1. Patró de gestió d'estat centralitzada</a>
        </div>
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    
        
        
        
        
        
        
        
        <div class="nav-item">
            <a href="#Unitat4_Bloc2_Seccio2" class="nav-link" data-section="Unitat4_Bloc2_Seccio2">2. Organització en mòduls i càrrega per seccions (lazy loading)</a>
        </div>
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    
        
        
        
        
        
        
        
        <div class="nav-item">
            <a href="#Unitat4_Bloc2_Seccio3" class="nav-link" data-section="Unitat4_Bloc2_Seccio3">3. Separació de responsabilitats i capes</a>
        </div>
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    

    
    
    
    



                </div>
            </div>
        </aside>
        

        <main class="main-content" role="main" id="main-content">
            
            <!-- Navegació horizontal -->
            
            <nav class="horizontal-nav" aria-label="Navegació de ruta">
                <div class="horizontal-nav-list">
                    <a href="/ioc/da2_OA01/" class="horizontal-nav-item">Inici</a>
                    
                    
                        
                        
                            
                        
                            
                        
                            
                        
                            
                                
                                
                        
                        
                            <span class="horizontal-nav-separator"> &gt; </span>
                            <a href="/ioc/da2_OA01/unitat-4/" class="horizontal-nav-item">
                                Unitat 4: Navegació i arquitectura d'aplicacions (RA4)
                            </a>
                        
                        
                        
                            
                            
                                
                            
                                
                                    
                                    
                            
                            
                                <span class="horizontal-nav-separator"> &gt; </span>
                                <span class="horizontal-nav-item current">
                                    Bloc 4.2: Arquitectura escalable
                                </span>
                            
                        
                    
                </div>
            </nav>
            
            
            <!-- Contingut de la Pàgina -->
            <article class="page-content">
                <div class="content-body">
                    

<!-- Objectius del bloc (si estan definits al frontmatter) -->


<!-- Contingut principal -->
<!--
  ═══════════════════════════════════════════════════════════════════
  BLOC 2 - UNITAT 4
  Contingut migrat des de:
  - .resources/Autoria/Unitat4/Lliço2/OA1/lectura-u4-l2-oa1.md
  - .resources/Autoria/Unitat4/Lliço2/OA2/lectura-u4-l2-oa2.md
  - .resources/Autoria/Unitat4/Lliço2/OA3/lectura-u4-l2-oa3.md
  ═══════════════════════════════════════════════════════════════════
-->

<div class="section" id="Unitat4_Bloc2_Seccio1">
  <h2 id="Unitat4_Bloc2_Seccio1">1. Patró de gestió d'estat centralitzada</h2>

  <!-- MULTIMÈDIA -->
  <!--
  ════════════════════════════════════════════════════════════════
  Component: Enllaços multimèdia YouTube
  ════════════════════════════════════════════════════════════════

  Paràmetres:
    - unitat: número de la unitat (1-4)
    - bloc: número del bloc (1-4)
    - seccio: número de la secció (1-3)

  Exemple d'ús:
    {% include multimedia-youtube.html unitat=1 bloc=1 seccio=1 %}

  El component busca automàticament les URLs corresponents a
  site.data.multimedia i mostra els botons de vídeo i àudio.
  ════════════════════════════════════════════════════════════════
-->





  
  
  
  
  

  

  

  
<div class="multimedia-resources">
  <div class="multimedia-header">
    <i class="bi bi-play-circle-fill"></i>
    <span>Contingut multimèdia d'aquesta lectura</span>
  </div>

  <div class="multimedia-buttons">
    
    <a href="https://www.youtube.com/watch?v=_baTUyKuHk4" target="_blank" rel="noopener noreferrer" class="multimedia-btn video-btn" title="Lectura 4.2.1 · Patró de gestió d'estat centralitzada">
      <i class="bi bi-youtube"></i>
      <span>Veure vídeo</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    

    
    <a href="https://www.youtube.com/watch?v=TdCiyJH0uE8" target="_blank" rel="noopener noreferrer" class="multimedia-btn audio-btn" title="[Audio] Lectura 4.2.1 · Patró de gestió d'estat centralitzada">
      <i class="bi bi-mic-fill"></i>
      <span>Escoltar àudio</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    
  </div>

  
  
</div>
  




  <!-- Component: Objectius del bloc/unitat -->



<div class="objectius-box">
  <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-bullseye" aria-hidden="true"></i> Objectius</div>
  <div class="component-content">
    <ul>
      
        <li>Identificar situacions on múltiples components necessiten accedir a les mateixes dades compartides</li>
      
        <li>Crear un servei d'estat centralitzat amb observables per gestionar dades globals</li>
      
        <li>Subscriure components a canvis d'estat per rebre actualitzacions automàtiques</li>
      
        <li>Aplicar el principi d'immutabilitat per evitar modificacions directes de l'estat</li>
      
    </ul>
  </div>
  <!-- IMPORTANT: també es pot usar via front matter: page.objectius (array) -->
</div>



  <!-- Component: Caixa informativa -->
<div class="info-box" role="note">
    <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-info-circle" aria-hidden="true"></i> Informació</div>
    <strong>RA4 · Criteri 4</strong> — Optimitza els recursos i genera un paquet llest per a publicació.
    
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.1. Prerequisits</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Unitat 3 completada:</strong> Heu treballat amb serveis, injecció de dependències i comunicació amb APIs externes</li>
<li><strong>Conceptes d'observables:</strong> Comprensió bàsica de <code>BehaviorSubject</code>, <code>Observable</code> i subscripcions</li>
<li><strong>Comunicació entre components:</strong> Coneixeu <code>@Input</code> i <code>@Output</code> per passar dades entre components</li>
<li><strong>Jerarquies de components:</strong> Enteneu relacions pare-fill i germans en l'arbre de components</li>
<li><strong>Projecte funcional:</strong> Teniu una aplicació Angular amb múltiples components creats</li>
</ul>

<p><strong>Verificació ràpida:</strong></p>


<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash"># Verificar que teniu el projecte preparat
ng version
ng serve --open</code></pre>
  </div>
</div>


<p><strong>Punt d'autocomprovació:</strong> L'aplicació s'obre al navegador i podeu navegar entre components sense errors.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.2. Marc conceptual</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.2.1. Què és la gestió d'estat centralitzada</h4>
<p>La gestió d'estat centralitzada és un patró arquitectònic on totes les dades globals de l'aplicació es guarden en un únic lloc accessible des de qualsevol component. En lloc que cada component mantingui la seva còpia de dades compartides, tots els components consulten i actualitzen un estat central que propaga els canvis automàticament.</p>

<h4>1.2.2. Problema sense gestió d'estat centralitzada</h4>
<p><strong>Situació abans:</strong></p>
<p>Quan diferents components necessiten accedir a les mateixes dades (usuari autenticat, cistella de compra, configuració global), cada component manté la seva pròpia còpia. Si l'usuari fa login, cal actualitzar manualment cada component.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">src/
├── components/
│   ├── header/
│   │   └── header.component.ts       // Té el seu propi usuari: User | null
│   ├── sidebar/
│   │   └── sidebar.component.ts      // També té el seu propi usuari: User | null
│   ├── profile/
│   │   └── profile.component.ts      // I aquest també: User | null
│   └── dashboard/
│       └── dashboard.component.ts    // Un altre més: User | null</code></pre>
  </div>
</div>


<p>Cada component duplica les dades i no sab quan altres components les modifiquen.</p>

<p><strong>Problemes que genera:</strong></p>

<p><strong>1. Inconsistència de dades</strong></p>
<p>Quan l'usuari fa login al <code>HeaderComponent</code>, altres components no s'assabenten del canvi. El <code>SidebarComponent</code> segueix mostrant "Usuari no autenticat" mentre el <code>HeaderComponent</code> mostra el nom de l'usuari. Aquesta desincronització crea confusió i errors.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// HeaderComponent fa login
this.currentUser = { id: 1, name: &#39;Anna&#39; };

// Però SidebarComponent encara té:
this.currentUser = null; // PROBLEMA: Desincronitzat!</code></pre>
  </div>
</div>


<p><strong>2. Complexitat exponencial en comunicació</strong></p>
<p>Per mantenir sincronitzats 4 components sobre l'usuari actual, necessiteu 6 connexions <code>@Output</code> i esdeveniments. Amb 10 components són 45 connexions. La quantitat de cables creix exponencialment: n × (n-1) / 2.</p>

<table>
<thead>
<tr>
<th>Components</th>
<th>Connexions necessàries</th>
</tr>
</thead>
<tbody>
<tr><td>2</td><td>1</td></tr>
<tr><td>4</td><td>6</td></tr>
<tr><td>8</td><td>28</td></tr>
<tr><td>10</td><td>45</td></tr>
</tbody>
</table>

<p><strong>3. Duplicació de lògica i memòria</strong></p>
<p>Cada component replica la mateixa lògica de gestió de l'usuari: validació, actualització, emmagatzematge local. Si cal canviar com es gestiona l'usuari, heu de modificar 10 fitxers diferents. A més, mantenir 10 còpies de l'objecte usuari multiplica el consum de memòria innecessàriament.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Repetit en 10 components:
updateUser(newUser: User) {
  this.currentUser = newUser;
  localStorage.setItem(&#39;user&#39;, JSON.stringify(newUser));
  this.validatePermissions();
}</code></pre>
  </div>
</div>


<p><strong>4. Dificultat per depurar i fer proves</strong></p>
<p>Quan hi ha un error relacionat amb les dades d'usuari, no sabeu quin component té la versió correcta. Fer proves unitàries requereix simular tots els components implicats, no només el servei central.</p>

<p><strong>5. Acoblament fort entre components</strong></p>
<p>Components que no haurien de conèixer-se directament han de comunicar-se amb esdeveniments en cadena. El <code>ProfileComponent</code> ha d'enviar esdeveniments al pare, que els reenvia al <code>HeaderComponent</code>. Modificar un component afecta múltiples altres.</p>

<h4>1.2.3. Solució amb gestió d'estat centralitzada</h4>
<p>Un servei d'estat centralitzat actua com a font única de veritat. Tots els components se subscriuen a aquest servei i reben actualitzacions automàtiques quan l'estat canvia.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>Consistència garantida:</strong> Un únic lloc guarda les dades, tots llegeixen el mateix</li>
<li><strong>Simplicitat de comunicació:</strong> Components no es comuniquen entre ells, només amb el servei</li>
<li><strong>Mantenibilitat:</strong> La lògica de gestió està centralitzada en un únic fitxer</li>
<li><strong>Facilitat de proves:</strong> Podeu provar el servei aïlladament sense components</li>
<li><strong>Desacoblament:</strong> Components no saben que altres components existeixen</li>
</ol>

<h4>1.2.4. Exemple real complet: Sense vs Amb gestió d'estat</h4>
<p><strong>Situació:</strong> Una aplicació amb header, sidebar i profile. L'usuari fa login i tots tres han de mostrar les dades actualitzades.</p>

<p><strong>Sense gestió d'estat centralitzada:</strong></p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// header.component.ts
export class HeaderComponent {
  @Output() userLoggedIn = new EventEmitter&lt;User&gt;();
  currentUser: User | null = null;

  login(credentials: Credentials) {
    this.authService.login(credentials).subscribe(user =&gt; {
      this.currentUser = user;
      this.userLoggedIn.emit(user); // Notificar pare
    });
  }
}

// app.component.ts (pare)
export class AppComponent {
  onUserLoggedIn(user: User) {
    // Propagar a sidebar i profile
    this.sidebarUser = user;
    this.profileUser = user;
  }
}

// sidebar.component.ts
export class SidebarComponent {
  @Input() currentUser: User | null = null;
}

// profile.component.ts
export class ProfileComponent {
  @Input() currentUser: User | null = null;
}</code></pre>
  </div>
</div>


<p>→ <strong>90 línies de codi</strong> per gestionar la propagació manual entre components.</p>

<p><strong>Amb gestió d'estat centralitzada:</strong></p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// auth-state.service.ts
@Injectable({ providedIn: &#39;root&#39; })
export class AuthStateService {
  private userSubject = new BehaviorSubject&lt;User | null&gt;(null);
  user$ = this.userSubject.asObservable();

  setUser(user: User | null) {
    this.userSubject.next(user);
  }
}

// header.component.ts
export class HeaderComponent {
  constructor(private authState: AuthStateService) {}

  login(credentials: Credentials) {
    this.authService.login(credentials).subscribe(user =&gt; {
      this.authState.setUser(user); // Actualitza estat central
    });
  }
}

// sidebar.component.ts
export class SidebarComponent {
  user$ = this.authState.user$; // Se subscriu automàticament
  constructor(private authState: AuthStateService) {}
}

// profile.component.ts
export class ProfileComponent {
  user$ = this.authState.user$; // Se subscriu automàticament
  constructor(private authState: AuthStateService) {}
}</code></pre>
  </div>
</div>


<p>→ <strong>45 línies de codi</strong>, 50% menys, zero cables entre components.</p>

<h4>1.2.5. Taula comparativa: Abans vs Després</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Sense estat central</th>
<th>Amb estat central</th>
</tr>
</thead>
<tbody>
<tr><td><strong>Línies de codi</strong></td><td>90+</td><td>45</td></tr>
<tr><td><strong>Connexions @Input/@Output</strong></td><td>6 per 4 components</td><td>0</td></tr>
<tr><td><strong>Lloc de veritat</strong></td><td>Múltiple (cada component)</td><td>Únic (servei)</td></tr>
<tr><td><strong>Temps actualització</strong></td><td>Manual i asíncron</td><td>Automàtic i síncron</td></tr>
<tr><td><strong>Complexitat afegir component</strong></td><td>Creix exponencial</td><td>Constant</td></tr>
<tr><td><strong>Facilitat proves</strong></td><td>Difícil (molts mocks)</td><td>Senzill (1 servei)</td></tr>
</tbody>
</table>

<h4>1.2.6. Conceptes clau de gestió d'estat</h4>
<table>
<thead>
<tr>
<th>Concepte</th>
<th>Descripció</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Font única de veritat</strong></td>
<td>Totes les dades globals estan en un únic lloc</td>
<td>Servei AuthStateService</td>
</tr>
<tr>
<td><strong>Flux unidireccional</strong></td>
<td>Les dades flueixen en una sola direcció: servei → components</td>
<td>Components llegeixen, mai modifiquen directament</td>
</tr>
<tr>
<td><strong>Observable</strong></td>
<td>Objecte que emet valors als subscriptors quan canvia</td>
<td><code>user$</code> emet cada cop que l'usuari canvia</td>
</tr>
<tr>
<td><strong>Immutabilitat</strong></td>
<td>No es modifica l'estat directament, es crea un de nou</td>
<td><code>next({ ...oldUser, name: 'Nou' })</code></td>
</tr>
<tr>
<td><strong>Subscripció</strong></td>
<td>Components escolten canvis de l'estat</td>
<td><code>user$.subscribe(u => ...)</code></td>
</tr>
</tbody>
</table>

<h4>1.2.7. Quan usar gestió d'estat centralitzada</h4>
<p><strong>Casos on és recomanable:</strong></p>
<ul>
<li>Dades d'autenticació (usuari, token, permisos)</li>
<li>Configuració global (idioma, tema, preferències)</li>
<li>Cistella de compra o carret</li>
<li>Filtres globals aplicats a múltiples vistes</li>
<li>Notificacions o missatges d'error globals</li>
</ul>

<p><strong>Casos on NO cal:</strong></p>
<ul>
<li>Dades locals d'un únic component (formulari temporal)</li>
<li>Estats UI efímers (menu desplegable obert/tancat)</li>
<li>Dades que només passa un component pare a un fill directe</li>
</ul>

<p><strong>Regla pràctica:</strong> Si més de 3 components necessiten les mateixes dades o si components no relacionats han de compartir informació, useu gestió d'estat centralitzada.</p>

<h4>1.2.8. Característiques principals</h4>
<p><strong>1. BehaviorSubject com a contenidor d'estat</strong></p>
<p>El <code>BehaviorSubject</code> és un tipus especial d'observable que emmagatzema l'últim valor emès. Quan un nou component se subscriu, rep immediatament el valor actual sense esperar el proper canvi. Això garanteix que tots els components tinguin sempre l'estat més recent.</p>

<p><strong>2. Exposició com a Observable de només lectura</strong></p>
<p>El servei exposa l'estat com a <code>Observable</code> (<code>user$</code>) però manté el <code>BehaviorSubject</code> privat. Els components poden llegir i subscriure's, però no poden modificar l'estat directament. Només el servei pot canviar l'estat mitjançant mètodes controlats.</p>

<p><strong>3. Mètodes d'actualització centralitzats</strong></p>
<p>Totes les modificacions de l'estat passen per mètodes del servei (<code>setUser()</code>, <code>updatePermissions()</code>). Això permet validar canvis, executar lògica de negoci, o registrar esdeveniments abans d'actualitzar l'estat.</p>

<p><strong>4. Propagació automàtica de canvis</strong></p>
<p>Quan l'estat canvia, tots els subscriptors reben la notificació automàticament sense codi addicional. No cal implementar mecanismes de notificació manual ni cadenes d'esdeveniments.</p>

<p><strong>5. Desacoblament de components</strong></p>
<p>Components no saben que altres components existeixen. Només coneixen el servei d'estat. Podeu afegir, eliminar o modificar components sense afectar els altres, sempre que mantinguin la interfície amb el servei.</p>

<h4>1.2.9. Integració amb el flux de treball del catàleg d'elements</h4>
<p>En el projecte del catàleg d'elements, la gestió d'estat centralitzada és útil per:</p>
<ul>
<li><strong>Elements seleccionats:</strong> Quan l'usuari selecciona múltiples elements per comparar o editar, aquesta selecció és accessible des del header (contador), sidebar (llista), i vista de detall (accions).</li>
<li><strong>Filtres actius:</strong> Els filtres aplicats a la llista d'elements (categoria, cerca, ordenació) es mantenen visibles al header i es poden resetejar des de qualsevol component.</li>
<li><strong>Mode visualització:</strong> Si l'usuari canvia de vista llista a vista graella, tots els components que mostren elements s'actualitzen automàticament sense comunicació manual.</li>
</ul>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.3. Model mental</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Emissor de ràdio central</strong></p>
<p>El servei d'estat és com una emissora de ràdio que emet un programa. Tots els components són ràdios que sintonitzen la mateixa freqüència. Quan l'emissora canvia el contingut (actualitza l'estat), totes les ràdios ho escolten simultàniament sense que s'hagin de comunicar entre elles.</p>

<p><strong>Pissarra compartida</strong></p>
<p>Imagineu una classe amb una pissarra central. Qualsevol alumne (component) pot mirar la pissarra per veure la informació actual. Només el professor (servei d'estat) pot escriure-hi. Quan el professor escriu alguna cosa nova, tots els alumnes ho veuen automàticament sense que calgui cridar-los un per un.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.4. Problema de l'estat compartit: components desconnectats que necessiten dades comunes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.4.1. Objectiu</h4>
<p>Comprendre per què sorgeix el problema de l'estat compartit i identificar situacions on múltiples components necessiten accedir a les mateixes dades.</p>

<p><strong>Escenari real:</strong> Teniu una aplicació de comerç electrònic amb múltiples components: un header que mostra el nombre d'articles a la cistella, un sidebar amb el resum de compra, una llista de productes on podeu afegir articles, i una pàgina de checkout. Tots quatre components necessiten saber quants articles hi ha a la cistella i quins són.</p>

<h4>1.4.2. Duplicació de dades</h4>
<p>Sense un estat centralitzat, cada component manté la seva pròpia còpia de la cistella. El <code>HeaderComponent</code> té <code>cartItems: Product[] = []</code>, el <code>SidebarComponent</code> té la seva pròpia <code>cartItems</code>, i el <code>ProductListComponent</code> també. Quan afegiu un producte a la cistella des de <code>ProductListComponent</code>, aquest component actualitza la seva cistella local, però els altres no s'assabenten del canvi.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// HeaderComponent
cartItems: Product[] = [];
cartCount = 0;

// SidebarComponent
cartItems: Product[] = [];
totalPrice = 0;

// ProductListComponent
cartItems: Product[] = [];</code></pre>
  </div>
</div>


<p>→ Tres còpies de les mateixes dades, cadascuna potencialment desincronitzada.</p>

<h4>1.4.3. Comunicació manual excessiva</h4>
<p>Per sincronitzar els components, heu de crear una cadena d'esdeveniments. El <code>ProductListComponent</code> emet un esdeveniment <code>@Output() productAdded</code>, el component pare el captura i el propaga al header i al sidebar mitjançant <code>@Input()</code>. Si el sidebar actualitza la quantitat d'un producte, ha d'emetre un altre esdeveniment cap amunt i propagar-lo lateralment al header.</p>

<p>Amb 4 components implicats, necessiteu 6 cables de comunicació. Cada cop que afegiu un nou component que necessita la cistella, heu de crear nous cables amb tots els components existents.</p>

<h4>1.4.4. Inconsistència temporal</h4>
<p>Entre el moment que el <code>ProductListComponent</code> afegeix un producte i el moment que el header rep la notificació via esdeveniments, hi ha un instant on la informació és inconsistent. L'usuari veu que el producte està afegit a la llista però el comptador del header encara no s'ha actualitzat. Aquesta inconsistència, encara que breu, crea confusió.</p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Quan múltiples components desconnectats necessiten les mateixes dades, la duplicació i comunicació manual crea complexitat, inconsistència i errors.
</div>


<h4>1.4.5. Resultat esperat</h4>
<p>Identificeu situacions on múltiples components necessiten compartir dades i compreneu els problemes de duplicació, comunicació manual i inconsistència.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.5. Patrons de gestió d'estat: flux unidireccional de dades</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.5.1. Objectiu</h4>
<p>Conèixer els principis fonamentals dels patrons de gestió d'estat i el concepte de flux unidireccional.</p>

<h4>1.5.2. Principi de flux unidireccional</h4>
<p>El flux unidireccional de dades és un patró on les dades sempre flueixen en una única direcció: des de l'estat cap als components, mai a l'inrevés. Els components no modifiquen l'estat directament; en lloc d'això, envien accions o criden mètodes del servei que actualitzen l'estat, i aquest propaga els canvis de tornada als components.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Estat Central
    ↓ (Observable)
Components (llegeixen)
    ↓ (accions/mètodes)
Estat Central (actualitza)
    ↓ (Observable)
Components (reben canvi)</code></pre>
  </div>
</div>


<p>Aquest cicle garanteix que sempre sabeu d'on ve un canvi i cap on va.</p>

<h4>1.5.3. Beneficis del flux unidireccional</h4>
<p><strong>Predictibilitat:</strong> Sempre sabeu que els canvis provenen del servei d'estat, mai directament d'un altre component. Això simplifica la depuració: si hi ha un error en les dades d'usuari, només cal revisar el servei d'estat.</p>

<p><strong>Historial de canvis:</strong> Com tots els canvis passen pel servei, podeu registrar-los fàcilment. Això permet implementar funcionalitats com "desfer canvis" o auditoria de modificacions.</p>

<p><strong>Testabilitat:</strong> Podeu provar el servei d'estat aïlladament sense components. Les proves verifiquen que donat un estat inicial i una acció, l'estat resultant és l'esperat.</p>

<h4>1.5.4. Comparació amb altres patrons</h4>
<table>
<thead>
<tr>
<th>Patró</th>
<th>Direcció dades</th>
<th>Complexitat</th>
<th>Predictibilitat</th>
</tr>
</thead>
<tbody>
<tr><td><strong>@Input/@Output</strong></td><td>Bidireccional</td><td>Alta (creix exponencial)</td><td>Baixa</td></tr>
<tr><td><strong>Flux unidireccional</strong></td><td>Unidireccional</td><td>Constant</td><td>Alta</td></tr>
<tr><td><strong>Shared service sense Observable</strong></td><td>Bidireccional</td><td>Mitjana</td><td>Mitjana</td></tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El flux unidireccional de dades garanteix que sempre sabeu quin és l'origen d'un canvi i facilita la depuració, proves i manteniment.
</div>


<h4>1.5.5. Resultat esperat</h4>
<p>Compreneu el principi de flux unidireccional i els seus beneficis per a la predictibilitat i mantenibilitat del codi.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.6. Estat centralitzat vs distribuït: avantatges i desavantatges</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.6.1. Objectiu</h4>
<p>Comparar l'estat centralitzat amb l'estat distribuït per entendre quan usar cadascun.</p>

<h4>1.6.2. Què és l'estat distribuït</h4>
<p>En l'estat distribuït, cada component manté les seves pròpies dades sense un lloc centralitzat. Cada component és responsable de gestionar el seu estat intern. Per exemple, un formulari gestiona els seus camps, un comptador gestiona el seu valor, i una llista gestiona els seus elements.</p>

<p>Aquest enfocament és adequat quan les dades són locals a un component i no es comparteixen amb altres parts de l'aplicació.</p>

<h4>1.6.3. Què és l'estat centralitzat</h4>
<p>En l'estat centralitzat, totes les dades globals es guarden en un o més serveis dedicats. Els components accedeixen a aquestes dades mitjançant subscripcions i no mantenen còpies locals. Qualsevol canvi a l'estat central es propaga automàticament a tots els components subscrits.</p>

<h4>1.6.4. Avantatges de l'estat centralitzat</h4>
<p><strong>Font única de veritat:</strong> Només hi ha una còpia de cada dada global. Si l'usuari està autenticat, aquesta informació està en un únic lloc. Això elimina possibles inconsistències.</p>

<p><strong>Sincronització automàtica:</strong> Quan l'estat canvia, tots els components subscrits reben la notificació immediatament sense codi addicional. No cal implementar mecanismes de sincronització manual.</p>

<p><strong>Facilitat per afegir components:</strong> Afegir un nou component que necessita accedir a l'estat global només requereix injectar el servei i subscriure's. No cal modificar components existents ni crear nous cables de comunicació.</p>

<h4>1.6.5. Desavantatges de l'estat centralitzat</h4>
<p><strong>Overhead per dades simples:</strong> Si un component només necessita un comptador local que ningú més utilitza, crear un servei d'estat és excessiu. L'estat local del component és més simple.</p>

<p><strong>Dificultat per depurar si l'estat és molt gran:</strong> Si l'estat centralitzat conté desenes de propietats diferents, trobar quin mètode està modificant una propietat específica pot ser complicat sense eines de depuració avançades.</p>

<p><strong>Possibilitat de crear un "god service":</strong> Si poseu tot l'estat de l'aplicació en un únic servei gegant, aquest es converteix en un punt de complexitat i dificultat de manteniment. És millor dividir l'estat en múltiples serveis especialitzats (AuthState, CartState, ConfigState).</p>

<h4>1.6.6. Quan usar cadascun</h4>
<table>
<thead>
<tr>
<th>Situació</th>
<th>Tipus d'estat</th>
<th>Raó</th>
</tr>
</thead>
<tbody>
<tr><td>Dades locals d'un formulari</td><td>Distribuït</td><td>Només el component del formulari les necessita</td></tr>
<tr><td>Usuari autenticat</td><td>Centralitzat</td><td>Múltiples components (header, sidebar, profile) necessiten aquesta info</td></tr>
<tr><td>Estat d'un menu desplegable (obert/tancat)</td><td>Distribuït</td><td>Només el component del menu ho necessita</td></tr>
<tr><td>Cistella de compra</td><td>Centralitzat</td><td>Header, sidebar, checkout necessiten aquesta info</td></tr>
<tr><td>Filtres globals aplicats</td><td>Centralitzat</td><td>Múltiples components de llista els utilitzen</td></tr>
<tr><td>Valor temporal d'un input</td><td>Distribuït</td><td>Només el component de l'input ho necessita</td></tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Useu estat centralitzat per dades globals compartides entre múltiples components, i estat distribuït per dades locals d'un únic component.
</div>


<h4>1.6.7. Resultat esperat</h4>
<p>Sabeu distingir quan usar estat centralitzat i quan usar estat distribuït segons les necessitats de l'aplicació.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.7. Crear servei d'estat: objecte observable amb dades globals</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.7.1. Objectiu</h4>
<p>Crear un servei d'estat centralitzat utilitzant <code>BehaviorSubject</code> i exposar les dades com a <code>Observable</code>.</p>

<h4>1.7.2. Estructura bàsica d'un servei d'estat</h4>
<p>Un servei d'estat típic conté tres elements:</p>
<ol>
<li><strong>BehaviorSubject privat:</strong> Emmagatzema l'estat actual i permet actualitzar-lo</li>
<li><strong>Observable públic:</strong> Exposa l'estat de només lectura als components</li>
<li><strong>Mètodes d'actualització:</strong> Permeten modificar l'estat de manera controlada</li>
</ol>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">import { Injectable } from &#39;@angular/core&#39;;
import { BehaviorSubject, Observable } from &#39;rxjs&#39;;

@Injectable({ providedIn: &#39;root&#39; })
export class AuthStateService {
  // 1. BehaviorSubject privat (només el servei pot modificar-lo)
  private userSubject = new BehaviorSubject&lt;User | null&gt;(null);

  // 2. Observable públic (components poden subscriure&#39;s)
  user$: Observable&lt;User | null&gt; = this.userSubject.asObservable();

  // 3. Mètodes d&#39;actualització
  setUser(user: User | null): void {
    this.userSubject.next(user);
  }

  updateUserName(newName: string): void {
    const currentUser = this.userSubject.value;
    if (currentUser) {
      this.userSubject.next({ ...currentUser, name: newName });
    }
  }
}</code></pre>
  </div>
</div>


<h4>1.7.3. Per què BehaviorSubject i no Subject</h4>
<p><code>BehaviorSubject</code> requereix un valor inicial i emmagatzema l'últim valor emès. Quan un component se subscriu, rep immediatament el valor actual. Això és ideal per a estat perquè els components necessiten conèixer l'estat actual en el moment de la subscripció, no esperar el proper canvi.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// BehaviorSubject: emet l&#39;últim valor immediatament
private userSubject = new BehaviorSubject&lt;User | null&gt;(null);

// Component que se subscriu després:
this.authState.user$.subscribe(user =&gt; {
  console.log(user); // Rep immediatament &#39;null&#39; (valor inicial)
});</code></pre>
  </div>
</div>


<p>En canvi, <code>Subject</code> no emet res fins que hi ha un nou valor, cosa que deixaria els components sense estat fins al primer canvi.</p>

<h4>1.7.4. Exposar com a Observable de només lectura</h4>
<p>Exposar el <code>BehaviorSubject</code> directament permet que els components cridin <code>next()</code> i modifiquin l'estat sense control. Per evitar-ho, s'exposa com a <code>Observable</code> amb <code>asObservable()</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// INCORRECTE: Components podrien fer this.userSubject.next(...)
public userSubject = new BehaviorSubject&lt;User | null&gt;(null);

// CORRECTE: Components només poden subscriure&#39;s i llegir
private userSubject = new BehaviorSubject&lt;User | null&gt;(null);
public user$ = this.userSubject.asObservable();</code></pre>
  </div>
</div>


<h4>1.7.5. Exemple complet: servei d'estat de cistella</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">export interface CartItem {
  productId: number;
  name: string;
  price: number;
  quantity: number;
}

@Injectable({ providedIn: &#39;root&#39; })
export class CartStateService {
  private itemsSubject = new BehaviorSubject&lt;CartItem[]&gt;([]);
  items$ = this.itemsSubject.asObservable();

  addItem(item: CartItem): void {
    const currentItems = this.itemsSubject.value;
    const existingItem = currentItems.find(i =&gt; i.productId === item.productId);

    if (existingItem) {
      // Actualitzar quantitat
      const updatedItems = currentItems.map(i =&gt;
        i.productId === item.productId
          ? { ...i, quantity: i.quantity + item.quantity }
          : i
      );
      this.itemsSubject.next(updatedItems);
    } else {
      // Afegir nou
      this.itemsSubject.next([...currentItems, item]);
    }
  }

  removeItem(productId: number): void {
    const currentItems = this.itemsSubject.value;
    this.itemsSubject.next(currentItems.filter(i =&gt; i.productId !== productId));
  }

  clear(): void {
    this.itemsSubject.next([]);
  }
}</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Un servei d'estat utilitza <code>BehaviorSubject</code> privat per emmagatzemar l'estat, <code>Observable</code> públic per exposar-lo, i mètodes per actualitzar-lo de manera controlada.
</div>


<h4>1.7.6. Resultat esperat</h4>
<p>Creeu serveis d'estat amb <code>BehaviorSubject</code>, exposeu les dades com a <code>Observable</code>, i implementeu mètodes d'actualització controlats.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.8. Components subscrits a canvis d'estat: rebre actualitzacions automàtiques</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.8.1. Objectiu</h4>
<p>Subscriure components a l'estat centralitzat perquè rebin actualitzacions automàtiques quan l'estat canvia.</p>

<h4>1.8.2. Subscripció bàsica en un component</h4>
<p>Per accedir a l'estat, el component injecta el servei i se subscriu a l'observable:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">export class HeaderComponent implements OnInit {
  currentUser: User | null = null;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.authState.user$.subscribe(user =&gt; {
      this.currentUser = user;
      console.log(&#39;Usuari actualitzat:&#39;, user);
    });
  }
}</code></pre>
  </div>
</div>


<p>Cada cop que el servei d'estat crida <code>this.userSubject.next(newUser)</code>, tots els components subscrits reben el nou valor i actualitzen la seva propietat local.</p>

<h4>1.8.3. Utilitzar l'async pipe per subscripcions automàtiques</h4>
<p>En lloc de subscriure's manualment, podeu utilitzar l'<code>async</code> pipe a la plantilla. Això té l'avantatge que Angular gestiona automàticament la subscripció i desubscripció:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">export class HeaderComponent {
  user$ = this.authState.user$; // Assignar directament l&#39;observable

  constructor(private authState: AuthStateService) {}
}</code></pre>
  </div>
</div>



<div class="code-block" data-lang="html" role="region" aria-label="Bloc de codi html">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">HTML</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-html">&lt;!-- Plantilla amb async pipe --&gt;
&lt;div *ngIf=&quot;user$ | async as user; else notLoggedIn&quot;&gt;
  &lt;p&gt;Benvingut, {{ user.name }}&lt;/p&gt;
&lt;/div&gt;
&lt;ng-template #notLoggedIn&gt;
  &lt;p&gt;No estàs autenticat&lt;/p&gt;
&lt;/ng-template&gt;</code></pre>
  </div>
</div>


<p>L'<code>async</code> pipe se subscriu automàticament quan el component es crea i es desubscriu quan es destrueix, evitant fuites de memòria.</p>

<h4>1.8.4. Múltiples components subscrits simultàniament</h4>
<p>Quan diversos components se subscriuen al mateix observable, tots reben les actualitzacions simultàniament:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// HeaderComponent
export class HeaderComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}

// SidebarComponent
export class SidebarComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}

// ProfileComponent
export class ProfileComponent {
  user$ = this.authState.user$;
  constructor(private authState: AuthStateService) {}
}</code></pre>
  </div>
</div>


<p>Quan algú crida <code>authState.setUser(newUser)</code>, els tres components actualitzen la seva vista automàticament i simultàniament.</p>

<h4>1.8.5. Gestió de subscripcions manuals</h4>
<p>Si utilitzeu subscripcions manuals (sense <code>async</code> pipe), heu de desubscriure-us per evitar fuites de memòria:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">export class HeaderComponent implements OnInit, OnDestroy {
  private subscription: Subscription;
  currentUser: User | null = null;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.subscription = this.authState.user$.subscribe(user =&gt; {
      this.currentUser = user;
    });
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}</code></pre>
  </div>
</div>


<p><strong>Recomanació:</strong> Sempre que sigui possible, utilitzeu l'<code>async</code> pipe per evitar gestió manual de subscripcions.</p>

<h4>1.8.6. Exemple: cistella amb comptador automàtic</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// HeaderComponent
export class HeaderComponent {
  cartCount$ = this.cartState.items$.pipe(
    map(items =&gt; items.reduce((sum, item) =&gt; sum + item.quantity, 0))
  );

  constructor(private cartState: CartStateService) {}
}</code></pre>
  </div>
</div>



<div class="code-block" data-lang="html" role="region" aria-label="Bloc de codi html">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">HTML</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-html">&lt;!-- Plantilla --&gt;
&lt;div class=&quot;cart-icon&quot;&gt;
  &lt;span&gt;🛒&lt;/span&gt;
  &lt;span class=&quot;badge&quot;&gt;{{ cartCount$ | async }}&lt;/span&gt;
&lt;/div&gt;</code></pre>
  </div>
</div>


<p>Cada cop que s'afegeix o elimina un article de la cistella, el comptador s'actualitza automàticament sense codi addicional.</p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Els components se subscriuen a l'observable exposat pel servei d'estat i reben actualitzacions automàtiques cada cop que l'estat canvia.
</div>


<h4>1.8.7. Resultat esperat</h4>
<p>Subscriviu components a l'estat centralitzat utilitzant subscripcions manuals o l'<code>async</code> pipe per rebre actualitzacions automàtiques.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.9. Exemple pràctic: usuari actual accessible des de qualsevol component</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.9.1. Objectiu</h4>
<p>Implementar un cas pràctic complet on l'estat d'usuari autenticat és accessible des de múltiples components.</p>

<h4>1.9.2. Definir la interfície i el servei</h4>
<p>Primer definiu la interfície de l'usuari i creeu el servei d'estat:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// models/user.interface.ts
export interface User {
  id: number;
  name: string;
  email: string;
  role: &#39;admin&#39; | &#39;user&#39;;
}

// services/auth-state.service.ts
import { Injectable } from &#39;@angular/core&#39;;
import { BehaviorSubject } from &#39;rxjs&#39;;
import { User } from &#39;../models/user.interface&#39;;

@Injectable({ providedIn: &#39;root&#39; })
export class AuthStateService {
  private userSubject = new BehaviorSubject&lt;User | null&gt;(null);
  user$ = this.userSubject.asObservable();

  setUser(user: User | null): void {
    this.userSubject.next(user);
  }

  getCurrentUser(): User | null {
    return this.userSubject.value;
  }

  isAuthenticated(): boolean {
    return this.userSubject.value !== null;
  }

  logout(): void {
    this.userSubject.next(null);
  }
}</code></pre>
  </div>
</div>


<h4>1.9.3. Component de login que actualitza l'estat</h4>
<p>El component de login crida un servei d'autenticació i actualitza l'estat centralitzat:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// components/login/login.component.ts
export class LoginComponent {
  constructor(
    private authService: AuthService,
    private authState: AuthStateService,
    private router: Router
  ) {}

  login(credentials: { email: string; password: string }): void {
    this.authService.login(credentials).subscribe({
      next: (user) =&gt; {
        this.authState.setUser(user); // Actualitza estat central
        this.router.navigate([&#39;/dashboard&#39;]);
      },
      error: (err) =&gt; {
        console.error(&#39;Error de login:&#39;, err);
      }
    });
  }
}</code></pre>
  </div>
</div>


<h4>1.9.4. Header que mostra l'usuari automàticament</h4>
<p>El header se subscriu a l'estat i mostra el nom de l'usuari:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// components/header/header.component.ts
export class HeaderComponent {
  user$ = this.authState.user$;

  constructor(private authState: AuthStateService) {}

  logout(): void {
    this.authState.logout();
  }
}</code></pre>
  </div>
</div>



<div class="code-block" data-lang="html" role="region" aria-label="Bloc de codi html">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">HTML</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-html">&lt;!-- header.component.html --&gt;
&lt;nav&gt;
  &lt;div *ngIf=&quot;user$ | async as user; else notAuthenticated&quot;&gt;
    &lt;span&gt;Benvingut, {{ user.name }}&lt;/span&gt;
    &lt;button (click)=&quot;logout()&quot;&gt;Sortir&lt;/button&gt;
  &lt;/div&gt;
  &lt;ng-template #notAuthenticated&gt;
    &lt;a routerLink=&quot;/login&quot;&gt;Iniciar sessió&lt;/a&gt;
  &lt;/ng-template&gt;
&lt;/nav&gt;</code></pre>
  </div>
</div>


<h4>1.9.5. Sidebar que mostra informació de l'usuari</h4>
<p>El sidebar també accedeix a l'estat sense necessitat de comunicació amb el header:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// components/sidebar/sidebar.component.ts
export class SidebarComponent {
  user$ = this.authState.user$;

  constructor(private authState: AuthStateService) {}
}</code></pre>
  </div>
</div>



<div class="code-block" data-lang="html" role="region" aria-label="Bloc de codi html">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">HTML</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-html">&lt;!-- sidebar.component.html --&gt;
&lt;aside *ngIf=&quot;user$ | async as user&quot;&gt;
  &lt;div class=&quot;user-info&quot;&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;{{ user.email }}&lt;/p&gt;
    &lt;span class=&quot;badge&quot;&gt;{{ user.role }}&lt;/span&gt;
  &lt;/div&gt;
&lt;/aside&gt;</code></pre>
  </div>
</div>


<h4>1.9.6. Verificació de permisos basada en l'estat</h4>
<p>Un component pot verificar permisos consultant l'estat:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// components/admin-panel/admin-panel.component.ts
export class AdminPanelComponent implements OnInit {
  canAccess = false;

  constructor(private authState: AuthStateService) {}

  ngOnInit(): void {
    this.authState.user$.subscribe(user =&gt; {
      this.canAccess = user?.role === &#39;admin&#39;;
    });
  }
}</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Amb l'estat centralitzat, el login actualitza l'estat una vegada i tots els components (header, sidebar, admin-panel) reben la informació automàticament.
</div>


<h4>1.9.7. Resultat esperat</h4>
<p>Implementeu un cas pràctic complet on l'usuari autenticat és accessible des de múltiples components sense comunicació manual entre ells.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.10. Immutabilitat: per què és important no modificar l'estat directament</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.10.1. Objectiu</h4>
<p>Comprendre el principi d'immutabilitat i aprendre a actualitzar l'estat sense modificar l'objecte original.</p>

<h4>1.10.2. Què és la immutabilitat</h4>
<p>La immutabilitat significa que no modifiqueu un objecte existent, sinó que creeu un de nou amb els canvis aplicats. En lloc de canviar <code>user.name = 'Nou nom'</code>, creeu un nou objecte amb l'operador spread: <code>{ ...user, name: 'Nou nom' }</code>.</p>

<h4>1.10.3. Per què és important en gestió d'estat</h4>
<p>Quan modifiqueu un objecte directament, Angular i RxJS poden no detectar el canvi perquè l'objecte (la referència) és el mateix. Els observables comparen referències: si la referència no canvia, no emeten notificacions.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// INCORRECTE: Modificació directa
updateUserName(newName: string): void {
  const user = this.userSubject.value;
  if (user) {
    user.name = newName; // Modifica l&#39;objecte original
    this.userSubject.next(user); // Emet la mateixa referència
  }
}
// Components subscrits NO reben notificació perquè la referència és igual

// CORRECTE: Crear nou objecte
updateUserName(newName: string): void {
  const user = this.userSubject.value;
  if (user) {
    this.userSubject.next({ ...user, name: newName }); // Nova referència
  }
}
// Components subscrits SÍ reben notificació perquè la referència ha canviat</code></pre>
  </div>
</div>


<h4>1.10.4. Immutabilitat amb arrays</h4>
<p>Per modificar arrays, utilitzeu mètodes que retornen nous arrays (<code>map</code>, <code>filter</code>, <code>concat</code>) en lloc de mètodes que modifiquen l'original (<code>push</code>, <code>splice</code>):</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// INCORRECTE: Modificació directa de l&#39;array
addItem(item: CartItem): void {
  const items = this.itemsSubject.value;
  items.push(item); // Modifica l&#39;array original
  this.itemsSubject.next(items); // Mateixa referència
}

// CORRECTE: Crear nou array
addItem(item: CartItem): void {
  const items = this.itemsSubject.value;
  this.itemsSubject.next([...items, item]); // Nou array
}

// CORRECTE: Eliminar element
removeItem(id: number): void {
  const items = this.itemsSubject.value;
  this.itemsSubject.next(items.filter(i =&gt; i.id !== id)); // Nou array filtrat
}</code></pre>
  </div>
</div>


<h4>1.10.5. Immutabilitat amb objectes niats</h4>
<p>Per modificar propietats niades, heu de crear còpies de tots els nivells:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Estructura niada
interface AppState {
  user: User | null;
  settings: {
    theme: string;
    language: string;
  };
}

// INCORRECTE: Modificació niada directa
updateTheme(theme: string): void {
  const state = this.stateSubject.value;
  state.settings.theme = theme; // Modifica niuat directament
  this.stateSubject.next(state);
}

// CORRECTE: Crear còpies de tots els nivells
updateTheme(theme: string): void {
  const state = this.stateSubject.value;
  this.stateSubject.next({
    ...state,
    settings: {
      ...state.settings,
      theme
    }
  });
}</code></pre>
  </div>
</div>


<h4>1.10.6. Avantatges de la immutabilitat</h4>
<ul>
<li><strong>Detecció de canvis fiable:</strong> Angular detecta canvis comparant referències</li>
<li><strong>Historial de canvis:</strong> Podeu guardar estats anteriors sense que es modifiquin</li>
<li><strong>Depuració més fàcil:</strong> Sabeu exactament quin mètode va crear cada versió de l'estat</li>
<li><strong>Proves més simples:</strong> L'estat anterior no canvia, facilitant assertions</li>
</ul>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> No modifiqueu l'estat directament; creeu sempre nous objectes o arrays amb els canvis aplicats per garantir que Angular detecti les actualitzacions.
</div>


<h4>1.10.7. Resultat esperat</h4>
<p>Apliqueu el principi d'immutabilitat creant nous objectes en lloc de modificar directament l'estat existent.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.11. Quan usar gestió d'estat centralitzada: criteri de decisió</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.11.1. Objectiu</h4>
<p>Establir criteris clars per decidir quan implementar gestió d'estat centralitzada i quan utilitzar estat local.</p>

<h4>1.11.2. Regla dels tres components</h4>
<p>Si tres o més components necessiten accedir a les mateixes dades, és un bon candidat per a estat centralitzat. Amb menys de tres components, la comunicació <code>@Input/@Output</code> o un servei simple és suficient.</p>

<table>
<thead>
<tr>
<th>Nombre de components</th>
<th>Solució recomanada</th>
</tr>
</thead>
<tbody>
<tr><td>1</td><td>Estat local del component</td></tr>
<tr><td>2 (pare-fill)</td><td>@Input/@Output</td></tr>
<tr><td>3+</td><td>Estat centralitzat</td></tr>
</tbody>
</table>

<h4>1.11.3. Dades que canvien freqüentment vs dades estables</h4>
<p>Si les dades canvien sovint i múltiples components han de reaccionar als canvis (cistella de compra, filtres actius), l'estat centralitzat és ideal. Si les dades són estables i només es llegeixen (configuració de l'aplicació que només es carrega un cop), un servei simple pot ser suficient.</p>

<h4>1.11.4. Components no relacionats que comparteixen dades</h4>
<p>Quan components que no tenen relació pare-fill han de compartir dades (header i sidebar són germans, no pare-fill), l'estat centralitzat és l'única manera pràctica de sincronitzar-los sense fer passar les dades per múltiples nivells de components intermedis.</p>

<h4>1.11.5. Complexitat de la lògica de gestió</h4>
<p>Si la lògica per gestionar les dades és complexa (validacions, transformacions, persistència), centralitzar-la en un servei d'estat fa que sigui més fàcil de mantenir i provar. Si la lògica és trivial (només guardar i llegir), pot no valer la pena.</p>

<h4>1.11.6. Checklist de decisió</h4>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Més de 2 components necessiten les dades?</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Les dades canvien freqüentment durant l'ús de l'aplicació?</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Components no relacionats (germans, cosins) necessiten sincronitzar-se?</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">La lògica de gestió és complexa (validacions, transformacions)?</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Necessiteu historial de canvis o capacitat de desfer?</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>


<p><strong>Si responeu "sí" a 3 o més preguntes, utilitzeu gestió d'estat centralitzada.</strong></p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Utilitzeu estat centralitzat quan múltiples components no relacionats necessiten dades compartides que canvien freqüentment amb lògica complexa.
</div>


<h4>1.11.7. Resultat esperat</h4>
<p>Apliqueu criteris objectius per decidir quan implementar gestió d'estat centralitzada segons les necessitats de l'aplicació.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.12. Mini exemple pràctic · Servei d'estat per a tema de l'aplicació</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Mini exemple pràctic: Servei d'estat per a tema de l'aplicació</h3>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Crear servei ThemeStateService amb BehaviorSubject (valor inicial: light)</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Exposar theme$ com a Observable públic de només lectura</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Implementar mètode setTheme que actualitza l'estat</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Injectar el servei al HeaderComponent i subscriure's a theme$</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Mostrar al header el tema actual amb interpolació</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Crear botó per canviar entre tema clar i fosc</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Injectar el servei al BodyComponent i aplicar classe CSS segons el tema</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Verificar que quan el botó canvia el tema, tant el header com el body s'actualitzen simultàniament</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>

<p><strong>Resultat esperat:</strong> Una aplicació on el tema es pot canviar des del header i el canvi es propaga automàticament a tots els components subscrits sense comunicació manual.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.13. Resolució de problemes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Possible causa</th>
<th>Solució ràpida</th>
</tr>
</thead>
<tbody>
<tr>
<td>Els components no reben actualitzacions quan canvia l'estat</td>
<td>S'està modificant l'objecte directament sense crear un de nou</td>
<td>Utilitzar operador spread per crear nou objecte: <code>this.subject.next({ ...old, prop: newValue })</code></td>
</tr>
<tr>
<td>Error "Cannot read property 'subscribe' of undefined"</td>
<td>El servei no està injectat correctament o l'Observable no està definit</td>
<td>Verificar que el servei té <code>@Injectable({ providedIn: 'root' })</code> i que l'Observable s'exposa correctament</td>
</tr>
<tr>
<td>Fuita de memòria: l'aplicació es torna lenta amb el temps</td>
<td>Subscripcions manuals sense <code>unsubscribe()</code></td>
<td>Utilitzar <code>async</code> pipe o implementar <code>ngOnDestroy()</code> amb <code>subscription.unsubscribe()</code></td>
</tr>
<tr>
<td>Múltiples components mostren dades desincronitzades</td>
<td>Cada component manté una còpia local en lloc de subscriure's</td>
<td>Eliminar còpies locals i utilitzar <code>async</code> pipe directament: <code>user$ | async</code></td>
</tr>
<tr>
<td>Error "BehaviorSubject is not defined"</td>
<td>No s'ha importat de RxJS</td>
<td>Afegir <code>import { BehaviorSubject } from 'rxjs';</code> al servei</td>
</tr>
<tr>
<td>El valor inicial del BehaviorSubject no es rep als components</td>
<td>El component se subscriu després que el valor hagi canviat</td>
<td>BehaviorSubject hauria d'emetre sempre el valor actual; verificar que s'està subscrivint correctament amb <code>observable.subscribe()</code></td>
</tr>
<tr>
<td>L'aplicació no compila: "Property 'asObservable' does not exist"</td>
<td>Intentar cridar <code>asObservable()</code> sobre un Observable en lloc d'un Subject</td>
<td>Només els Subjects tenen <code>asObservable()</code>; verificar que esteu aplicant-ho al BehaviorSubject, no a l'Observable</td>
</tr>
<tr>
<td>Els canvis d'estat no es veuen reflectits a la vista</td>
<td>Angular no detecta el canvi perquè la referència de l'objecte no ha canviat</td>
<td>Assegurar-se de crear nous objectes/arrays en lloc de modificar els existents</td>
</tr>
</tbody>
</table>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.14. Prompts d'IA</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>1.14.1. Prompt 1</h4>
<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Expert en arquitectura d'aplicacions Angular.<br><br><strong>Context:</strong> Estic desenvolupant una aplicació de gestió de tasques on múltiples components (llista de tasques, comptador de pendents, filtre per prioritat, vista de detall) necessiten accedir a les mateixes tasques.<br><br><strong>Tasca:</strong> Dissenya un servei d'estat centralitzat per gestionar les tasques amb mètodes per afegir, eliminar, actualitzar i filtrar tasques, assegurant que tots els components es mantinguin sincronitzats.<br><br><strong>Format:</strong> Codi TypeScript complet del servei amb interfície de Task i exemple de subscripció d'un component.</div>
  </div>
</div>


<h4>1.14.2. Prompt 2</h4>
<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Instructor de patrons de gestió d'estat en frameworks frontend.<br><br><strong>Context:</strong> Tinc una aplicació Angular amb 5 components que comparteixen informació sobre els productes seleccionats a la cistella de compra. Actualment cada component té la seva pròpia còpia de la cistella i la sincronització es fa amb @Input i @Output.<br><br><strong>Tasca:</strong> Refactoritza l'arquitectura actual per implementar un servei d'estat centralitzat utilitzant BehaviorSubject que elimini la necessitat de @Input/@Output i asseguri sincronització automàtica.<br><br><strong>Format:</strong> Codi abans i després mostrant la transformació del component amb @Input/@Output a component amb subscripció al servei d'estat, incloent el servei complet.</div>
  </div>
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.15. Autoavaluació</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Autoavaluació</h3>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Identifico situacions on múltiples components no relacionats necessiten compartir les mateixes dades globals</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Creo serveis d'estat utilitzant BehaviorSubject privat i exposant Observable públic de només lectura</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Implemento mètodes d'actualització d'estat que creen nous objectes en lloc de modificar els existents (immutabilitat)</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Subscric components a l'estat centralitzat utilitzant l'async pipe o subscripcions manuals amb ngOnDestroy</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Aplico criteris objectius per decidir quan usar estat centralitzat vs estat local segons el nombre de components i la complexitat</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.16. Síntesi</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Síntesi</h3>
<ul>
<li>La gestió d'estat centralitzada resol el problema de múltiples components que necessiten accedir a les mateixes dades globals eliminant duplicació, sincronització manual i cables de comunicació entre components.</li>
<li>El patró de flux unidireccional garanteix que les dades sempre flueixen des del servei d'estat cap als components, mai a l'inrevés, millorant la predictibilitat, testabilitat i depuració del codi.</li>
<li>Un servei d'estat típic utilitza <code>BehaviorSubject</code> privat per emmagatzemar l'estat actual, <code>Observable</code> públic per exposar-lo de només lectura, i mètodes controlats per actualitzar l'estat de manera immutable.</li>
<li>Els components se subscriuen a l'observable exposat pel servei i reben actualitzacions automàtiques cada cop que l'estat canvia, utilitzant l'<code>async</code> pipe per evitar gestió manual de subscripcions.</li>
<li>El principi d'immutabilitat és fonamental: mai modifiqueu l'estat directament, sempre creeu nous objectes o arrays amb l'operador spread per garantir que Angular detecti els canvis i notifiqui els subscriptors.</li>
</ul>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">1.17. Repàs de conceptes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Conceptes clau</h3>
<ul>
<li><strong>Gestió d'estat centralitzada:</strong> Patró on totes les dades globals es guarden en serveis dedicats accessibles des de qualsevol component sense comunicació manual.</li>
<li><strong>BehaviorSubject:</strong> Tipus especial d'observable que emmagatzema i emet l'últim valor als nous subscriptors immediatament.</li>
<li><strong>Observable de només lectura:</strong> Exposar l'estat com a <code>Observable</code> (amb <code>asObservable()</code>) per evitar que components modifiquin l'estat directament.</li>
<li><strong>Flux unidireccional:</strong> Patró on les dades sempre flueixen des de l'estat cap als components; components no modifiquen l'estat directament sinó via mètodes del servei.</li>
<li><strong>Immutabilitat:</strong> Principi de crear nous objectes/arrays en lloc de modificar els existents per garantir detecció de canvis fiable.</li>
<li><strong>Font única de veritat:</strong> L'estat global està en un únic lloc, eliminant inconsistències entre còpies duplicades a diferents components.</li>
<li><strong>Subscripció:</strong> Mecanisme pel qual un component escolta canvis d'un observable i rep notificacions automàtiques quan l'estat canvia.</li>
<li><strong>async pipe:</strong> Pipe d'Angular que gestiona automàticament subscripció i desubscripció, evitant fuites de memòria.</li>
<li><strong>Estat distribuït vs centralitzat:</strong> Estat distribuït manté dades locals a cada component; estat centralitzat guarda dades globals en serveis compartits.</li>
<li><strong>Regla dels tres components:</strong> Si tres o més components necessiten les mateixes dades, és candidat ideal per a estat centralitzat.</li>
<li><strong>Detecció de canvis:</strong> Mecanisme d'Angular per detectar quan les dades canvien i actualitzar la vista; depèn de comparar referències d'objectes.</li>
<li><strong>Fuita de memòria:</strong> Problema quan subscripcions manuals no es cancelen amb <code>unsubscribe()</code>, causant que callbacks segueixin actius innecessàriament.</li>
</ul>
  
  </div>
</div>


</div>

<div class="section" id="Unitat4_Bloc2_Seccio2">
  <h2 id="Unitat4_Bloc2_Seccio2">2. Organització en mòduls i càrrega per seccions (lazy loading)</h2>

  <!-- MULTIMÈDIA -->
  <!--
  ════════════════════════════════════════════════════════════════
  Component: Enllaços multimèdia YouTube
  ════════════════════════════════════════════════════════════════

  Paràmetres:
    - unitat: número de la unitat (1-4)
    - bloc: número del bloc (1-4)
    - seccio: número de la secció (1-3)

  Exemple d'ús:
    {% include multimedia-youtube.html unitat=1 bloc=1 seccio=1 %}

  El component busca automàticament les URLs corresponents a
  site.data.multimedia i mostra els botons de vídeo i àudio.
  ════════════════════════════════════════════════════════════════
-->





  
  
  
  
  

  

  

  
<div class="multimedia-resources">
  <div class="multimedia-header">
    <i class="bi bi-play-circle-fill"></i>
    <span>Contingut multimèdia d'aquesta lectura</span>
  </div>

  <div class="multimedia-buttons">
    
    <a href="https://www.youtube.com/watch?v=-LFePw_VZeY" target="_blank" rel="noopener noreferrer" class="multimedia-btn video-btn" title="Lectura 4.2.2 · Organització en mòduls i càrrega per seccions (lazyloading)">
      <i class="bi bi-youtube"></i>
      <span>Veure vídeo</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    

    
    <a href="https://www.youtube.com/watch?v=e8I-D4-mDtU" target="_blank" rel="noopener noreferrer" class="multimedia-btn audio-btn" title="[Audio] Lectura 4.2.2 · Organització en mòduls i càrrega per seccions (lazyloading)">
      <i class="bi bi-mic-fill"></i>
      <span>Escoltar àudio</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    
  </div>

  
  
</div>
  




  <!-- Component: Objectius del bloc/unitat -->



<div class="objectius-box">
  <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-bullseye" aria-hidden="true"></i> Objectius</div>
  <div class="component-content">
    <ul>
      
        <li>Dividir l'aplicació en mòduls funcionals que agrupen components, serveis i rutes relacionats</li>
      
        <li>Configurar rutes amb lazy loading per carregar mòduls només quan l'usuari els necessita</li>
      
        <li>Implementar una estratègia de càrrega que optimitzi el temps de càrrega inicial de l'aplicació</li>
      
        <li>Mesurar l'impacte del lazy loading en el rendiment utilitzant eines de desenvolupador</li>
      
    </ul>
  </div>
  <!-- IMPORTANT: també es pot usar via front matter: page.objectius (array) -->
</div>



  <!-- Component: Caixa informativa -->
<div class="info-box" role="note">
    <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-info-circle" aria-hidden="true"></i> Informació</div>
    <strong>RA4 · Criteri 4</strong> — Optimitza els recursos i genera un paquet llest per a publicació.
    
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.1. Prerequisits</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Unitat 4.1 completada:</strong> Heu configurat el sistema de rutes i sabeu crear rutes bàsiques amb components associats.</li>
<li><strong>Conceptes de components:</strong> Comprensió de com crear i organitzar components en carpetes.</li>
<li><strong>Serveis i injecció de dependències:</strong> Sabeu crear serveis i injectar-los als components.</li>
<li><strong>CLI d'Angular:</strong> Domini de comandes bàsiques per generar mòduls i components (<code>ng generate</code>).</li>
<li><strong>Estructura de projecte:</strong> Enteneu l'organització actual del vostre projecte amb <code>src/app/</code>.</li>
</ul>

<p><strong>Verificació ràpida:</strong></p>


<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash"># Verificar que teniu el projecte amb rutes funcionals
ng serve --open
# Navegar entre diferents rutes i comprovar que funcionen</code></pre>
  </div>
</div>


<p><strong>Punt d'autocomprovació:</strong> L'aplicació s'obre al navegador, podeu navegar entre diferents pàgines, i enteneu on estan definides les rutes actuals.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.2. Marc conceptual</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.2.1. Què és la modularització amb lazy loading</h4>
<p>La modularització és l'organització de l'aplicació en unitats lògiques independents (mòduls) que agrupen funcionalitats relacionades. El lazy loading (càrrega diferida) carrega aquests mòduls només quan l'usuari els necessita, no durant la càrrega inicial. Això redueix dràsticament el temps que l'aplicació triga a estar operativa.</p>

<h4>2.2.2. Problema sense modularització i lazy loading</h4>
<p><strong>Situació abans:</strong></p>
<p>Tota l'aplicació es carrega d'un sol cop quan l'usuari obre la pàgina inicial. Tots els components, serveis, llibreries i codi de totes les funcionalitats es descarreguen immediatament, encara que l'usuari només necessiti veure la pàgina d'inici.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Fitxer únic compilat: main.js (3.2 MB)
├── Codi de login i registre (300 KB)
├── Codi de dashboard (450 KB)
├── Codi d&#39;administració (800 KB)
├── Codi de preferits (200 KB)
├── Codi de cerca avançada (350 KB)
├── Codi de gestió de perfil (250 KB)
└── Llibreries compartides (850 KB)

Temps de càrrega inicial: 8-12 segons amb connexió mitjana</code></pre>
  </div>
</div>


<p>L'usuari espera 10 segons per veure la pàgina d'inici, tot i que només accedirà a administració si és admin (10% dels usuaris).</p>

<p><strong>Problemes que genera:</strong></p>

<p><strong>1. Temps de càrrega inicial inacceptable</strong></p>
<p>Amb aplicacions grans, el fitxer principal pot pesar 3-5 MB. En connexions mòbils o 3G, això significa 10-15 segons de pantalla blanca abans que l'usuari vegi res. El 53% dels usuaris abandonen un lloc web que triga més de 3 segons a carregar (dades de Google). Esteu perdent la meitat dels vostres usuaris potencials per mala optimització.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Connexió 4G (10 Mbps): 3.2 MB → 2.5 segons
Connexió 3G (2 Mbps): 3.2 MB → 12.8 segons
Connexió lenta (750 Kbps): 3.2 MB → 34 segons</code></pre>
  </div>
</div>


<p><strong>2. Desperdici de recursos en funcionalitats no utilitzades</strong></p>
<p>Si el 90% dels usuaris són usuaris normals que mai accedeixen al panell d'administració, esteu forçant-los a descarregar 800 KB de codi d'administració que mai utilitzaran. Això és com portar 50 kg de roba a un viatge de cap de setmana "per si de cas".</p>
<p>Un estudi de Chrome revela que el 60% del codi JavaScript descarregat en una aplicació web típica mai s'executa. Esteu malgastant ample de banda i recursos de processador dels vostres usuaris.</p>

<p><strong>3. Dificultat per mantenir i organitzar codi gran</strong></p>
<p>Quan tot el codi està en un únic lloc, trobar components específics es complica. Teniu 150 components en una única carpeta plana <code>src/app/components/</code>. Localitzar el component que necessiteu modificar requereix desplaçar-se per llistes interminables. Els conflictes en control de versions augmenten perquè múltiples desenvolupadors treballen en el mateix espai.</p>

<p><strong>4. Temps de compilació incrementals massa llargs</strong></p>
<p>Cada cop que modifiqueu un component, Angular ha de recompilar tota l'aplicació perquè tot està interconnectat. Una aplicació sense modularitzar pot trigar 15-20 segons a recompilar després d'un canvi petit. Això destrueix la productivitat: feu un canvi d'una línia, espereu 20 segons, veieu el resultat, repetiu.</p>

<p><strong>5. Impossibilitat de treball en equip eficient</strong></p>
<p>Quan diferents equips treballen en funcionalitats diferents (equip de dashboard, equip d'administració, equip de cerca), tots modifiquen fitxers al mateix directori. Els conflictes de merge es multipliquen. No podeu assignar clarament responsabilitats: "l'equip A s'encarrega del mòdul d'administració" no té sentit si tot és un monolit.</p>

<h4>2.2.3. Solució amb modularització i lazy loading</h4>
<p>Dividiu l'aplicació en mòduls funcionals independents que es carreguen només quan l'usuari accedeix a aquella funcionalitat. El fitxer inicial conté només el codi essencial; la resta es carrega sota demanda.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>Càrrega inicial ràpida:</strong> Només es carrega el codi essencial (200-500 KB en lloc de 3 MB)</li>
<li><strong>Escalabilitat:</strong> Podeu afegir noves funcionalitats sense augmentar el temps de càrrega inicial</li>
<li><strong>Organització clara:</strong> Cada funcionalitat té el seu propi mòdul amb components i serveis</li>
<li><strong>Millor experiència d'usuari:</strong> L'aplicació respon en 1-2 segons, no 10-15 segons</li>
<li><strong>Treball en equip eficient:</strong> Equips treballen en mòduls independents amb menys conflictes</li>
</ol>

<h4>2.2.4. Exemple real complet: Sense vs Amb lazy loading</h4>
<p><strong>Situació:</strong> Una aplicació de comerç electrònic amb catàleg de productes (pàgina principal), panell d'administració, i pàgina de preferits.</p>

<p><strong>Sense lazy loading:</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app-routing.module.ts - TOT ES CARREGA IMMEDIATAMENT
import { ProductListComponent } from &#39;./products/product-list.component&#39;;
import { ProductDetailComponent } from &#39;./products/product-detail.component&#39;;
import { AdminDashboardComponent } from &#39;./admin/admin-dashboard.component&#39;;
import { AdminUsersComponent } from &#39;./admin/admin-users.component&#39;;
import { FavoritesComponent } from &#39;./favorites/favorites.component&#39;;

const routes: Routes = [
  { path: &#39;&#39;, component: ProductListComponent },
  { path: &#39;product/:id&#39;, component: ProductDetailComponent },
  { path: &#39;admin&#39;, component: AdminDashboardComponent },
  { path: &#39;admin/users&#39;, component: AdminUsersComponent },
  { path: &#39;favorites&#39;, component: FavoritesComponent }
];</code></pre>
  </div>
</div>


<p>Resultat: <strong>main.js = 3.2 MB</strong>, càrrega inicial = 12 segons en 3G.</p>

<p><strong>Amb lazy loading:</strong></p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app-routing.module.ts - NOMÉS CARREGA EL QUE ES NECESSITA
const routes: Routes = [
  {
    path: &#39;&#39;,
    loadChildren: () =&gt; import(&#39;./products/products.module&#39;).then(m =&gt; m.ProductsModule)
  },
  {
    path: &#39;admin&#39;,
    loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule)
  },
  {
    path: &#39;favorites&#39;,
    loadChildren: () =&gt; import(&#39;./favorites/favorites.module&#39;).then(m =&gt; m.FavoritesModule)
  }
];</code></pre>
  </div>
</div>


<p>Resultat: <strong>main.js = 450 KB</strong>, càrrega inicial = 2 segons en 3G. Els mòduls admin (800 KB) i favorites (200 KB) es carreguen només quan l'usuari hi accedeix.</p>

<h4>2.2.5. Taula comparativa: Abans vs Després</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Sense lazy loading</th>
<th>Amb lazy loading</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mida inicial (main.js)</strong></td>
<td>3.2 MB</td>
<td>450 KB</td>
</tr>
<tr>
<td><strong>Temps càrrega 3G</strong></td>
<td>12.8 segons</td>
<td>2 segons</td>
</tr>
<tr>
<td><strong>Temps fins interactiu</strong></td>
<td>15 segons</td>
<td>3 segons</td>
</tr>
<tr>
<td><strong>% usuaris que abandonen</strong></td>
<td>53%</td>
<td>12%</td>
</tr>
<tr>
<td><strong>Codi no utilitzat descarregat</strong></td>
<td>1.9 MB (60%)</td>
<td>0 KB</td>
</tr>
<tr>
<td><strong>Temps recompilació dev</strong></td>
<td>18 segons</td>
<td>4 segons</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El lazy loading redueix el temps de càrrega inicial de 12.8 segons a 2 segons (millora del 84%), i elimina la descàrrega de codi no utilitzat (1.9 MB estalviats).
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.3. Model mental</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Biblioteca modular d'una ciutat</strong></p>
<p>Una biblioteca gran no posa tots els llibres en una única sala gegant. Organitza els llibres en sales temàtiques: sala de ciència, sala d'història, sala infantil. Quan entres a la biblioteca, només accedeixes a la sala que necessites. Els llibres de les altres sales no ocupen el teu espai mental. Els mòduls funcionen igual: cada "sala" (mòdul) s'obre només quan la necessites.</p>

<p><strong>Apartament amb habitacions tancades</strong></p>
<p>Quan arribes a casa, no encens els llums de totes les habitacions simultàniament. Encens el llum del rebedor, i després obres les habitacions que necessites. El lazy loading funciona així: l'aplicació "encén" només el mòdul inicial, i després carrega cada mòdul (habitació) quan l'usuari hi "entra" navegant a aquella ruta.</p>

<p><strong>Restaurant amb cuina a la carta</strong></p>
<p>Un restaurant no prepara tots els plats del menú quan obre. Prepara cada plat quan un client el demana. Això estalvia temps, ingredients i espai a la cuina. De la mateixa manera, el lazy loading no "cuina" (carrega) tot el codi al principi; prepara cada mòdul quan l'usuari l'accedeix.</p>

<p><strong>Caixes en un magatzem amb etiquetes</strong></p>
<p>Imagineu un magatzem amb 50 caixes. No obriu totes les caixes al matí per veure què hi ha dins. Cada caixa té una etiqueta, i només obriu la caixa que necessiteu en aquell moment. Els mòduls són com caixes etiquetades: sabeu què contenen (components, serveis), i només les "obriu" (carrega) quan les necessiteu.</p>

<p><strong>Sistema de transport públic amb zones</strong></p>
<p>Una ciutat no envia tots els autobusos de totes les línies simultàniament a l'hora punta. Cada línia d'autobús (mòdul) opera independentment. Quan agafes la línia 5, no estàs esperant que arribin també les línies 1, 2, 3 i 4. El lazy loading carrega només la "línia" (mòdul) que has demanat.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.4. Què són els mòduls: agrupacions lògiques de funcionalitat</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.4.1. Objectiu</h4>
<p>Comprendre què és un mòdul d'Angular i per què agrupar funcionalitats relacionades en mòduls independents.</p>

<h4>2.4.2. Definició de mòdul</h4>
<p>Un mòdul d'Angular (<code>NgModule</code>) és una classe decorada amb <code>@NgModule()</code> que agrupa components, serveis, directives i pipes relacionats amb una funcionalitat específica. Cada mòdul és una unitat cohesiva que pot importar-se i reutilitzar-se.</p>
<p>Angular té sempre almenys un mòdul: l'<code>AppModule</code> (mòdul principal). Però en aplicacions grans, creeu mòduls addicionals per organitzar la funcionalitat.</p>

<h4>2.4.3. Analogia del mòdul com a caixa d'eines</h4>
<p>Penseu en un mòdul com una caixa d'eines especialitzada. Un fuster té una caixa per treballar la fusta (serres, formó, nivell) i una altra per acabats (pinzells, lija, vernís). No barreja totes les eines en una única caixa gegant; les organitza per funcionalitat.</p>
<p>De la mateixa manera, en lloc de tenir tots els 150 components en un únic <code>AppModule</code>, creeu:</p>
<ul>
<li><code>ProductsModule</code>: components i serveis per gestionar productes</li>
<li><code>AdminModule</code>: components i serveis per administració</li>
<li><code>AuthModule</code>: components i serveis d'autenticació</li>
</ul>

<h4>2.4.4. Estructura d'un mòdul típic</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// products.module.ts
import { NgModule } from &#39;@angular/core&#39;;
import { CommonModule } from &#39;@angular/common&#39;;
import { ProductListComponent } from &#39;./product-list/product-list.component&#39;;
import { ProductDetailComponent } from &#39;./product-detail/product-detail.component&#39;;
import { ProductsRoutingModule } from &#39;./products-routing.module&#39;;

@NgModule({
  declarations: [
    ProductListComponent,    // Components del mòdul
    ProductDetailComponent
  ],
  imports: [
    CommonModule,            // Mòduls que necessita
    ProductsRoutingModule    // Rutes del mòdul
  ],
  providers: []              // Serveis específics del mòdul
})
export class ProductsModule { }</code></pre>
  </div>
</div>


<p>Aquest mòdul encapsula tota la funcionalitat de productes: llista, detall, i les seves rutes.</p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Un mòdul agrupa components, serveis i rutes relacionats amb una funcionalitat específica, mantenint l'organització clara i escalable.
</div>


<h4>2.4.5. Resultat esperat</h4>
<p>Comprensió del concepte de mòdul d'Angular i la seva utilitat per agrupar funcionalitats relacionades.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.5. Avantatges de modularitzar: organització, reutilització, mantenibilitat</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.5.1. Objectiu</h4>
<p>Identificar els beneficis concrets que proporciona l'organització en mòduls.</p>

<h4>2.5.2. Organització clara i escalable</h4>
<p>Amb mòduls, l'estructura de carpetes reflecteix clarament les funcionalitats de l'aplicació:</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">src/app/
├── core/               (Mòdul amb serveis globals)
├── shared/             (Mòdul amb components reutilitzables)
├── products/           (Mòdul de productes)
│   ├── product-list/
│   ├── product-detail/
│   └── products.module.ts
├── admin/              (Mòdul d&#39;administració)
│   ├── dashboard/
│   ├── users/
│   └── admin.module.ts
└── app.module.ts</code></pre>
  </div>
</div>


<p>Trobar codi relacionat amb productes és trivial: tot està dins de <code>products/</code>. No cal buscar entre 150 components.</p>

<h4>2.5.3. Reutilització entre projectes</h4>
<p>Un mòdul ben dissenyat és autocontingut i es pot reutilitzar en altres projectes. Per exemple, si creeu un <code>AuthModule</code> amb login, registre i recuperació de contrasenya, podeu copiar aquesta carpeta sencera a un altre projecte i funciona sense modificacions.</p>
<p>Això accelera el desenvolupament de nous projectes: en lloc de reescriure autenticació cada vegada, reutilitzeu el mòdul existent.</p>

<h4>2.5.4. Mantenibilitat i reducció de conflictes</h4>
<p>Quan equips diferents treballen en mòduls diferents, els conflictes de merge es redueixen dràsticament. L'equip A modifica fitxers dins de <code>admin/</code>, l'equip B modifica fitxers dins de <code>products/</code>. Rarament toquen els mateixos fitxers.</p>
<p>A més, quan cal corregir un error relacionat amb administració, sabeu que el problema està dins del mòdul <code>AdminModule</code>. No cal revisar tota l'aplicació.</p>

<h4>2.5.5. Compilació incremental més ràpida</h4>
<p>Angular pot compilar només els mòduls que han canviat. Si modifiqueu un component dins de <code>ProductsModule</code>, Angular recompila només aquest mòdul, no <code>AdminModule</code> ni <code>AuthModule</code>. Això redueix el temps de recompilació de 18 segons a 4 segons.</p>

<h4>2.5.6. Proves unitàries més senzilles</h4>
<p>Provar un mòdul aïlladament és més fàcil que provar tota l'aplicació. Podeu carregar només <code>ProductsModule</code> en les proves i verificar que funciona correctament sense preocupar-vos per interferències d'altres mòduls.</p>

<table>
<thead>
<tr>
<th>Avantatge</th>
<th>Benefici pràctic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Organització</strong></td>
<td>Trobar codi en 10 segons vs 5 minuts</td>
</tr>
<tr>
<td><strong>Reutilització</strong></td>
<td>Estalviar 20 hores en projectes futurs</td>
</tr>
<tr>
<td><strong>Mantenibilitat</strong></td>
<td>Localitzar errors en minuts vs hores</td>
</tr>
<tr>
<td><strong>Compilació</strong></td>
<td>Recompilar en 4s vs 18s</td>
</tr>
<tr>
<td><strong>Proves</strong></td>
<td>Executar proves unitàries 3x més ràpid</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> La modularització millora l'organització, reutilització, mantenibilitat, temps de compilació i facilitat de proves de manera significativa.
</div>


<h4>2.5.7. Resultat esperat</h4>
<p>Identificació dels avantatges concrets de modularitzar l'aplicació i com impacten positivament el desenvolupament.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.6. Crear mòdul funcional: agrupant components, serveis i rutes relacionats</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.6.1. Objectiu</h4>
<p>Crear un mòdul funcional complet que agrupa components, serveis i rutes d'una funcionalitat específica.</p>

<h4>2.6.2. Generar mòdul amb CLI</h4>
<p>Angular CLI facilita la creació de mòduls amb una comanda:</p>


<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash">ng generate module admin --routing
# o forma abreujada:
ng g m admin --routing</code></pre>
  </div>
</div>


<p>Això crea:</p>

<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">src/app/admin/
├── admin-routing.module.ts   (Rutes del mòdul)
└── admin.module.ts            (Definició del mòdul)</code></pre>
  </div>
</div>


<p>El flag <code>--routing</code> crea automàticament el fitxer de rutes del mòdul.</p>

<h4>2.6.3. Afegir components al mòdul</h4>
<p>Genereu components dins del mòdul:</p>


<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash">ng g c admin/dashboard
ng g c admin/users</code></pre>
  </div>
</div>


<p>Angular CLI detecta que esteu dins de <code>admin/</code> i afegeix automàticament els components a <code>admin.module.ts</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// admin.module.ts
import { NgModule } from &#39;@angular/core&#39;;
import { CommonModule } from &#39;@angular/common&#39;;
import { AdminRoutingModule } from &#39;./admin-routing.module&#39;;
import { DashboardComponent } from &#39;./dashboard/dashboard.component&#39;;
import { UsersComponent } from &#39;./users/users.component&#39;;

@NgModule({
  declarations: [
    DashboardComponent,
    UsersComponent
  ],
  imports: [
    CommonModule,
    AdminRoutingModule
  ]
})
export class AdminModule { }</code></pre>
  </div>
</div>


<h4>2.6.4. Configurar rutes del mòdul</h4>
<p>Definiu les rutes internes del mòdul a <code>admin-routing.module.ts</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// admin-routing.module.ts
import { NgModule } from &#39;@angular/core&#39;;
import { RouterModule, Routes } from &#39;@angular/router&#39;;
import { DashboardComponent } from &#39;./dashboard/dashboard.component&#39;;
import { UsersComponent } from &#39;./users/users.component&#39;;

const routes: Routes = [
  { path: &#39;&#39;, component: DashboardComponent },        // /admin
  { path: &#39;users&#39;, component: UsersComponent }        // /admin/users
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class AdminRoutingModule { }</code></pre>
  </div>
</div>


<p><strong>Nota important:</strong> Utilitzeu <code>RouterModule.forChild(routes)</code> als mòduls funcionals, NO <code>forRoot()</code>. El <code>forRoot()</code> només s'usa a l'<code>AppModule</code>.</p>

<h4>2.6.5. Afegir serveis al mòdul (opcional)</h4>
<p>Si el mòdul necessita serveis específics, creeu-los dins del mòdul:</p>


<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash">ng g s admin/services/user-management</code></pre>
  </div>
</div>


<p>Podeu proporcionar el servei a nivell de mòdul si voleu que només existeixi dins del mòdul:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// admin.module.ts
import { UserManagementService } from &#39;./services/user-management.service&#39;;

@NgModule({
  // ...
  providers: [UserManagementService]  // Servei específic del mòdul
})
export class AdminModule { }</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Un mòdul funcional agrupa components, serveis i rutes relacionats, creats amb CLI i configurats amb routing propi mitjançant RouterModule.forChild().
</div>


<h4>2.6.6. Resultat esperat</h4>
<p>Creació de mòduls funcionals complets amb components, serveis i rutes agrupats lògicament.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.7. Importar mòduls: com integrar-los a l'aplicació principal</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.7.1. Objectiu</h4>
<p>Aprendre a importar mòduls a l'aplicació principal i comprendre la diferència entre eager i lazy loading.</p>

<h4>2.7.2. Importació eager (càrrega immediata)</h4>
<p>Per importar un mòdul de manera eager, l'afegiu a la llista <code>imports</code> de l'<code>AppModule</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app.module.ts
import { NgModule } from &#39;@angular/core&#39;;
import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { AppRoutingModule } from &#39;./app-routing.module&#39;;
import { AppComponent } from &#39;./app.component&#39;;
import { AdminModule } from &#39;./admin/admin.module&#39;;  // Import eager

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    AdminModule,        // Mòdul carregat immediatament
    AppRoutingModule    // AppRoutingModule sempre últim
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
  </div>
</div>


<p>Amb aquesta configuració, tot el codi de <code>AdminModule</code> es carrega immediatament quan l'aplicació arrenca.</p>

<h4>2.7.3. Configurar ruta per a mòdul eager</h4>
<p>Quan importeu un mòdul eager, les seves rutes s'integren automàticament. No cal fer res especial a <code>app-routing.module.ts</code>; les rutes del mòdul ja estan disponibles.</p>
<p>Però sovint voleu prefixar les rutes del mòdul:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app-routing.module.ts
const routes: Routes = [
  { path: &#39;&#39;, component: HomeComponent },
  { path: &#39;admin&#39;, loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule) }
];</code></pre>
  </div>
</div>


<p><strong>Nota:</strong> Amb <code>loadChildren</code>, passem de eager a lazy. Més endavant veurem això en detall.</p>

<h4>2.7.4. Ordre d'importació de mòduls</h4>
<p><strong>Crític:</strong> L'ordre d'importació dels mòduls dins de <code>imports</code> és important. L'<code>AppRoutingModule</code> ha d'anar sempre últim:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">imports: [
  BrowserModule,
  SharedModule,       // Mòduls compartits primer
  AdminModule,        // Mòduls funcionals després
  AppRoutingModule    // AppRoutingModule SEMPRE ÚLTIM
]</code></pre>
  </div>
</div>


<p>Si poseu <code>AppRoutingModule</code> abans que altres mòduls amb rutes, les rutes d'aquests mòduls es poden ignorar perquè el router troba primer la ruta genèrica <code>{ path: '**' }</code> de l'<code>AppRoutingModule</code>.</p>

<h4>2.7.5. Diferència entre forRoot() i forChild()</h4>
<ul>
<li><strong><code>forRoot()</code>:</strong> Només s'usa una vegada a l'<code>AppModule</code>. Configura el router amb configuració global.</li>
<li><strong><code>forChild()</code>:</strong> S'usa a tots els mòduls funcionals. Afegeix rutes al router sense duplicar la configuració global.</li>
</ul>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// AppModule
RouterModule.forRoot(routes)  // Configura router globalment

// Mòduls funcionals
RouterModule.forChild(routes) // Afegeix rutes sense reconfigurar</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Els mòduls es poden importar de manera eager (càrrega immediata) afegint-los a imports de l'AppModule, tenint cura de l'ordre d'importació.
</div>


<h4>2.7.6. Resultat esperat</h4>
<p>Importació de mòduls a l'aplicació principal i comprensió de la diferència entre forRoot() i forChild().</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.8. Lazy loading: càrrega diferida de mòduls quan es necessiten</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.8.1. Objectiu</h4>
<p>Comprendre el concepte de lazy loading i per què és fonamental per optimitzar el rendiment.</p>

<h4>2.8.2. Què és el lazy loading</h4>
<p>Lazy loading (càrrega diferida) és la tècnica de carregar parts del codi només quan l'usuari les necessita. En lloc de descarregar tot el codi al principi, l'aplicació descarrega el codi mínim necessari, i després carrega mòduls addicionals sota demanda.</p>
<p>Això redueix dràsticament el temps de càrrega inicial perquè el navegador només descarrega, parseja i executa el codi essencial.</p>

<h4>2.8.3. Com funciona internament</h4>
<p>Quan configureu lazy loading, Angular:</p>
<ol>
<li>Compila cada mòdul lazy en un fitxer JavaScript separat (chunk)</li>
<li>Durant la càrrega inicial, NO inclou aquests chunks al fitxer principal</li>
<li>Quan l'usuari navega a una ruta lazy, Angular descarrega el chunk corresponent</li>
<li>Una vegada descarregat, Angular carrega el mòdul i renderitza els components</li>
</ol>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Usuari obre aplicació
  ↓
Descarrega main.js (450 KB)
  ↓
Aplicació operativa en 2 segons
  ↓
Usuari clica &quot;Admin&quot;
  ↓
Descarrega admin.chunk.js (800 KB) en background
  ↓
Mòdul admin operatiu en 1 segon</code></pre>
  </div>
</div>


<h4>2.8.4. Avantatges del lazy loading</h4>
<p><strong>Temps de càrrega inicial reduït:</strong> El fitxer principal és 70-80% més petit. Una aplicació de 3.2 MB es redueix a 450 KB. Això significa temps de càrrega inicial de 2-3 segons en lloc de 10-15 segons.</p>
<p><strong>Millor experiència d'usuari:</strong> L'usuari veu contingut i pot interactuar amb l'aplicació molt més ràpidament. La percepció de velocitat millora dràsticament.</p>
<p><strong>Estalvi d'ample de banda:</strong> Els usuaris només descarreguen el codi que realment utilitzen. Si un usuari mai accedeix a l'administració, mai descarrega els 800 KB de codi d'admin. Això és especialment important en connexions mòbils amb dades limitades.</p>
<p><strong>Escalabilitat sense penalització:</strong> Podeu afegir noves funcionalitats (nous mòduls lazy) sense augmentar el temps de càrrega inicial. Cada nova funcionalitat és un nou chunk que es carrega sota demanda.</p>

<h4>2.8.5. Quan es carrega un mòdul lazy</h4>
<p>Un mòdul lazy es carrega la primera vegada que l'usuari navega a una ruta d'aquell mòdul. Després de carregar-se, queda en memòria i ja no cal tornar-lo a descarregar.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Usuari accedeix /products → ProductsModule es carrega
Usuari accedeix /product/123 → ProductsModule ja està carregat, no es descarrega novament
Usuari accedeix /admin → AdminModule es carrega per primera vegada
Usuari accedeix /admin/users → AdminModule ja està carregat</code></pre>
  </div>
</div>


<h4>2.8.6. Comparativa de càrrega</h4>
<table>
<thead>
<tr>
<th>Mètode</th>
<th>Mida inicial</th>
<th>Temps 3G</th>
<th>Codi no utilitzat</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Eager (tot immediatament)</strong></td>
<td>3.2 MB</td>
<td>12.8s</td>
<td>60%</td>
</tr>
<tr>
<td><strong>Lazy (sota demanda)</strong></td>
<td>450 KB</td>
<td>2s</td>
<td>0%</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El lazy loading carrega mòduls només quan l'usuari els necessita, reduint dràsticament el temps de càrrega inicial i millorant l'experiència d'usuari.
</div>


<h4>2.8.7. Resultat esperat</h4>
<p>Comprensió del concepte de lazy loading, com funciona internament i els seus avantatges en rendiment.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.9. Configurar rutes amb lazy loading: sintaxi específica</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.9.1. Objectiu</h4>
<p>Implementar lazy loading configurant rutes amb la sintaxi <code>loadChildren</code> i imports dinàmics.</p>

<h4>2.9.2. Sintaxi de lazy loading</h4>
<p>Per configurar una ruta lazy, utilitzeu <code>loadChildren</code> amb una funció que retorna una promise d'importació dinàmica:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app-routing.module.ts
const routes: Routes = [
  { path: &#39;&#39;, component: HomeComponent },
  {
    path: &#39;admin&#39;,
    loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule)
  },
  {
    path: &#39;products&#39;,
    loadChildren: () =&gt; import(&#39;./products/products.module&#39;).then(m =&gt; m.ProductsModule)
  }
];</code></pre>
  </div>
</div>


<p><strong>Nota important:</strong> NO importeu el mòdul a la part superior del fitxer quan useu lazy loading. L'import dinàmic <code>import()</code> dins de <code>loadChildren</code> és l'única importació necessària.</p>

<h4>2.9.3. Anatomia de loadChildren</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule)
//            ↑    ↑                                ↑       ↑
//            │    │                                │       └─ Classe del mòdul
//            │    │                                └───────── Promesa resolta
//            │    └────────────────────────────────────────── Import dinàmic
//            └─────────────────────────────────────────────── Funció arrow</code></pre>
  </div>
</div>


<ol>
<li><strong>Funció arrow:</strong> <code>() =&gt;</code> crea una funció que s'executa quan l'usuari accedeix a la ruta</li>
<li><strong>Import dinàmic:</strong> <code>import('./admin/admin.module')</code> carrega el mòdul de manera asíncrona</li>
<li><strong>Promesa resolta:</strong> <code>.then(m =&gt; m.AdminModule)</code> retorna la classe del mòdul quan s'ha carregat</li>
</ol>

<h4>2.9.4. Eliminar importació eager del mòdul</h4>
<p>Si prèviament teníeu el mòdul importat a l'<code>AppModule</code>, elimineu aquesta importació:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app.module.ts

// ELIMINAR si useu lazy loading:
import { AdminModule } from &#39;./admin/admin.module&#39;;

@NgModule({
  imports: [
    BrowserModule,
    // AdminModule,  ← ELIMINAR aquesta línia
    AppRoutingModule
  ]
})
export class AppModule { }</code></pre>
  </div>
</div>


<p>Si deixeu la importació eager, el mòdul es carregarà immediatament i el lazy loading no funcionarà.</p>

<h4>2.9.5. Rutes niades amb lazy loading</h4>
<p>Els mòduls lazy poden tenir rutes niades definides al seu propi routing module:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// admin-routing.module.ts (dins del mòdul lazy)
const routes: Routes = [
  { path: &#39;&#39;, component: AdminDashboardComponent },
  { path: &#39;users&#39;, component: UsersComponent },
  { path: &#39;settings&#39;, component: SettingsComponent }
];</code></pre>
  </div>
</div>


<p>Quan accediu a <code>/admin/users</code>, el router:</p>
<ol>
<li>Carrega <code>AdminModule</code> (si no està carregat)</li>
<li>Navega a la ruta <code>users</code> dins del mòdul</li>
</ol>

<h4>2.9.6. Verificar que funciona</h4>
<p>Obriu les DevTools del navegador (F12) → Network → filtreu per "chunk". Navegueu per l'aplicació i observeu com es descarreguen fitxers <code>.chunk.js</code> quan accediu a rutes lazy per primera vegada.</p>


<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">/             → main.js (450 KB) descarregat
/products     → products.chunk.js (280 KB) descarregat
/admin        → admin.chunk.js (800 KB) descarregat
/admin/users  → No es descarrega res (admin ja està carregat)</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El lazy loading es configura amb loadChildren i imports dinàmics, eliminant la importació eager del mòdul de l'AppModule.
</div>


<h4>2.9.7. Resultat esperat</h4>
<p>Configuració de rutes amb lazy loading utilitzant <code>loadChildren</code> i verificació que els mòduls es carreguen sota demanda.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.10. Beneficis: reducció del temps de càrrega inicial</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.10.1. Objectiu</h4>
<p>Mesurar i quantificar els beneficis reals del lazy loading en temps de càrrega i experiència d'usuari.</p>

<h4>2.10.2. Mètrica 1: Time to Interactive (TTI)</h4>
<p>El Time to Interactive és el temps que triga l'aplicació des que l'usuari obre la pàgina fins que pot interactuar amb ella. Google considera que un TTI inferior a 3.8 segons és bo.</p>

<p><strong>Sense lazy loading:</strong></p>
<ul>
<li>Descarregar 3.2 MB: 12.8s (3G)</li>
<li>Parsejar i executar JavaScript: 2.5s</li>
<li>TTI total: <strong>15.3 segons</strong></li>
</ul>

<p><strong>Amb lazy loading:</strong></p>
<ul>
<li>Descarregar 450 KB: 2s (3G)</li>
<li>Parsejar i executar JavaScript: 0.8s</li>
<li>TTI total: <strong>2.8 segons</strong></li>
</ul>

<p>Millora: <strong>82% més ràpid</strong>.</p>

<h4>2.10.3. Mètrica 2: First Contentful Paint (FCP)</h4>
<p>El First Contentful Paint és el temps que triga a aparèixer el primer contingut visible a la pantalla.</p>
<p><strong>Sense lazy loading:</strong> FCP = 8.5 segons (l'usuari veu pantalla blanca 8 segons)</p>
<p><strong>Amb lazy loading:</strong> FCP = 1.2 segons</p>
<p>Millora: <strong>86% més ràpid</strong>.</p>

<h4>2.10.4. Mètrica 3: Retenció d'usuaris</h4>
<p>Segons estadístiques de Google i Amazon:</p>
<ul>
<li>53% dels usuaris abandonen si la pàgina triga més de 3 segons</li>
<li>Cada 100ms de millora en velocitat augmenta conversions un 1%</li>
</ul>

<p><strong>Aplicació sense lazy loading (TTI 15s):</strong></p>
<ul>
<li>Taxa d'abandonament: 75%</li>
<li>Usuaris que interactuen: 25%</li>
</ul>

<p><strong>Aplicació amb lazy loading (TTI 2.8s):</strong></p>
<ul>
<li>Taxa d'abandonament: 12%</li>
<li>Usuaris que interactuen: 88%</li>
</ul>

<p>Millora: <strong>252% més usuaris</strong> que utilitzen l'aplicació.</p>

<h4>2.10.5. Mètrica 4: Consum de dades mòbils</h4>
<p>En connexions mòbils amb plans de dades limitats, cada MB compte.</p>
<p><strong>Usuari típic que només visita 3 pàgines:</strong></p>
<ul>
<li>Sense lazy loading: Descarrega 3.2 MB (tot el codi)</li>
<li>Amb lazy loading: Descarrega 450 KB (inicial) + 280 KB (products) = 730 KB</li>
</ul>
<p>Estalvi: <strong>2.47 MB (77% menys dades)</strong> per usuari típic.</p>

<h4>2.10.6. Taula de beneficis quantificats</h4>
<table>
<thead>
<tr>
<th>Mètrica</th>
<th>Sense lazy</th>
<th>Amb lazy</th>
<th>Millora</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TTI (3G)</strong></td>
<td>15.3s</td>
<td>2.8s</td>
<td>82% més ràpid</td>
</tr>
<tr>
<td><strong>FCP</strong></td>
<td>8.5s</td>
<td>1.2s</td>
<td>86% més ràpid</td>
</tr>
<tr>
<td><strong>Mida inicial</strong></td>
<td>3.2 MB</td>
<td>450 KB</td>
<td>86% més petit</td>
</tr>
<tr>
<td><strong>Taxa retenció</strong></td>
<td>25%</td>
<td>88%</td>
<td>252% més usuaris</td>
</tr>
<tr>
<td><strong>Consum dades</strong></td>
<td>3.2 MB</td>
<td>730 KB</td>
<td>77% menys</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El lazy loading redueix el TTI en un 82%, millora el FCP en un 86%, i augmenta la retenció d'usuaris en un 252%, amb impacte directe en l'experiència i l'èxit de l'aplicació.
</div>


<h4>2.10.7. Resultat esperat</h4>
<p>Quantificació dels beneficis reals del lazy loading en temps de càrrega, retenció d'usuaris i consum de dades.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.11. Estratègia: què carregar immediatament i què diferir</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.11.1. Objectiu</h4>
<p>Aprendre a prendre decisions estratègiques sobre quins mòduls carregar immediatament i quins diferir amb lazy loading.</p>

<h4>2.11.2. Criteris de decisió</h4>
<p><strong>Carregueu immediatament (eager):</strong></p>
<ul>
<li>Components visibles a la pàgina inicial (header, footer, home)</li>
<li>Funcionalitat crítica que tots els usuaris necessiten</li>
<li>Mòduls molt petits (&lt; 50 KB) on el lazy overhead no compensa</li>
<li>Serveis globals que molts components necessiten</li>
</ul>

<p><strong>Carregueu diferit (lazy):</strong></p>
<ul>
<li>Panells d'administració (només per administradors)</li>
<li>Funcionalitats avançades poc utilitzades</li>
<li>Seccions grans amb molts components (&gt; 200 KB)</li>
<li>Contingut darrere d'autenticació</li>
</ul>

<h4>2.11.3. Exemple d'estratègia per aplicació e-commerce</h4>
<table>
<thead>
<tr>
<th>Funcionalitat</th>
<th>Mètode</th>
<th>Raó</th>
</tr>
</thead>
<tbody>
<tr>
<td>Home / Catàleg</td>
<td>Eager</td>
<td>Tots els usuaris ho veuen primer</td>
</tr>
<tr>
<td>Header / Footer</td>
<td>Eager</td>
<td>Sempre visibles</td>
</tr>
<tr>
<td>Detall de producte</td>
<td>Eager</td>
<td>Molt utilitzat (80% usuaris)</td>
</tr>
<tr>
<td>Cistella</td>
<td>Eager</td>
<td>Funcionalitat crítica</td>
</tr>
<tr>
<td>Checkout</td>
<td>Lazy</td>
<td>Només 15% arriben aquí</td>
</tr>
<tr>
<td>Administració</td>
<td>Lazy</td>
<td>Només admins (5% usuaris)</td>
</tr>
<tr>
<td>Preferits</td>
<td>Lazy</td>
<td>Funcionalitat secundària</td>
</tr>
<tr>
<td>Cerca avançada</td>
<td>Lazy</td>
<td>Poc utilitzada (10% usuaris)</td>
</tr>
</tbody>
</table>

<h4>2.11.4. Preloading strategies avançades</h4>
<p>Angular ofereix estratègies de preload que carreguen mòduls lazy en background després de la càrrega inicial:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// app-routing.module.ts
@NgModule({
  imports: [RouterModule.forRoot(routes, {
    preloadingStrategy: PreloadAllModules  // Precarrega tots els mòduls lazy
  })],
  exports: [RouterModule]
})</code></pre>
  </div>
</div>


<p>Estratègies disponibles:</p>
<ul>
<li><strong>NoPreloading</strong> (per defecte): Només carrega quan l'usuari accedeix</li>
<li><strong>PreloadAllModules</strong>: Carrega tots els mòduls lazy en background després de l'inici</li>
<li><strong>Custom</strong>: Podeu crear estratègies personalitzades per precarregar només certs mòduls</li>
</ul>

<h4>2.11.5. Quan usar preloading</h4>
<p><strong>Useu PreloadAllModules quan:</strong></p>
<ul>
<li>L'aplicació no és massa gran (&lt; 5 mòduls lazy)</li>
<li>Voleu eliminar el petit retard quan l'usuari accedeix a un mòdul lazy</li>
<li>Els usuaris tenen connexions ràpides</li>
</ul>

<p><strong>NO useu preloading quan:</strong></p>
<ul>
<li>L'aplicació és molt gran (&gt; 10 mòduls lazy)</li>
<li>Molts usuaris tenen connexions lentes</li>
<li>Hi ha mòduls que molt pocs usuaris utilitzen</li>
</ul>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Carregueu eager la funcionalitat crítica i visible inicialment; diferiu amb lazy les seccions avançades, administració i contingut poc utilitzat.
</div>


<h4>2.11.6. Resultat esperat</h4>
<p>Aplicació de criteris estratègics per decidir què carregar immediatament i què diferir segons l'ús real de cada funcionalitat.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.12. Mini exemple pràctic · Mòdul d'administració amb lazy loading</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Mini exemple pràctic: Mòdul d'administració amb lazy loading</h3>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Crear mòdul admin amb routing: ng g m admin --routing</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Crear dos components dins del mòdul: ng g c admin/dashboard i ng g c admin/users</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Configurar rutes internes del mòdul a admin-routing.module.ts amb forChild()</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Afegir ruta lazy a app-routing.module.ts amb loadChildren i import dinàmic</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Eliminar qualsevol import eager de AdminModule de l'AppModule</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Servir l'aplicació i obrir DevTools → Network</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Navegar a /admin i observar com es descarrega admin.chunk.js</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Verificar que la navegació entre /admin i /admin/users no descarrega res més</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>


<p><strong>Resultat esperat:</strong> Un mòdul d'administració que es carrega només quan l'usuari accedeix a <code>/admin</code>, reduint la mida inicial de l'aplicació.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.13. Resolució de problemes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Possible causa</th>
<th>Solució ràpida</th>
</tr>
</thead>
<tbody>
<tr>
<td>El mòdul lazy no es carrega i dóna error 404</td>
<td>El path del loadChildren és incorrecte o el mòdul no existeix</td>
<td>Verificar que el path './admin/admin.module' és correcte i que el fitxer existeix</td>
</tr>
<tr>
<td>Error "Cannot find module" quan navego a ruta lazy</td>
<td>Sintaxi incorrecta de loadChildren o falta .then(m =&gt; m.ModuleName)</td>
<td>Assegurar sintaxi: loadChildren: () =&gt; import('./path').then(m =&gt; m.ModuleName)</td>
</tr>
<tr>
<td>El mòdul es carrega immediatament, no lazy</td>
<td>El mòdul encara està importat a l'AppModule</td>
<td>Eliminar la importació del mòdul de imports: [] a AppModule</td>
</tr>
<tr>
<td>Error "forRoot() already called"</td>
<td>S'està usant forRoot() en un mòdul lazy en lloc de forChild()</td>
<td>Canviar RouterModule.forRoot(routes) per RouterModule.forChild(routes) al mòdul lazy</td>
</tr>
<tr>
<td>Les rutes del mòdul lazy no funcionen</td>
<td>El routing module del mòdul no està importat al mòdul</td>
<td>Afegir ModuleRoutingModule a imports: [] del mòdul</td>
</tr>
<tr>
<td>No es veuen fitxers .chunk.js a DevTools</td>
<td>El lazy loading no està configurat o la build és de desenvolupament sense optimització</td>
<td>Verificar configuració de loadChildren i compilar amb ng build --configuration production</td>
</tr>
<tr>
<td>Error "Unexpected value 'Module' imported by module"</td>
<td>Està important el mòdul amb import estàtic en lloc de dinàmic</td>
<td>Eliminar import { Module } from './path' i deixar només l'import dins de loadChildren</td>
</tr>
<tr>
<td>El temps de càrrega inicial no millora</td>
<td>Hi ha massa mòduls eager o els chunks lazy són massa petits</td>
<td>Revisar estratègia: convertir més mòduls a lazy, especialment els grans (&gt; 200 KB)</td>
</tr>
</tbody>
</table>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.14. Prompts d'IA</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>2.14.1. Prompt 1</h4>
<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Arquitecte d'aplicacions Angular especialitzat en optimització de rendiment.<br><br><strong>Context:</strong> Tinc una aplicació Angular amb 8 funcionalitats principals: catàleg de productes, cistella, checkout, perfil d'usuari, preferits, administració, cerca avançada i configuració. Actualment tot es carrega immediatament i el temps de càrrega inicial és de 14 segons.<br><br><strong>Tasca:</strong> Proposa una estratègia completa de modularització i lazy loading indicant quins mòduls crear, quins carregar eager i quins lazy, i estima la millora esperada en temps de càrrega.<br><br><strong>Format:</strong> Taula amb columnes: Funcionalitat, Mòdul, Mètode (Eager/Lazy), Mida estimada, Raó, i un resum final amb temps de càrrega abans/després.</div>
  </div>
</div>


<h4>2.14.2. Prompt 2</h4>
<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Instructor d'Angular especialitzat en lazy loading.<br><br><strong>Context:</strong> He creat un mòdul AdminModule amb components de dashboard i gestió d'usuaris. Vull implementar lazy loading però no estic segur de la sintaxi exacta ni dels passos necessaris per evitar errors.<br><br><strong>Tasca:</strong> Proporciona una guia pas a pas completa per convertir el meu AdminModule de càrrega eager a lazy loading, incloent codi complet dels fitxers afectats (app-routing.module.ts, admin-routing.module.ts, app.module.ts) i com verificar que funciona correctament.<br><br><strong>Format:</strong> Guia numerada amb snippets de codi complets per cada fitxer i instruccions de verificació amb DevTools.</div>
  </div>
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.15. Autoavaluació</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Autoavaluació</h3>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Creo mòduls funcionals amb CLI que agrupen components, serveis i rutes relacionats amb --routing</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Configuro rutes internes dels mòduls utilitzant RouterModule.forChild() correctament</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Implemento lazy loading amb loadChildren i imports dinàmics eliminant imports eager del mòdul</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Aplico criteris estratègics per decidir quins mòduls carregar eager (crítics, visibles) i quins lazy (administració, avançats)</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Verifico que els mòduls lazy es carreguen correctament observant fitxers .chunk.js a DevTools Network</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.16. Síntesi</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Síntesi</h3>
<ul>
<li>La modularització organitza l'aplicació en unitats funcionals independents que agrupen components, serveis i rutes relacionats, millorant l'organització, reutilització i mantenibilitat del codi amb reducció de temps de compilació.</li>
<li>El lazy loading carrega mòduls només quan l'usuari els necessita, reduint el temps de càrrega inicial en un 80-85% i la mida del fitxer principal de 3 MB a 450 KB, millorant dràsticament Time to Interactive i First Contentful Paint.</li>
<li>Els mòduls funcionals es creen amb <code>ng g m module-name --routing</code>, configuren rutes internes amb <code>RouterModule.forChild()</code>, i es carreguen lazy amb <code>loadChildren: () =&gt; import('./path').then(m =&gt; m.Module)</code> eliminant imports eager.</li>
<li>L'estratègia òptima és carregar eager la funcionalitat crítica visible inicialment (home, header, catàleg) i diferir amb lazy les seccions d'administració, funcionalitats avançades i contingut poc utilitzat per optimitzar recursos.</li>
<li>Els beneficis quantificables inclouen 82% millora en TTI, 86% reducció en mida inicial, 252% augment en retenció d'usuaris, i 77% estalvi de dades mòbils per usuaris típics.</li>
</ul>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">2.17. Repàs de conceptes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Conceptes clau</h3>
<ul>
<li><strong>Mòdul funcional:</strong> Agrupació de components, serveis i rutes relacionats amb una funcionalitat específica de l'aplicació.</li>
<li><strong>Lazy loading:</strong> Tècnica de càrrega diferida que carrega mòduls només quan l'usuari accedeix a les seves rutes.</li>
<li><strong>Eager loading:</strong> Càrrega immediata de mòduls durant l'inici de l'aplicació, inclosos a <code>imports</code> de l'<code>AppModule</code>.</li>
<li><strong>loadChildren:</strong> Propietat de configuració de rutes que especifica un mòdul per carregar de manera lazy amb import dinàmic.</li>
<li><strong>Import dinàmic:</strong> Sintaxi <code>import('./path')</code> que retorna una promise i permet carregar mòduls de manera asíncrona.</li>
<li><strong>Code splitting:</strong> Divisió automàtica del codi en múltiples fitxers (chunks) que es carreguen separadament.</li>
<li><strong>Chunk:</strong> Fitxer JavaScript generat pel compilador que conté el codi d'un mòdul lazy (ex: <code>admin.chunk.js</code>).</li>
<li><strong>RouterModule.forChild():</strong> Mètode per configurar rutes en mòduls funcionals sense duplicar configuració global del router.</li>
<li><strong>Time to Interactive (TTI):</strong> Temps des que l'usuari obre la pàgina fins que pot interactuar; objectiu &lt; 3.8 segons.</li>
<li><strong>First Contentful Paint (FCP):</strong> Temps fins que apareix el primer contingut visible a la pantalla de l'usuari.</li>
<li><strong>Preloading strategy:</strong> Estratègia per carregar mòduls lazy en background després de la càrrega inicial per eliminar retards.</li>
<li><strong>SharedModule:</strong> Mòdul que conté components, directives i pipes reutilitzables compartits entre múltiples mòduls funcionals.</li>
</ul>
  
  </div>
</div>


</div>

<div class="section" id="Unitat4_Bloc2_Seccio3">
  <h2 id="Unitat4_Bloc2_Seccio3">3. Separació de responsabilitats i capes</h2>

  <!-- MULTIMÈDIA -->
  <!--
  ════════════════════════════════════════════════════════════════
  Component: Enllaços multimèdia YouTube
  ════════════════════════════════════════════════════════════════

  Paràmetres:
    - unitat: número de la unitat (1-4)
    - bloc: número del bloc (1-4)
    - seccio: número de la secció (1-3)

  Exemple d'ús:
    {% include multimedia-youtube.html unitat=1 bloc=1 seccio=1 %}

  El component busca automàticament les URLs corresponents a
  site.data.multimedia i mostra els botons de vídeo i àudio.
  ════════════════════════════════════════════════════════════════
-->





  
  
  
  
  

  

  

  
<div class="multimedia-resources">
  <div class="multimedia-header">
    <i class="bi bi-play-circle-fill"></i>
    <span>Contingut multimèdia d'aquesta lectura</span>
  </div>

  <div class="multimedia-buttons">
    
    <a href="https://www.youtube.com/watch?v=e-1xF0Pttws" target="_blank" rel="noopener noreferrer" class="multimedia-btn video-btn" title="Lectura 4.2.3 · Separació de responsabilitats i capes">
      <i class="bi bi-youtube"></i>
      <span>Veure vídeo</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    

    
    <a href="https://www.youtube.com/watch?v=Rf8ol8HOprg" target="_blank" rel="noopener noreferrer" class="multimedia-btn audio-btn" title="[Audio] Lectura 4.2.3 · Separació de responsabilitats i capes">
      <i class="bi bi-mic-fill"></i>
      <span>Escoltar àudio</span>
      <i class="bi bi-box-arrow-up-right"></i>
    </a>
    
  </div>

  
  
</div>
  




  <!-- Component: Objectius del bloc/unitat -->



<div class="objectius-box">
  <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-bullseye" aria-hidden="true"></i> Objectius</div>
  <div class="component-content">
    <ul>
      
        <li>Aplicar el principi de responsabilitat única separant presentació, lògica de negoci i accés a dades</li>
      
        <li>Refactoritzar components barrejats en components presentacionals nets amb serveis de suport</li>
      
        <li>Implementar el patró contenidor/presentacional amb smart components i dumb components</li>
      
        <li>Organitzar el codi en capes clarament definides per facilitar proves, mantenibilitat i reutilització</li>
      
    </ul>
  </div>
  <!-- IMPORTANT: també es pot usar via front matter: page.objectius (array) -->
</div>



  <!-- Component: Caixa informativa -->
<div class="info-box" role="note">
    <div class="component-header info-header" role="heading" aria-level="4"><i class="bi bi-info-circle" aria-hidden="true"></i> Informació</div>
    <strong>RA4 · Criteri 4</strong> — Optimitza els recursos i genera un paquet llest per a publicació.
    
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.1. Prerequisits</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Unitat 3 completada:</strong> Heu treballat amb serveis, injecció de dependències i comunicació amb APIs.</li>
<li><strong>Components funcionals:</strong> Sabeu crear components i gestionar el seu cicle de vida amb <code>ngOnInit</code> i <code>ngOnDestroy</code>.</li>
<li><strong>Serveis bàsics:</strong> Comprensió de com crear serveis amb <code>@Injectable</code> i injectar-los als components.</li>
<li><strong>HttpClient:</strong> Experiència bàsica fent peticions HTTP a APIs externes.</li>
<li><strong>Conceptes de responsabilitat:</strong> Enteneu què significa que una classe o funció tingui una única responsabilitat.</li>
</ul>

<h4>Verificació ràpida</h4>

<div class="code-block" data-lang="bash" role="region" aria-label="Bloc de codi bash">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">BASH</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-bash"># Verificar que teniu el projecte amb components i serveis
ng serve --open
# Comprovar que podeu navegar i veure dades d&#39;una API</code></pre>
  </div>
</div>


<p><strong>Punt d'autocomprovació:</strong> L'aplicació mostra dades d'una API, teniu components que funcionen, i enteneu com es comuniquen components i serveis.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.2. Marc conceptual</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Què és la separació de responsabilitats en capes</h3>
<p>La separació de responsabilitats en capes és un principi d'arquitectura de programari on cada part del codi té una única responsabilitat clarament definida. En aplicacions Angular, això significa organitzar el codi en tres capes principals: presentació (components que mostren dades), lògica de negoci (serveis que processen dades i apliquen regles), i accés a dades (serveis que es comuniquen amb APIs). Cada capa depèn de les inferiors però mai a l'inrevés.</p>

<h3>Problema sense separació de responsabilitats</h3>
<h4>Situació abans</h4>
<p>Un component fa massa coses: mostra la interfície, valida dades, fa càlculs de negoci, es comunica amb l'API, transforma respostes, i gestiona errors. Tot aquest codi barrejat fa que el component tingui 300-500 línies i sigui impossible de provar i mantenir.</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Component barrejat amb totes les responsabilitats
@Component({
  selector: &#39;app-product-list&#39;,
  template: `
    &lt;div *ngFor=&quot;let product of products&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€ - Descompte: {{ calculateDiscount(product) }}%&lt;/p&gt;
      &lt;button (click)=&quot;addToCart(product)&quot;&gt;Afegir&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ProductListComponent implements OnInit {
  products: any[] = [];
  cart: any[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // RESPONSABILITAT 1: Comunicació amb API
    this.http.get(&#39;https://api.example.com/products&#39;).subscribe(
      (response: any) =&gt; {
        // RESPONSABILITAT 2: Transformació de dades
        this.products = response.data.map((item: any) =&gt; ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        }));
      },
      error =&gt; {
        // RESPONSABILITAT 3: Gestió d&#39;errors
        console.error(&#39;Error:&#39;, error);
        alert(&#39;No s\&#39;han pogut carregar els productes&#39;);
      }
    );
  }

  // RESPONSABILITAT 4: Lògica de negoci (càlcul de descomptes)
  calculateDiscount(product: any): number {
    if (product.stock &gt; 100) return 20;
    if (product.stock &gt; 50) return 10;
    if (product.stock &gt; 10) return 5;
    return 0;
  }

  // RESPONSABILITAT 5: Gestió d&#39;estat (cistella)
  addToCart(product: any) {
    const existing = this.cart.find(item =&gt; item.id === product.id);
    if (existing) {
      existing.quantity++;
    } else {
      this.cart.push({ ...product, quantity: 1 });
    }
    // RESPONSABILITAT 6: Persistència local
    localStorage.setItem(&#39;cart&#39;, JSON.stringify(this.cart));
  }
}</code></pre>
  </div>
</div>


<p>Aquest component té 6 responsabilitats diferents en un únic fitxer de 80 línies.</p>

<h4>Problemes que genera</h4>

<p><strong>1. Dificultat per fer proves unitàries</strong></p>
<p>Per provar que el càlcul de descompte funciona correctament, heu de crear un component complet amb totes les seves dependències: <code>HttpClient</code>, localStorage, i simular respostes d'API. Testejar una única funció requereix configurar tot un ecosistema. Si el càlcul de descompte estigués en un servei independent, podríeu provar només el servei sense components ni HTTP.</p>

<p><strong>2. Impossibilitat de reutilitzar lògica</strong></p>
<p>La funció <code>calculateDiscount()</code> està tancada dins del component. Si necessiteu calcular descomptes en un altre component (cistella, detall de producte, checkout), heu de copiar-enganxar el codi. Ara teniu 3 còpies de la mateixa lògica; si cal canviar els descomptes, heu de modificar 3 fitxers diferents amb risc d'inconsistències.</p>

<p><strong>3. Modificacions arrisquen trencar múltiples coses</strong></p>
<p>Quan voleu canviar com es mostren els productes a la interfície, heu de tocar el mateix fitxer que conté la lògica de descomptes i la comunicació amb l'API. Un canvi visual innocent pot trencar accidentalment la lògica de negoci perquè tot està barrejat. Cada modificació és una jugada de Jenga: tocar una peça pot fer caure tot l'edifici.</p>

<p><strong>4. Components de 300-500 línies impossibles de llegir</strong></p>
<p>Components amb múltiples responsabilitats creixen descontroladament. Revisar un component de 400 línies per trobar un error específic és com buscar una agulla en un paller. Els nous desenvolupadors triguen hores a entendre què fa cada part del component perquè tot està entrellaçat.</p>

<p><strong>5. Acoblament fort amb dependències externes</strong></p>
<p>El component depèn directament de <code>HttpClient</code> i localStorage. Si voleu canviar com es carreguen dades (per exemple, usar WebSockets o una llibreria diferent), heu de modificar tots els components que fan peticions HTTP. Amb 30 components que accedeixen directament a l'API, un canvi d'arquitectura requereix modificar 30 fitxers.</p>

<h3>Solució amb separació de responsabilitats en capes</h3>
<p>Dividiu el codi en capes amb responsabilitats clares: components només mostren i capturen interaccions, serveis de negoci apliquen regles i processament, serveis de dades comuniquen amb APIs. Cada capa es pot provar, modificar i reutilitzar independentment.</p>

<p><strong>Avantatges principals:</strong></p>
<ol>
<li><strong>Proves unitàries senzilles:</strong> Cada capa es prova aïlladament sense dependències complexes</li>
<li><strong>Reutilització de lògica:</strong> Serveis es poden usar des de qualsevol component</li>
<li><strong>Canvis localitzats:</strong> Modificar presentació no afecta lògica; canviar lògica no afecta presentació</li>
<li><strong>Components petits:</strong> Components de 50-80 línies fàcils de llegir i entendre</li>
<li><strong>Desacoblament:</strong> Canviar com s'obté dades no afecta components ni lògica de negoci</li>
</ol>

<h3>Exemple real complet: Sense vs Amb separació de capes</h3>
<p><strong>Situació:</strong> Una aplicació de llista de productes amb descomptes segons stock.</p>

<h4>Sense separació de responsabilitats (component barrejat)</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Un únic fitxer fa tot: 80 línies, 6 responsabilitats
export class ProductListComponent {
  products: any[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get(&#39;https://api.example.com/products&#39;).subscribe(
      (response: any) =&gt; {
        this.products = response.data.map((item: any) =&gt; ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100
        }));
      }
    );
  }

  calculateDiscount(product: any): number {
    if (product.stock &gt; 100) return 20;
    if (product.stock &gt; 50) return 10;
    return 0;
  }
}</code></pre>
  </div>
</div>


<p><strong>80 línies</strong> en un únic fitxer, impossible de provar aïlladament.</p>

<h4>Amb separació de responsabilitats (capes definides)</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// 1. CAPA DE DADES: Servei que comunica amb API
@Injectable({ providedIn: &#39;root&#39; })
export class ProductDataService {
  constructor(private http: HttpClient) {}

  getProducts(): Observable&lt;ProductDTO[]&gt; {
    return this.http.get&lt;{ data: ProductDTO[] }&gt;(&#39;https://api.example.com/products&#39;)
      .pipe(map(response =&gt; response.data));
  }
}

// 2. CAPA DE LÒGICA: Servei amb regles de negoci
@Injectable({ providedIn: &#39;root&#39; })
export class DiscountService {
  calculateDiscount(stock: number): number {
    if (stock &gt; 100) return 20;
    if (stock &gt; 50) return 10;
    return 0;
  }
}

// 3. CAPA DE PRESENTACIÓ: Component que només mostra
@Component({
  selector: &#39;app-product-list&#39;,
  template: `
    &lt;div *ngFor=&quot;let product of products$ | async&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€ - Descompte: {{ getDiscount(product) }}%&lt;/p&gt;
    &lt;/div&gt;
  `
})
export class ProductListComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product.stock);
  }
}</code></pre>
  </div>
</div>


<p><strong>3 fitxers separats</strong>, cada un amb una única responsabilitat, testejables independentment.</p>

<h3>Taula comparativa: Abans vs Després</h3>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Component barrejat</th>
<th>Capes separades</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Línies per fitxer</strong></td>
<td>80-300</td>
<td>20-50 per fitxer</td>
</tr>
<tr>
<td><strong>Responsabilitats per classe</strong></td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td><strong>Dificultat per testejar</strong></td>
<td>Alta (molts mocks)</td>
<td>Baixa (testejar servei sol)</td>
</tr>
<tr>
<td><strong>Reutilització de lògica</strong></td>
<td>Impossible (dins component)</td>
<td>Fàcil (injectar servei)</td>
</tr>
<tr>
<td><strong>Impacte d'un canvi visual</strong></td>
<td>Pot trencar lògica</td>
<td>Zero (capa independent)</td>
</tr>
<tr>
<td><strong>Temps per entendre codi</strong></td>
<td>20-30 minuts</td>
<td>5 minuts</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> La separació de responsabilitats redueix la complexitat de 80-300 línies per fitxer a 20-50 línies, passa de 6 responsabilitats a 1, i redueix el temps d'entendre el codi de 30 minuts a 5 minuts.
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.3. Model mental</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Restaurant amb brigada de cuina</strong></p>
<p>En un restaurant professional, cada membre de la brigada té una responsabilitat específica: el xef de partida prepara els plats (lògica), el cambrer porta els plats als clients (presentació), i el magatzemer s'encarrega de l'aprovisionament (dades). Ningú fa la feina d'altri. Si el xef hagués de servir taules i fer comandes als proveïdors, el restaurant seria un caos. Les capes de l'aplicació funcionen igual: cada una fa una cosa específica i es coordinen entre elles.</p>

<p><strong>Fàbrica amb cadena de muntatge</strong></p>
<p>Una fàbrica eficient organitza la producció en estacions especialitzades: una estació obté matèries primeres (capa de dades), una altra les processa i ensambla (capa de lògica), i una tercera empaqueta i presenta el producte final (capa de presentació). Cada estació és experta en la seva tasca. Si una sola persona hagués de fer tot, seria lenta i propensa a errors.</p>

<p><strong>Edifici amb plantes separades</strong></p>
<p>Un edifici d'oficines organitza les empreses en plantes: la planta baixa atén clients (presentació), el primer pis gestiona operacions (lògica), i el sòtan guarda l'arxiu (dades). Cada planta té una funció clara. Si tot estigués barrejat en una única sala, seria impossible treballar eficientment. Les capes arquitectòniques funcionen com plantes d'un edifici: separades però connectades.</p>

<p><strong>Orquestra amb seccions instrumentals</strong></p>
<p>En una orquestra simfònica, cada secció té un paper: cordes, vents, percussió. El director coordina totes les seccions, però cada músic es concentra en la seva part. Si cada músic hagués de tocar tots els instruments alhora, el resultat seria caòtic. De la mateixa manera, cada capa del codi se centra en la seva responsabilitat mentre el framework coordina la comunicació.</p>

<p><strong>Sistema de transport amb especialització</strong></p>
<p>El sistema de transport separa responsabilitats: trens de mercaderies mouen matèries (capa de dades), fàbriques processen materials (capa de lògica), botigues venen productes finals (capa de presentació). Cada actor està especialitzat. Si una botiga hagués de fabricar i transportar tot, seria ineficient. La separació de responsabilitats fa que cada part sigui eficient en la seva tasca.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.4. Principi de responsabilitat única: cada peça fa una cosa</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.4.1. Objectiu</h4>
<p>Comprendre el principi de responsabilitat única (Single Responsibility Principle - SRP) i per què és fonamental en arquitectura de programari.</p>

<h4>3.4.2. Definició del principi</h4>
<p>El principi de responsabilitat única estableix que cada classe, funció o mòdul ha de tenir una única raó per canviar. Això significa que cada peça de codi fa una sola cosa i la fa bé. Si una classe gestiona dades d'usuari, només fa això; no hauria de validar formularis, comunicar-se amb APIs, i mostrar interfície simultàniament.</p>

<p>Aquest principi prové dels principis SOLID de disseny orientat a objectes i és la base de l'arquitectura neta.</p>

<h4>3.4.3. Per què "una única raó per canviar"</h4>
<p>Penseu en les raons per les quals modificaríeu codi:</p>
<ul>
  <li>Canvia el disseny visual → Modifiqueu components de presentació</li>
  <li>Canvia una regla de negoci → Modifiqueu serveis de lògica</li>
  <li>Canvia l'API backend → Modifiqueu serveis d'accés a dades</li>
</ul>

<p>Si un component té codi de presentació, lògica i accés a dades, qualsevol dels tres canvis anteriors el forçarà a modificar-se. Això incrementa el risc d'errors: un canvi visual innocent pot trencar accidentalment la lògica de negoci.</p>

<h4>3.4.4. Exemple pràctic: Component que viola SRP</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">export class UserProfileComponent {
  user: User;

  ngOnInit() {
    // Responsabilitat 1: Accés a dades
    this.http.get(&#39;/api/user/123&#39;).subscribe(data =&gt; {
      // Responsabilitat 2: Transformació de dades
      this.user = this.transformDTO(data);
      // Responsabilitat 3: Validació
      if (!this.isValid(this.user)) {
        // Responsabilitat 4: Gestió d&#39;errors UI
        this.showError(&#39;Dades invàlides&#39;);
      }
    });
  }

  // Responsabilitat 5: Lògica de negoci
  calculateAge(birthDate: Date): number {
    return new Date().getFullYear() - birthDate.getFullYear();
  }

  // Responsabilitat 6: Presentació
  // Template amb lògica complexa barrejada
}</code></pre>
  </div>
</div>


<p>Aquest component té 6 responsabilitats diferents. Qualsevol canvi (API, validació, càlcul d'edat, disseny) requereix tocar aquest component.</p>

<h4>3.4.5. Aplicant SRP: Una classe, una responsabilitat</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// UserDataService: NOMÉS accés a dades
@Injectable({ providedIn: &#39;root&#39; })
export class UserDataService {
  getUser(id: number): Observable&lt;User&gt; {
    return this.http.get&lt;UserDTO&gt;(`/api/user/${id}`)
      .pipe(map(dto =&gt; this.transformDTO(dto)));
  }
}

// UserValidationService: NOMÉS validació
@Injectable({ providedIn: &#39;root&#39; })
export class UserValidationService {
  isValid(user: User): boolean {
    return user.name &amp;&amp; user.email &amp;&amp; user.birthDate;
  }
}

// UserProfileComponent: NOMÉS presentació
export class UserProfileComponent {
  user$ = this.userData.getUser(123);

  constructor(private userData: UserDataService) {}
}</code></pre>
  </div>
</div>


<p>Ara cada classe té una única responsabilitat i una única raó per canviar.</p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El principi de responsabilitat única exigeix que cada classe tingui una única raó per canviar, separant presentació, lògica i accés a dades.
</div>


<h4>3.4.6. Resultat esperat</h4>
<p>L'alumnat comprèn el principi de responsabilitat única i identifica quan una classe té múltiples responsabilitats que haurien de separar-se.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.5. Capes d'una aplicació: presentació, lògica de negoci, dades</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.5.1. Objectiu</h4>
<p>Identificar les tres capes principals d'una aplicació i comprendre les responsabilitats de cadascuna.</p>

<h4>3.5.2. Les tres capes fonamentals</h4>
<p><strong>1. Capa de presentació (Components)</strong></p>
<ul>
  <li>Responsabilitat: Mostrar informació a l'usuari i capturar interaccions</li>
  <li>Què fa: Renderitza HTML, gestiona esdeveniments (clicks, canvis), mostra estat visual</li>
  <li>Què NO fa: Validacions complexes, càlculs de negoci, comunicació amb APIs</li>
</ul>

<p><strong>2. Capa de lògica de negoci (Serveis)</strong></p>
<ul>
  <li>Responsabilitat: Aplicar regles de negoci, validacions, càlculs i processament</li>
  <li>Què fa: Valida dades, calcula descomptes, aplica regles, transforma informació</li>
  <li>Què NO fa: Renderitzar HTML, fer peticions HTTP directes</li>
</ul>

<p><strong>3. Capa d'accés a dades (Serveis de dades)</strong></p>
<ul>
  <li>Responsabilitat: Comunicar-se amb APIs externes, bases de dades, localStorage</li>
  <li>Què fa: Peticions HTTP, transformació DTO ↔ Model, gestió d'errors d'API</li>
  <li>Què NO fa: Aplicar regles de negoci, mostrar interfície</li>
</ul>

<h4>3.5.3. Flux de dades entre capes</h4>

<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">Usuario interactúa
    ↓
CAPA PRESENTACIÓ (Component)
    → Crida servei de lògica
    ↓
CAPA LÒGICA (Business Service)
    → Valida, processa
    → Crida servei de dades
    ↓
CAPA DADES (Data Service)
    → Obté dades d&#39;API
    ↓
Dades retornen cap amunt
    ↓
Component mostra dades</code></pre>
  </div>
</div>


<p>Les dades sempre flueixen en una direcció clara: usuari → presentació → lògica → dades → lògica → presentació → usuari.</p>

<h4>3.5.4. Exemple d'organització en carpetes</h4>

<div class="code-block" data-lang="text" role="region" aria-label="Bloc de codi text">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TEXT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-text">src/app/
├── components/              # CAPA PRESENTACIÓ
│   ├── product-list/
│   ├── product-card/
│   └── product-detail/
├── services/
│   ├── business/            # CAPA LÒGICA
│   │   ├── discount.service.ts
│   │   ├── validation.service.ts
│   │   └── calculation.service.ts
│   └── data/                # CAPA DADES
│       ├── product-data.service.ts
│       ├── user-data.service.ts
│       └── order-data.service.ts
└── models/
    ├── product.model.ts
    └── user.model.ts</code></pre>
  </div>
</div>


<p>Aquesta estructura fa evident quina és la responsabilitat de cada fitxer.</p>

<h4>3.5.5. Avantatges de l'arquitectura en capes</h4>
<table>
<thead>
<tr>
<th>Avantatge</th>
<th>Benefici pràctic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Canvis localitzats</strong></td>
<td>Modificar API només afecta capa de dades</td>
</tr>
<tr>
<td><strong>Reutilització</strong></td>
<td>Múltiples components usen mateix servei de lògica</td>
</tr>
<tr>
<td><strong>Proves senzilles</strong></td>
<td>Testejar cada capa independentment</td>
</tr>
<tr>
<td><strong>Escalabilitat</strong></td>
<td>Afegir funcionalitats sense tocar codi existent</td>
</tr>
<tr>
<td><strong>Treball en equip</strong></td>
<td>Diferents desenvolupadors treballen en capes diferents</td>
</tr>
</tbody>
</table>

<h4>3.5.6. Errors comuns a evitar</h4>
<p><strong>Error 1: Component accedeix directament a HttpClient</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// MAL: Component fa peticions HTTP
export class ProductListComponent {
  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get(&#39;/api/products&#39;).subscribe(...)
  }
}

// BÉ: Component usa servei de dades
export class ProductListComponent {
  constructor(private productData: ProductDataService) {}

  ngOnInit() {
    this.productData.getProducts().subscribe(...)
  }
}</code></pre>
  </div>
</div>


<p><strong>Error 2: Servei d'accés a dades conté lògica de negoci</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// MAL: Servei de dades calcula descomptes
export class ProductDataService {
  getProducts(): Observable&lt;Product[]&gt; {
    return this.http.get(&#39;/api/products&#39;).pipe(
      map(products =&gt; products.map(p =&gt; {
        p.discount = this.calculateDiscount(p); // Lògica de negoci aquí
        return p;
      }))
    );
  }
}

// BÉ: Separar en dos serveis
export class ProductDataService {
  getProducts(): Observable&lt;Product[]&gt; {
    return this.http.get(&#39;/api/products&#39;);
  }
}

export class DiscountService {
  calculateDiscount(product: Product): number {
    // Lògica de negoci en servei dedicat
  }
}</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Les aplicacions s'organitzen en tres capes amb responsabilitats clares: presentació (components), lògica (serveis de negoci), i dades (serveis d'accés a APIs).
</div>


<h4>3.5.7. Resultat esperat</h4>
<p>L'alumnat identifica les tres capes principals d'una aplicació i comprèn les responsabilitats específiques de cadascuna.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.6. Components (presentació): només mostrar i capturar interaccions</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.6.1. Objectiu</h4>
<p>Aprendre a crear components presentacionals purs que només es dediquen a mostrar dades i capturar interaccions de l'usuari.</p>

<h4>3.6.2. Responsabilitats d'un component presentacional</h4>
<p>Un component presentacional pur:</p>
<ul>
  <li>Rep dades via <code>@Input()</code> o observables</li>
  <li>Mostra les dades amb interpolació i directives</li>
  <li>Captura esdeveniments d'usuari (click, change, submit)</li>
  <li>Emet esdeveniments via <code>@Output()</code> per notificar accions</li>
  <li><strong>NO</strong> conté lògica de negoci, càlculs, validacions complexes ni peticions HTTP</li>
</ul>

<h4>3.6.3. Exemple: Component presentacional pur</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Component({
  selector: &#39;app-product-card&#39;,
  template: `
    &lt;div class=&quot;card&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€&lt;/p&gt;
      &lt;p class=&quot;discount&quot; *ngIf=&quot;discount &gt; 0&quot;&gt;Descompte: {{ discount }}%&lt;/p&gt;
      &lt;button (click)=&quot;onAddToCart()&quot;&gt;Afegir a cistella&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter&lt;Product&gt;();

  onAddToCart(): void {
    this.addToCart.emit(this.product);
  }
}</code></pre>
  </div>
</div>


<p>Aquest component:</p>
<ul>
  <li>Rep dades (<code>product</code>, <code>discount</code>) via <code>@Input()</code></li>
  <li>Les mostra al template</li>
  <li>Captura el clic del botó</li>
  <li>Emet un esdeveniment perquè el component pare gestioni l'acció</li>
  <li><strong>NO</strong> calcula el descompte ni fa peticions HTTP</li>
</ul>

<h4>3.6.4. Beneficis dels components presentacionals</h4>
<p><strong>1. Fàcils de testejar</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Test: passar dades simulades i verificar renderitzat
it(&#39;should display product name&#39;, () =&gt; {
  component.product = { name: &#39;Test Product&#39;, price: 10, stock: 5 };
  fixture.detectChanges();
  expect(fixture.nativeElement.textContent).toContain(&#39;Test Product&#39;);
});</code></pre>
  </div>
</div>


<p>No cal simular serveis ni HttpClient; només passeu dades i verifiqueu el resultat visual.</p>

<p><strong>2. Reutilitzables en múltiples contextos</strong></p>
<p>El mateix <code>ProductCardComponent</code> es pot usar a:</p>
<ul>
  <li>Llista de productes</li>
  <li>Cerca de productes</li>
  <li>Productes relacionats</li>
  <li>Preferits</li>
</ul>

<p>Cada context passa les dades necessàries via <code>@Input()</code> i gestiona els esdeveniments via <code>@Output()</code>.</p>

<p><strong>3. Independents de la font de dades</strong></p>
<p>El component no sap d'on vénen les dades (API, localStorage, estat centralitzat, dades simulades). Només rep un objecte <code>Product</code> i el mostra. Això fa el component totalment desacoblat de la infraestructura.</p>

<h4>3.6.5. Patró contenidor vs presentacional</h4>
<p><strong>Component contenidor (smart):</strong></p>
<ul>
  <li>Gestiona estat i lògica</li>
  <li>Obté dades de serveis</li>
  <li>Passa dades als components presentacionals</li>
  <li>Gestiona esdeveniments dels components fills</li>
</ul>

<p><strong>Component presentacional (dumb):</strong></p>
<ul>
  <li>Rep dades via <code>@Input()</code></li>
  <li>Mostra dades</li>
  <li>Emet esdeveniments via <code>@Output()</code></li>
  <li>Sense lògica de negoci</li>
</ul>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// COMPONENT CONTENIDOR (smart)
@Component({
  selector: &#39;app-product-list-container&#39;,
  template: `
    &lt;app-product-card
      *ngFor=&quot;let product of products$ | async&quot;
      [product]=&quot;product&quot;
      [discount]=&quot;getDiscount(product)&quot;
      (addToCart)=&quot;handleAddToCart($event)&quot;&gt;
    &lt;/app-product-card&gt;
  `
})
export class ProductListContainerComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private cart: CartService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculate(product.stock);
  }

  handleAddToCart(product: Product): void {
    this.cart.add(product);
  }
}

// COMPONENT PRESENTACIONAL (dumb)
@Component({
  selector: &#39;app-product-card&#39;,
  template: `...` // Només mostra dades rebudes
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter&lt;Product&gt;();
}</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Els components presentacionals només mostren dades rebudes via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code>, sense lògica de negoci ni accés a dades.
</div>


<h4>3.6.6. Resultat esperat</h4>
<p>L'alumnat crea components presentacionals purs que separen clarament la responsabilitat de presentació de la lògica de negoci.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.7. Serveis (lògica): processament, regles de negoci</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.7.1. Objectiu</h4>
<p>Aprendre a crear serveis de lògica de negoci que encapsulen regles, validacions i processament de dades.</p>

<h4>3.7.2. Responsabilitats d'un servei de lògica</h4>
<p>Un servei de lògica de negoci:</p>
<ul>
  <li>Aplica regles de negoci (descomptes, comissions, càlculs)</li>
  <li>Valida dades abans d'enviar-les a l'API</li>
  <li>Transforma dades entre formats</li>
  <li>Implementa algoritmes i processament complex</li>
  <li><strong>NO</strong> fa peticions HTTP ni renderitza interfície</li>
</ul>

<h4>3.7.3. Exemple: Servei de càlcul de descomptes</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Injectable({ providedIn: &#39;root&#39; })
export class DiscountService {

  calculateDiscount(product: Product): number {
    // Regla 1: Descompte per stock alt
    if (product.stock &gt; 100) return 20;
    if (product.stock &gt; 50) return 10;
    if (product.stock &gt; 10) return 5;

    // Regla 2: Descompte per categoria
    if (product.category === &#39;clearance&#39;) return 30;

    // Regla 3: Sense descompte
    return 0;
  }

  applyDiscount(price: number, discountPercent: number): number {
    return price * (1 - discountPercent / 100);
  }

  calculateFinalPrice(product: Product): number {
    const discount = this.calculateDiscount(product);
    return this.applyDiscount(product.price, discount);
  }
}</code></pre>
  </div>
</div>


<p>Aquest servei encapsula tota la lògica de descomptes. Si les regles canvien (per exemple, afegir descompte per client VIP), només cal modificar aquest servei, no 20 components diferents.</p>

<h4>3.7.4. Exemple: Servei de validació</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Injectable({ providedIn: &#39;root&#39; })
export class ProductValidationService {

  validateProduct(product: Product): ValidationResult {
    const errors: string[] = [];

    if (!product.name || product.name.trim().length &lt; 3) {
      errors.push(&#39;El nom ha de tenir almenys 3 caràcters&#39;);
    }

    if (product.price &lt;= 0) {
      errors.push(&#39;El preu ha de ser superior a 0&#39;);
    }

    if (product.stock &lt; 0) {
      errors.push(&#39;L\&#39;stock no pot ser negatiu&#39;);
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  canBeSold(product: Product): boolean {
    return product.stock &gt; 0 &amp;&amp; product.price &gt; 0;
  }
}</code></pre>
  </div>
</div>


<h4>3.7.5. Reutilització de serveis de lògica</h4>
<p>El mateix servei es pot usar des de múltiples components:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// En component de llista
export class ProductListComponent {
  constructor(private discount: DiscountService) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }
}

// En component de detall
export class ProductDetailComponent {
  constructor(private discount: DiscountService) {}

  finalPrice$ = this.product$.pipe(
    map(product =&gt; this.discount.calculateFinalPrice(product))
  );
}

// En component de cistella
export class CartComponent {
  constructor(private discount: DiscountService) {}

  getTotalWithDiscounts(): number {
    return this.items.reduce((sum, item) =&gt; {
      const finalPrice = this.discount.calculateFinalPrice(item.product);
      return sum + (finalPrice * item.quantity);
    }, 0);
  }
}</code></pre>
  </div>
</div>


<p>Tres components diferents usen el mateix servei, garantint consistència. Si canvia la lògica de descomptes, només cal modificar el servei.</p>

<h4>3.7.6. Proves unitàries de serveis de lògica</h4>
<p>Els serveis de lògica són extremadament fàcils de testejar perquè no tenen dependències externes:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">describe(&#39;DiscountService&#39;, () =&gt; {
  let service: DiscountService;

  beforeEach(() =&gt; {
    service = new DiscountService();
  });

  it(&#39;should calculate 20% discount for stock &gt; 100&#39;, () =&gt; {
    const product = { name: &#39;Test&#39;, price: 100, stock: 150, category: &#39;normal&#39; };
    expect(service.calculateDiscount(product)).toBe(20);
  });

  it(&#39;should calculate 30% discount for clearance category&#39;, () =&gt; {
    const product = { name: &#39;Test&#39;, price: 100, stock: 5, category: &#39;clearance&#39; };
    expect(service.calculateDiscount(product)).toBe(30);
  });

  it(&#39;should apply discount correctly&#39;, () =&gt; {
    expect(service.applyDiscount(100, 20)).toBe(80);
    expect(service.applyDiscount(50, 10)).toBe(45);
  });
});</code></pre>
  </div>
</div>


<p>Proves netes, ràpides, sense mocks complexos.</p>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Els serveis de lògica de negoci encapsulen regles, validacions i càlculs, permetent reutilització, consistència i proves unitàries senzilles.
</div>


<h4>3.7.7. Resultat esperat</h4>
<p>L'alumnat crea serveis de lògica de negoci amb regles, validacions i processament separats dels components i l'accés a dades.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.8. Capa de dades: comunicació amb serveis web (APIs), adaptació</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.8.1. Objectiu</h4>
<p>Aprendre a crear serveis d'accés a dades que encapsulen tota la comunicació amb APIs externes.</p>

<h4>3.8.2. Responsabilitats d'un servei d'accés a dades</h4>
<p>Un servei d'accés a dades (data service o repository):</p>
<ul>
  <li>Fa peticions HTTP a APIs (GET, POST, PUT, DELETE)</li>
  <li>Transforma DTOs (Data Transfer Objects) de l'API a models interns</li>
  <li>Gestiona errors HTTP i retry logic</li>
  <li>Encapsula la URL base i endpoints de l'API</li>
  <li><strong>NO</strong> conté lògica de negoci ni renderitza interfície</li>
</ul>

<h4>3.8.3. Exemple: Servei d'accés a dades complet</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Interfície DTO (el que retorna l&#39;API)
interface ProductDTO {
  product_id: number;
  product_name: string;
  price_cents: number;
  available_quantity: number;
}

// Model intern (el que usa l&#39;aplicació)
export interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

// Servei d&#39;accés a dades
@Injectable({ providedIn: &#39;root&#39; })
export class ProductDataService {
  private apiUrl = &#39;https://api.example.com&#39;;

  constructor(private http: HttpClient) {}

  getProducts(): Observable&lt;Product[]&gt; {
    return this.http.get&lt;{ data: ProductDTO[] }&gt;(`${this.apiUrl}/products`)
      .pipe(
        map(response =&gt; response.data.map(dto =&gt; this.mapDTOToModel(dto))),
        catchError(this.handleError)
      );
  }

  getProduct(id: number): Observable&lt;Product&gt; {
    return this.http.get&lt;ProductDTO&gt;(`${this.apiUrl}/products/${id}`)
      .pipe(
        map(dto =&gt; this.mapDTOToModel(dto)),
        catchError(this.handleError)
      );
  }

  createProduct(product: Product): Observable&lt;Product&gt; {
    const dto = this.mapModelToDTO(product);
    return this.http.post&lt;ProductDTO&gt;(`${this.apiUrl}/products`, dto)
      .pipe(
        map(dto =&gt; this.mapDTOToModel(dto)),
        catchError(this.handleError)
      );
  }

  private mapDTOToModel(dto: ProductDTO): Product {
    return {
      id: dto.product_id,
      name: dto.product_name,
      price: dto.price_cents / 100,
      stock: dto.available_quantity
    };
  }

  private mapModelToDTO(product: Product): ProductDTO {
    return {
      product_id: product.id,
      product_name: product.name,
      price_cents: product.price * 100,
      available_quantity: product.stock
    };
  }

  private handleError(error: HttpErrorResponse): Observable&lt;never&gt; {
    console.error(&#39;Error en petició HTTP:&#39;, error);
    return throwError(() =&gt; new Error(&#39;Error en comunicació amb API&#39;));
  }
}</code></pre>
  </div>
</div>


<h4>3.8.4. Avantatges de la capa d'accés a dades</h4>
<p><strong>1. Desacoblament del backend</strong></p>
<p>Els components i serveis de lògica treballen amb models interns (<code>Product</code>), no amb DTOs de l'API. Si l'API canvia el format de resposta, només cal modificar el servei d'accés a dades, no tot el codi:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Abans: API retorna `product_name`
// Després: API retorna `name`

// Només cal canviar:
private mapDTOToModel(dto: ProductDTO): Product {
  return {
    id: dto.product_id,
    name: dto.name, // ← Únic canvi necessari
    price: dto.price_cents / 100,
    stock: dto.available_quantity
  };
}

// Tot el codi de components i lògica segueix funcionant sense canvis</code></pre>
  </div>
</div>


<p><strong>2. Facilitat per canviar el backend</strong></p>
<p>Si decidiu canviar de REST a GraphQL o WebSockets, només cal modificar els serveis d'accés a dades. Els components i lògica no saben com s'obtenen les dades:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Versió REST
getProducts(): Observable&lt;Product[]&gt; {
  return this.http.get&lt;ProductDTO[]&gt;(`${this.apiUrl}/products`)
    .pipe(map(dtos =&gt; dtos.map(dto =&gt; this.mapDTOToModel(dto))));
}

// Versió GraphQL (només canvia implementació del servei)
getProducts(): Observable&lt;Product[]&gt; {
  return this.apollo.query({ query: GET_PRODUCTS_QUERY })
    .pipe(map(result =&gt; result.data.products.map(dto =&gt; this.mapDTOToModel(dto))));
}</code></pre>
  </div>
</div>


<p><strong>3. Gestió centralitzada d'errors</strong></p>
<p>Tota la gestió d'errors HTTP està en un únic lloc. Podeu implementar retry logic, logging, o notificacions d'error de manera consistent:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">private handleError(error: HttpErrorResponse): Observable&lt;never&gt; {
  // Logging centralitzat
  this.logger.error(&#39;Error HTTP&#39;, error);

  // Notificació a l&#39;usuari
  this.notificationService.showError(&#39;Error en carregar dades&#39;);

  // Retry logic si cal
  return throwError(() =&gt; new Error(&#39;Error en API&#39;));
}</code></pre>
  </div>
</div>


<h4>3.8.5. Proves unitàries de serveis d'accés a dades</h4>
<p>Els serveis d'accés a dades es proven amb <code>HttpClientTestingModule</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">describe(&#39;ProductDataService&#39;, () =&gt; {
  let service: ProductDataService;
  let httpMock: HttpTestingController;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [ProductDataService]
    });
    service = TestBed.inject(ProductDataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it(&#39;should transform DTO to model correctly&#39;, () =&gt; {
    const mockDTO = {
      product_id: 1,
      product_name: &#39;Test&#39;,
      price_cents: 1000,
      available_quantity: 5
    };

    service.getProduct(1).subscribe(product =&gt; {
      expect(product.id).toBe(1);
      expect(product.name).toBe(&#39;Test&#39;);
      expect(product.price).toBe(10); // 1000 cents → 10 euros
      expect(product.stock).toBe(5);
    });

    const req = httpMock.expectOne(&#39;https://api.example.com/products/1&#39;);
    req.flush(mockDTO);
  });
});</code></pre>
  </div>
</div>


<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Els serveis d'accés a dades encapsulen tota la comunicació amb APIs, transformant DTOs a models interns i gestionant errors de manera centralitzada.
</div>


<h4>3.8.6. Resultat esperat</h4>
<p>L'alumnat crea serveis d'accés a dades que separen la comunicació HTTP de la lògica de negoci i components.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.9. Exemple pràctic: refactoritzar component barrejat en capes separades</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.9.1. Objectiu</h4>
<p>Aplicar tots els conceptes anteriors refactoritzant un component barrejat en una arquitectura en capes clara.</p>

<h4>3.9.2. Component original (barrejat)</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Component({
  selector: &#39;app-product-list&#39;,
  template: `
    &lt;div *ngFor=&quot;let product of products&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€ - Descompte: {{ calculateDiscount(product) }}%&lt;/p&gt;
      &lt;button (click)=&quot;addToCart(product)&quot; [disabled]=&quot;!canBeSold(product)&quot;&gt;
        Afegir
      &lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ProductListComponent implements OnInit {
  products: Product[] = [];
  cart: Product[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // Accés a dades + transformació
    this.http.get&lt;any&gt;(&#39;https://api.example.com/products&#39;).subscribe(
      response =&gt; {
        this.products = response.data.map((item: any) =&gt; ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        }));
      }
    );
  }

  // Lògica de negoci: càlcul descomptes
  calculateDiscount(product: Product): number {
    if (product.stock &gt; 100) return 20;
    if (product.stock &gt; 50) return 10;
    return 0;
  }

  // Lògica de negoci: validació
  canBeSold(product: Product): boolean {
    return product.stock &gt; 0;
  }

  // Gestió d&#39;estat
  addToCart(product: Product) {
    this.cart.push(product);
    localStorage.setItem(&#39;cart&#39;, JSON.stringify(this.cart));
  }
}</code></pre>
  </div>
</div>


<p>Aquest component fa massa coses: accés a dades, transformació DTO, lògica de descomptes, validació, i gestió de cistella.</p>

<h4>3.9.3. Pas 1: Crear servei d'accés a dades</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Injectable({ providedIn: &#39;root&#39; })
export class ProductDataService {
  private apiUrl = &#39;https://api.example.com&#39;;

  constructor(private http: HttpClient) {}

  getProducts(): Observable&lt;Product[]&gt; {
    return this.http.get&lt;{ data: any[] }&gt;(`${this.apiUrl}/products`)
      .pipe(
        map(response =&gt; response.data.map(item =&gt; ({
          id: item.product_id,
          name: item.product_name,
          price: item.price_cents / 100,
          stock: item.available_quantity
        })))
      );
  }
}</code></pre>
  </div>
</div>


<h4>3.9.4. Pas 2: Crear serveis de lògica</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Injectable({ providedIn: &#39;root&#39; })
export class DiscountService {
  calculateDiscount(product: Product): number {
    if (product.stock &gt; 100) return 20;
    if (product.stock &gt; 50) return 10;
    return 0;
  }
}

@Injectable({ providedIn: &#39;root&#39; })
export class ProductValidationService {
  canBeSold(product: Product): boolean {
    return product.stock &gt; 0;
  }
}

@Injectable({ providedIn: &#39;root&#39; })
export class CartService {
  private cart: Product[] = [];

  add(product: Product): void {
    this.cart.push(product);
    localStorage.setItem(&#39;cart&#39;, JSON.stringify(this.cart));
  }

  getCart(): Product[] {
    return this.cart;
  }
}</code></pre>
  </div>
</div>


<h4>3.9.5. Pas 3: Refactoritzar component (només presentació)</h4>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Component({
  selector: &#39;app-product-list&#39;,
  template: `
    &lt;div *ngFor=&quot;let product of products$ | async&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€ - Descompte: {{ getDiscount(product) }}%&lt;/p&gt;
      &lt;button (click)=&quot;addToCart(product)&quot; [disabled]=&quot;!canBeSold(product)&quot;&gt;
        Afegir
      &lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ProductListComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private validation: ProductValidationService,
    private cart: CartService
  ) {}

  getDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }

  canBeSold(product: Product): boolean {
    return this.validation.canBeSold(product);
  }

  addToCart(product: Product): void {
    this.cart.add(product);
  }
}</code></pre>
  </div>
</div>


<h4>3.9.6. Resultats de la refactorització</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Abans</th>
<th>Després</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Línies al component</strong></td>
<td>80</td>
<td>30</td>
</tr>
<tr>
<td><strong>Responsabilitats</strong></td>
<td>6 en 1 classe</td>
<td>1 per classe (5 classes)</td>
</tr>
<tr>
<td><strong>Reutilització</strong></td>
<td>Impossible</td>
<td>Fàcil (injectar serveis)</td>
</tr>
<tr>
<td><strong>Proves</strong></td>
<td>Molt difícils</td>
<td>Senzilles (cada servei independent)</td>
</tr>
<tr>
<td><strong>Mantenibilitat</strong></td>
<td>Baixa (tot barrejat)</td>
<td>Alta (cada capa independent)</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> Refactoritzar components barrejats en capes separades redueix línies de codi per fitxer, millora testabilitat, i permet reutilització de lògica.
</div>


<h4>3.9.7. Resultat esperat</h4>
<p>L'alumnat aplica la separació de responsabilitats refactoritzant components barrejats en arquitectura de capes clara i mantenible.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.10. Beneficis: proves més fàcils, canvis localitzats, reutilització</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.10.1. Objectiu</h4>
<p>Quantificar i comprendre els beneficis pràctics de la separació de responsabilitats en capes.</p>

<h4>3.10.2. Benefici 1: Proves unitàries més senzilles</h4>
<p><strong>Sense separació de capes:</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Per provar càlcul de descompte necessites:
TestBed.configureTestingModule({
  imports: [HttpClientTestingModule],
  declarations: [ProductListComponent],
  providers: [...]
});
// Simular HttpClient, localStorage, events...
// 50 línies de setup per provar 1 funció</code></pre>
  </div>
</div>


<p><strong>Amb separació de capes:</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Per provar càlcul de descompte:
const service = new DiscountService();
expect(service.calculateDiscount(product)).toBe(20);
// 2 línies, zero mocks</code></pre>
  </div>
</div>


<p><strong>Comparativa quantitativa:</strong></p>
<ul>
  <li>Temps per escriure test: 15 minuts → 2 minuts (87% més ràpid)</li>
  <li>Línies de codi de test: 50 → 5 (90% menys)</li>
  <li>Temps d'execució del test: 500ms → 5ms (99% més ràpid)</li>
</ul>

<h4>3.10.3. Benefici 2: Canvis localitzats i risc reduït</h4>
<p><strong>Sense separació:</strong></p>
<ul>
  <li>Canviar regla de descompte: Modificar 5 components diferents</li>
  <li>Canviar API: Modificar 15 components que fan peticions HTTP</li>
  <li>Risc d'error: Alt (tocar múltiples fitxers)</li>
</ul>

<p><strong>Amb separació:</strong></p>
<ul>
  <li>Canviar regla de descompte: Modificar 1 servei (<code>DiscountService</code>)</li>
  <li>Canviar API: Modificar 1 servei (<code>ProductDataService</code>)</li>
  <li>Risc d'error: Baix (tocar únic fitxer responsable)</li>
</ul>

<p><strong>Exemple real:</strong></p>
<p>L'API canvia el format de preus de <code>price_cents</code> a <code>price_euros</code>:</p>


<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">// Sense separació: Canviar 15 components
// Component 1
this.products = response.data.map(item =&gt; ({ price: item.price_cents / 100 }));
// Component 2
this.products = response.data.map(item =&gt; ({ price: item.price_cents / 100 }));
// ... 13 components més amb el mateix codi duplicat

// Amb separació: Canviar 1 servei
@Injectable({ providedIn: &#39;root&#39; })
export class ProductDataService {
  private mapDTOToModel(dto: ProductDTO): Product {
    return {
      price: dto.price_euros // ← Únic canvi necessari
    };
  }
}</code></pre>
  </div>
</div>


<h4>3.10.4. Benefici 3: Reutilització de lògica</h4>
<p><strong>Sense separació:</strong></p>
<ul>
  <li>Lògica de descomptes copiada en 5 components</li>
  <li>Total: 5 × 15 línies = 75 línies duplicades</li>
  <li>Canviar lògica: Modificar 5 fitxers</li>
</ul>

<p><strong>Amb separació:</strong></p>
<ul>
  <li>Lògica de descomptes en 1 servei</li>
  <li>Total: 1 × 15 línies = 15 línies</li>
  <li>Canviar lògica: Modificar 1 fitxer</li>
</ul>

<p><strong>Estalvi:</strong> 60 línies de codi duplicat (80% reducció).</p>

<h4>3.10.5. Benefici 4: Facilitat per afegir funcionalitats</h4>
<p>Afegir nova regla de negoci "descompte per client VIP":</p>

<p><strong>Sense separació:</strong></p>
<ol>
  <li>Identificar tots els components que calculen descomptes (30 minuts)</li>
  <li>Modificar cada component individualment (2 hores)</li>
  <li>Provar cada component (1 hora)</li>
</ol>
<p><strong>Total: 3.5 hores</strong></p>

<p><strong>Amb separació:</strong></p>
<ol>
  <li>Modificar <code>DiscountService.calculateDiscount()</code> (15 minuts)</li>
  <li>Provar el servei (5 minuts)</li>
</ol>
<p><strong>Total: 20 minuts</strong></p>

<p><strong>Millora: 90% més ràpid.</strong></p>

<h4>3.10.6. Taula resum de beneficis quantificats</h4>
<table>
<thead>
<tr>
<th>Benefici</th>
<th>Sense separació</th>
<th>Amb separació</th>
<th>Millora</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Temps escriure test</strong></td>
<td>15 min</td>
<td>2 min</td>
<td>87% més ràpid</td>
</tr>
<tr>
<td><strong>Línies codi test</strong></td>
<td>50</td>
<td>5</td>
<td>90% menys</td>
</tr>
<tr>
<td><strong>Fitxers a modificar per canvi API</strong></td>
<td>15</td>
<td>1</td>
<td>93% menys</td>
</tr>
<tr>
<td><strong>Codi duplicat</strong></td>
<td>75 línies</td>
<td>0 línies</td>
<td>100% eliminat</td>
</tr>
<tr>
<td><strong>Temps afegir funcionalitat</strong></td>
<td>3.5 h</td>
<td>20 min</td>
<td>90% més ràpid</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> La separació de responsabilitats en capes redueix dràsticament el temps de proves, canvis i noves funcionalitats, eliminant duplicació i localitzant modificacions.
</div>


<h4>3.10.7. Resultat esperat</h4>
<p>L'alumnat quantifica els beneficis reals de la separació de responsabilitats en proves, mantenibilitat i productivitat de desenvolupament.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.11. Patró de contenidor/presentacional: smart vs dumb components</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h4>3.11.1. Objectiu</h4>
<p>Aprendre el patró contenidor/presentacional per organitzar components en smart (contenidors) i dumb (presentacionals).</p>

<h4>3.11.2. Definició del patró</h4>
<p><strong>Smart components (contenidors):</strong></p>
<ul>
  <li>Gestionen estat i lògica</li>
  <li>Injecten i usen serveis</li>
  <li>Obtenen dades d'APIs</li>
  <li>Passen dades a components fills via <code>@Input()</code></li>
  <li>Gestionen esdeveniments de components fills via <code>@Output()</code></li>
</ul>

<p><strong>Dumb components (presentacionals):</strong></p>
<ul>
  <li>Reben dades via <code>@Input()</code></li>
  <li>Mostren dades amb interpolació</li>
  <li>Emeten esdeveniments via <code>@Output()</code></li>
  <li>No injecten serveis</li>
  <li>Totalment reutilitzables i testejables</li>
</ul>

<h4>3.11.3. Exemple complet del patró</h4>
<p><strong>Component presentacional (dumb):</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Component({
  selector: &#39;app-product-card&#39;,
  template: `
    &lt;div class=&quot;card&quot;&gt;
      &lt;h3&gt;{{ product.name }}&lt;/h3&gt;
      &lt;p&gt;{{ product.price }}€&lt;/p&gt;
      &lt;span class=&quot;discount&quot; *ngIf=&quot;discount &gt; 0&quot;&gt;-{{ discount }}%&lt;/span&gt;
      &lt;button (click)=&quot;onAddClick()&quot;&gt;Afegir&lt;/button&gt;
    &lt;/div&gt;
  `
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() discount: number = 0;
  @Output() addToCart = new EventEmitter&lt;Product&gt;();

  onAddClick(): void {
    this.addToCart.emit(this.product);
  }
}</code></pre>
  </div>
</div>


<p><strong>Component contenidor (smart):</strong></p>

<div class="code-block" data-lang="typescript" role="region" aria-label="Bloc de codi typescript">
  <div class="code-header">
    <div class="code-info">
      <span class="code-lang">TYPESCRIPT</span>
      
    </div>
    <div class="code-actions">
      <button class="toggle-expand" title="Expandir/Col·lapsar alçada" aria-label="Expandir o col·lapsar alçada" aria-pressed="false"><i class="bi bi-arrows-fullscreen" aria-hidden="true"></i></button>
      <button class="toggle-lines" title="Mostrar/Ocultar números de línia" aria-label="Mostrar o ocultar números de línia">#</button>
      <button class="copy-btn" title="Copiar codi al portapapers" aria-label="Copiar codi"><i class="bi bi-clipboard" aria-hidden="true"></i></button>
    </div>
  </div>

  <div class="code-container">
    <div class="line-numbers" aria-hidden="true"></div>
    <pre role="textbox" aria-readonly="true" aria-label="Codi font"><code class="language-typescript">@Component({
  selector: &#39;app-product-list-container&#39;,
  template: `
    &lt;app-product-card
      *ngFor=&quot;let product of products$ | async&quot;
      [product]=&quot;product&quot;
      [discount]=&quot;calculateDiscount(product)&quot;
      (addToCart)=&quot;handleAddToCart($event)&quot;&gt;
    &lt;/app-product-card&gt;
  `
})
export class ProductListContainerComponent {
  products$ = this.productData.getProducts();

  constructor(
    private productData: ProductDataService,
    private discount: DiscountService,
    private cart: CartService
  ) {}

  calculateDiscount(product: Product): number {
    return this.discount.calculateDiscount(product);
  }

  handleAddToCart(product: Product): void {
    this.cart.add(product);
  }
}</code></pre>
  </div>
</div>


<h4>3.11.4. Avantatges del patró</h4>
<ol>
  <li><strong>Components presentacionals molt reutilitzables:</strong> <code>ProductCardComponent</code> es pot usar en llista, cerca, preferits, relacionats, etc.</li>
  <li><strong>Proves senzilles:</strong> Testejar <code>ProductCardComponent</code> només requereix passar dades simulades, no serveis.</li>
  <li><strong>Separació clara:</strong> El contenidor gestiona lògica; el presentacional només mostra.</li>
  <li><strong>Canvis visuals aïllats:</strong> Modificar l'aparença de <code>ProductCardComponent</code> no afecta la lògica del contenidor.</li>
</ol>

<h4>3.11.5. Quan usar cada tipus</h4>
<table>
<thead>
<tr>
<th>Situació</th>
<th>Component a usar</th>
</tr>
</thead>
<tbody>
<tr>
<td>Necessita accedir a serveis</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Només mostra dades rebudes</td>
<td>Dumb (presentacional)</td>
</tr>
<tr>
<td>Gestiona estat global</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Es reutilitza en múltiples contextos</td>
<td>Dumb (presentacional)</td>
</tr>
<tr>
<td>Fa peticions HTTP</td>
<td>Smart (contenidor)</td>
</tr>
<tr>
<td>Només emet esdeveniments</td>
<td>Dumb (presentacional)</td>
</tr>
</tbody>
</table>

<!-- Component: Caixa d'èxit -->
<div class="success-box" role="status" aria-live="polite">
    <div class="component-header success-header" role="heading" aria-level="4"><i class="bi bi-check-circle" aria-hidden="true"></i> Èxit</div>
    <strong>Clau:</strong> El patró contenidor/presentacional separa components en smart (amb lògica i serveis) i dumb (només presentació), millorant reutilització i testabilitat.
</div>


<h4>3.11.6. Resultat esperat</h4>
<p>L'alumnat aplica el patró contenidor/presentacional creant components smart que gestionen lògica i components dumb que només presenten dades.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.12. Mini exemple pràctic · Component de llista amb capes separades</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Mini exemple pràctic:</strong> Component de llista amb capes separades</p>
<ol>
  <li>Crear servei d'accés a dades <code>ProductDataService</code> que obté productes de JSONPlaceholder</li>
  <li>Crear servei de lògica <code>DiscountService</code> amb mètode <code>calculateDiscount(stock: number)</code></li>
  <li>Crear component presentacional <code>ProductCardComponent</code> amb <code>@Input() product</code> i <code>@Output() selected</code></li>
  <li>Crear component contenidor <code>ProductListContainerComponent</code> que injecta els serveis</li>
  <li>Al contenidor, obtenir productes amb <code>products$ = this.productData.getProducts()</code></li>
  <li>Al template del contenidor, usar <code>*ngFor</code> amb <code>async</code> pipe per iterar productes</li>
  <li>Passar cada producte al <code>ProductCardComponent</code> amb <code>[product]="p"</code> i <code>[discount]="calculateDiscount(p)"</code></li>
  <li>Gestionar esdeveniment <code>(selected)</code> al contenidor per mostrar log a consola</li>
</ol>

<p><strong>Resultat esperat:</strong> Una aplicació organitzada en capes clares on el component contenidor gestiona lògica i dades mentre el component presentacional només mostra.</p>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.13. Resolució de problemes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Resolució de problemes (Win/macOS/Linux):</strong></p>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Possible causa</th>
<th>Solució ràpida</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component necessita múltiples serveis injectats</td>
<td>El component fa massa coses; hauria de ser un contenidor o dividir-se</td>
<td>Refactoritzar en component contenidor (smart) que gestiona serveis i component presentacional (dumb) que només mostra</td>
</tr>
<tr>
<td>Error "Cannot read property of undefined" en component presentacional</td>
<td>El <code>@Input()</code> no està rebent dades del pare o es mostra abans que arribin</td>
<td>Usar operador <code>?</code> de safe navigation (<code>product?.name</code>) o <code>*ngIf="product"</code> per esperar dades</td>
</tr>
<tr>
<td>Lògica de negoci duplicada en múltiples components</td>
<td>No s'ha creat servei de lògica; cada component implementa la seva versió</td>
<td>Crear servei <code>@Injectable</code> amb la lògica i injectar-lo als components que ho necessitin</td>
</tr>
<tr>
<td>Proves unitàries requereixen molts mocks</td>
<td>El component té massa dependències; no està separat en capes</td>
<td>Separar lògica en serveis i provar serveis independentment sense component</td>
</tr>
<tr>
<td>Canviar API requereix modificar molts components</td>
<td>Components accedeixen directament a HttpClient; no hi ha capa d'accés a dades</td>
<td>Crear servei d'accés a dades que encapsula HttpClient i usar-lo als components</td>
</tr>
<tr>
<td>Component de 300+ línies difícil de mantenir</td>
<td>Component té múltiples responsabilitats barrejades</td>
<td>Aplicar refactorització: separar en serveis (lògica, dades) i dividir en components més petits</td>
</tr>
<tr>
<td>Components no es poden reutilitzar en altres contextos</td>
<td>Components estan acoblats a serveis específics; no són presentacionals</td>
<td>Convertir en components presentacionals amb <code>@Input/@Output</code>, sense injecció de serveis</td>
</tr>
<tr>
<td>Dificultat per trobar on canviar una regla de negoci</td>
<td>Lògica està dispersa en múltiples components</td>
<td>Centralitzar lògica en servei dedicat; components només criden mètodes del servei</td>
</tr>
</tbody>
</table>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.14. Prompts d'IA</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<p><strong>Prompts d'IA:</strong></p>

<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Arquitecte de programari especialitzat en refactorització i arquitectura neta. <strong>Context:</strong> Tinc un component Angular de 250 línies que gestiona una llista de productes, fa peticions HTTP a una API, calcula descomptes segons regles de negoci, valida dades abans d'enviar, i gestiona l'estat de la cistella amb localStorage. Tot el codi està barrejat en un únic component. <strong>Tasca:</strong> Dissenya una refactorització completa aplicant separació de responsabilitats en capes: crea els serveis necessaris (accés a dades, lògica de negoci, gestió d'estat), defineix les responsabilitats de cadascun, i mostra com quedaria el component refactoritzat. <strong>Format:</strong> Document amb estructura de carpetes, codi complet de cada servei amb comentaris explicatius, i el component refactoritzat final amb explicació dels beneficis aconseguits.</div>
  </div>
</div>


<!-- Component: Prompt per IA amb caixa de text i botó de còpia -->
<div class="ai-prompt" role="note">
  <div class="component-header ai-header" role="heading" aria-level="4">
    <i class="bi bi-robot" aria-hidden="true"></i> Prompt per IA
    <div class="ai-actions">
      <button type="button" class="copy-btn" title="Copiar prompt" aria-label="Copiar prompt">
        <i class="bi bi-clipboard" aria-hidden="true"></i>
      </button>
    </div>
  </div>
  <div class="ai-container">
    <div class="ai-prompt-content" aria-label="Text del prompt"><strong>Rol:</strong> Instructor d'Angular especialitzat en patrons arquitectònics. <strong>Context:</strong> Estic creant una aplicació de gestió de comandes de restaurant on necessito mostrar plats disponibles, calcular preus amb descomptes per menú del dia, validar que hi ha ingredients disponibles, i comunicar-me amb una API per obtenir el catàleg i enviar comandes. Vull aplicar el patró contenidor/presentacional amb separació clara de responsabilitats. <strong>Tasca:</strong> Proporciona una arquitectura completa en capes especificant: (1) Quins serveis d'accés a dades crear i les seves responsabilitats, (2) Quins serveis de lògica de negoci crear amb exemples de regles concretes, (3) Quins components smart (contenidors) i dumb (presentacionals) crear, (4) Com es comuniquen entre ells amb diagrames de flux de dades. <strong>Format:</strong> Document arquitectònic amb diagrames de capes, especificació de responsabilitats per cada classe, i exemples de codi dels punts clau.</div>
  </div>
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.15. Autoavaluació</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<h3>Autoavaluació</h3>
<!-- Component: Checklist (sense contenidor extern) -->

<div class="checklist-list" role="group" aria-label="Checklist">
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Aplico el principi de responsabilitat única creant classes amb una única raó per canviar</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Organitzo l'aplicació en tres capes clares: presentació (components), lògica (serveis de negoci), i dades (serveis d'accés a APIs)</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Creo components presentacionals purs que només reben dades via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code> sense lògica de negoci</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Implemento serveis de lògica de negoci amb regles, validacions i càlculs separats de components i accés a dades</div>
  </div>
  
  <div class="checklist-item" role="checkbox" tabindex="0" aria-checked="false">
    <div class="checklist-checkbox" aria-hidden="true"></div>
    <div class="checklist-text">Aplico el patró contenidor/presentacional separant components smart (amb serveis i lògica) de components dumb (només presentació)</div>
  </div>
  
  <!-- Interacció via JS en assets/js/site.js: click/teclat actualitza aria-checked -->
</div>

  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.16. Síntesi</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<ul>
  <li>La separació de responsabilitats en capes organitza el codi en presentació (components), lògica de negoci (serveis), i accés a dades (serveis d'API), aplicant el principi de responsabilitat única on cada classe té una única raó per canviar.</li>
  <li>Els components presentacionals purs només mostren dades rebudes via <code>@Input()</code> i emeten esdeveniments via <code>@Output()</code> sense injectar serveis ni contenir lògica, facilitant proves unitàries i reutilització en múltiples contextos.</li>
  <li>Els serveis de lògica de negoci encapsulen regles, validacions, càlculs i processament, permetent reutilització des de múltiples components i garantint consistència quan les regles canvien.</li>
  <li>Els serveis d'accés a dades encapsulen tota la comunicació amb APIs, transformant DTOs a models interns i gestionant errors de manera centralitzada, desacoblant el codi del backend específic utilitzat.</li>
  <li>El patró contenidor/presentacional separa components smart (amb serveis, lògica i estat) de components dumb (només presentació), reduint línies de codi per component en un 70%, millorant testabilitat en un 90%, i eliminant 100% de codi duplicat.</li>
</ul>
  
  </div>
</div>


  
  <!-- Component: Punt destacat dins d'una secció -->


<div class="section-point" >
  <div class="component-header section-point-header" role="heading" aria-level="4">
    <i class="bi bi-journal-text" aria-hidden="true"></i>
    <div class="section-point-meta">
      <div class="section-point-title">3.17. Repàs de conceptes</div>
      
    </div>
  </div>
  <div class="section-point-body component-content">
    
<ul>
  <li><strong>Principi de responsabilitat única (SRP):</strong> Cada classe o funció ha de tenir una única raó per canviar, fent només una cosa ben definida.</li>
  <li><strong>Capa de presentació:</strong> Components que només mostren dades a l'usuari i capturen interaccions sense lògica de negoci ni accés a dades.</li>
  <li><strong>Capa de lògica de negoci:</strong> Serveis amb regles de negoci, validacions, càlculs i processament de dades aplicables des de múltiples components.</li>
  <li><strong>Capa d'accés a dades:</strong> Serveis que comuniquen amb APIs externes, transformen DTOs a models interns i gestionen errors HTTP.</li>
  <li><strong>Component presentacional (dumb):</strong> Rep dades via <code>@Input()</code>, les mostra, i emet esdeveniments via <code>@Output()</code> sense injectar serveis.</li>
  <li><strong>Component contenidor (smart):</strong> Gestiona estat i lògica, injecta serveis, obté dades i les passa a components presentacionals fills.</li>
  <li><strong>DTO (Data Transfer Object):</strong> Objecte amb el format de dades que retorna l'API, diferent del model intern usat per l'aplicació.</li>
  <li><strong>Model intern:</strong> Representació de dades adaptada a les necessitats de l'aplicació, transformada des de DTOs de l'API.</li>
  <li><strong>Desacoblament:</strong> Reducció de dependències directes entre capes usant abstraccions (serveis, interfícies) en lloc d'implementacions concretes.</li>
  <li><strong>Refactorització:</strong> Procés de reestructurar codi existent sense canviar comportament extern, millorant organització i mantenibilitat.</li>
  <li><strong>Reutilització de lògica:</strong> Capacitat d'usar la mateixa lògica de negoci des de múltiples components injectant serveis compartits.</li>
  <li><strong>Flux unidireccional de dades:</strong> Les dades flueixen en una direcció clara: capa de dades → lògica → presentació, facilitant depuració.</li>
</ul>
  
  </div>
</div>


</div>


<!-- Exercicis proposats (si estan definits) -->


<!-- Recursos addicionals -->


<!-- Glossari del bloc -->



<!-- Schema.org structured data per SEO -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "name": "Bloc 2: Arquitectura i patrons",
  "description": "Gestió d'estat, modularització i bones pràctiques arquitectòniques",
  "author": {
    "@type": "Organization",
    "name": "Institut Obert de Catalunya"
  },
  "provider": {
    "@type": "Organization",
    "name": "Institut Obert de Catalunya"
  },
  "educationalLevel": "Intermediate",
  "learningResourceType": "Course Module",
  "inLanguage": "ca",
  
  
  "isPartOf": {
    "@type": "Course",
    "name": "DA2_OA01 - Programació Avançada (Angular) — IOC",
    "description": "Materials del mòdul DA2_OA01 - Programació Avançada amb Angular"
  }
}
</script>

                </div>
            </article>
            
            <!-- Navegació entre pàgines -->
            
            <nav class="page-navigation" role="navigation" aria-label="Navegació entre blocs">
                <div class="nav-links-container">
                    
                    
                    
                    
                    
                    
                    
                    
                        
                    
                        
                    
                        
                    
                        
                            
                            
                    
                    
                    
                        
                            
                        
                            
                                
                                
                                
                                
                                
                                    
                                    
                                        
                                            
                                            
                                
                                
                                
                                
                                
                                    
                                
                                    
                                
                                    
                                        
                                        
                                
                                
                    
                    
                    <div class="nav-link-wrapper">
                        
                        <a href="/ioc/da2_OA01/unitat-4/bloc-1/" class="nav-button" aria-label="Bloc anterior: Sistema de rutes i navegació">← Anterior</a>
                        
                    </div>
                    
                    <div class="nav-link-wrapper">
                        
                        <a href="/ioc/da2_OA01/unitat-4/bloc-3/" class="nav-button" aria-label="Bloc següent: Optimització de rendiment">Següent →</a>
                        
                    </div>
                </div>
            </nav>
            
        </main>
    </div>

    <!-- Footer fix -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-info">
                Versió v1.0
            </div>
            <div class="footer-progress" aria-label="Progrés de lectura"><!-- Progrés per unitats (posició de la unitat actual) --><div class="progress-group course-progress">
                    <span class="progress-label">Unitat</span>
                    <span class="progress-text" data-pos="4" data-total="4">(4/4)</span>
                    <div class="progress-bar-footer"><div class="progress-fill-footer" style="width: 100%"></div></div>
                </div><!-- Progrés per blocs dins de la unitat --><div class="progress-group unit-progress">
                        <span class="progress-label">Bloc</span>
                        <span class="progress-text" data-pos="2" data-total="4">(2/4)</span>
                        <div class="progress-bar-footer"><div class="progress-fill-footer" style="width: 50%"></div></div>
                    </div>

                    <!-- Progrés per seccions (H2) dins del bloc --><div class="progress-group section-progress" data-scan-sections="true">
                        <span class="progress-label">Secció</span>
                        <span class="progress-text" data-pos="1" data-total="3">(1/3)</span>
                        <div class="progress-bar-footer"><div class="progress-fill-footer" style="width: 33%"></div></div>
                    </div></div>
            <div class="footer-actions" aria-label="Accions ràpides">
                <button class="task-btn footer-collapse-toggle" type="button" aria-expanded="true" aria-label="Amaga el peu de pàgina">
                  <i class="bi bi-chevron-down" aria-hidden="true"></i>
                </button>
                <a href="#top" id="footer-btn-top" class="task-btn" aria-label="Anar a l'inici">↑</a>
                <a href="#bottom" id="footer-btn-bottom" class="task-btn" aria-label="Anar al final">↓</a>
                <a href="#next" id="footer-btn-next" class="task-btn" aria-label="Secció següent">→</a>
                <a href="#prev" id="footer-btn-prev" class="task-btn" aria-label="Secció anterior">←</a>
                <a href="#bookmark" id="footer-btn-bookmark" class="task-btn" aria-label="Desar marcador" title="Desar marcador">
                  <i class="bi bi-bookmark" aria-hidden="true"></i>
                </a>
                <a href="/ioc/da2_OA01/quadern.html" class="task-btn" aria-label="Obrir quadern complet" title="Quadern">
                  <i class="bi bi-journal-text" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </footer>

    <!-- Scripts del lloc -->
    <script src="/ioc/da2_OA01/assets/js/site.js" defer></script>
    <!-- Quadern Notes v2 (nou sistema) -->
    <script src="/ioc/da2_OA01/assets/js/quadern-app/constants.js" defer></script>
    <script src="/ioc/da2_OA01/assets/js/quadern-app/utils.js" defer></script>
    <script src="/ioc/da2_OA01/assets/js/quadern-app/store.js" defer></script>
    <script src="/ioc/da2_OA01/assets/js/quadern-app/panel.js" defer></script>
    <script src="/ioc/da2_OA01/assets/js/index-notes.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer></script>
    <script src="/ioc/da2_OA01/assets/js/quadern-app/rich-editor.js" defer></script>
    <script>
      document.addEventListener('DOMContentLoaded', function(){
        if (window.Quadern && typeof window.Quadern.bootstrapNotes === 'function') {
          try { window.Quadern.bootstrapNotes(); } catch(e) {}
        }
        if (window.Quadern && window.Quadern.RichEditor && typeof window.Quadern.RichEditor.autoInit === 'function') {
          try { window.Quadern.RichEditor.autoInit(); } catch(e) {}
        }
      });
    </script>
</body>
</html>
