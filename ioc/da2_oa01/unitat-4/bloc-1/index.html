---
layout: bloc
title: "Bloc 1: Sistema de rutes i navegació"
description: "Configuració de rutes, paràmetres i guàrdies de navegació"
keywords: "Angular, Router, rutes, navegació, SPA"
unitat: 4
bloc: 1
bloc_numero: 1
---

<!--
  ═══════════════════════════════════════════════════════════════════
  BLOC 1 - UNITAT 4
  Contingut migrat des de:
  - .resources/Autoria/Unitat4/Lliço1/OA1/lectura-u4-l1-oa1.md
  - .resources/Autoria/Unitat4/Lliço1/OA2/lectura-u4-l1-oa2.md
  - .resources/Autoria/Unitat4/Lliço1/OA3/lectura-u4-l1-oa3.md
  ═══════════════════════════════════════════════════════════════════
-->

<div class="section" id="Unitat4_Bloc1_Seccio1">
  <h2 id="Unitat4_Bloc1_Seccio1">1. Configuració del sistema de rutes</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=1 seccio=1 %}


  {% include objectius.html llista="Configurar el sistema de rutes d'Angular per crear aplicacions de múltiples vistes sense recàrregar la pàgina.|Implementar el mapa de rutes principal amb les vistes del catàleg.|Crear menú de navegació amb indicadors visuals de ruta activa.|Verificar el funcionament del sistema de rutes i documentar la configuració." %}

  {% include info_box.html contingut="<strong>RA4 · Criteri 1</strong> — Configura la navegació entre pantalles i la gestió de paràmetres." %}

  {% capture section_point_1_1 %}
  <ul>
    <li>Projecte <code>catalog-elements</code> amb serveis HTTP, formularis i gestió d'estats funcionals</li>
    <li>Components principals creats: <code>CatalegPageComponent</code>, <code>FormulariCercaComponent</code>, <code>PreferitsPanelComponent</code></li>
    <li>Git actualitzat amb commit recent i <code>git status</code> net</li>
    <li>Node.js i Angular CLI operatius (versions 20.x i Angular 18+)</li>
    <li>Servidor de desenvolupament funcional: <code>ng serve</code> arrenca sense errors</li>
    <li>Carpeta de documentació: <code>docs/navegacio.md</code> creada (pot estar buida)</li>
  </ul>

  <p><strong>Verificació ràpida:</strong></p>

  <p><strong>PowerShell (Windows):</strong></p>
{% capture code_1 %}Set-Location $env:USERPROFILE\workspace\catalog-elements
ng version | Select-String "Angular CLI"
git status
Test-Path src\app\pages\cataleg-page{% endcapture %}
{% include code-block.html lang="powershell" code=code_1 %}

  <p><strong>bash/zsh (macOS/Linux):</strong></p>
{% capture code_2 %}cd ~/workspace/catalog-elements
ng version | grep "Angular CLI"
git status
ls -d src/app/pages/cataleg-page{% endcapture %}
{% include code-block.html lang="bash" code=code_2 %}

  <p><strong>Punt d'autocomprovació:</strong> Veieu la versió d'Angular CLI (≥18.0.0), <code>git status</code> mostra "working tree clean" i la carpeta <code>cataleg-page</code> existeix.</p>
  {% endcapture %}
  {% include section-point.html numero="1.1" titol="Prerequisits" contingut=section_point_1_1 %}

  {% capture section_point_1_2 %}

  <h4>1.2.1. Què és el sistema de rutes d'Angular</h4>
  <p>El <strong>Router d'Angular</strong> és un servei que gestiona la navegació entre diferents vistes (components) d'una aplicació sense recarregar la pàgina sencera. Mapeja URLs específiques a components concrets i manté sincronitzada la barra d'adreces del navegador amb el contingut mostrat a l'usuari.</p>

  <p>Aquest sistema permet construir <strong>Single Page Applications (SPA)</strong>: aplicacions que carreguen un sol document HTML però ofereixen l'experiència de múltiples pàgines mitjançant la manipulació del DOM i l'historial del navegador.</p>

  <h4>1.2.2. Problema sense sistema de rutes</h4>
  <p>Sense sistema de rutes, una aplicació Angular tradicional només pot mostrar una vista fixa. Imagina l'aplicació del catàleg d'elements amb tres seccions diferents:</p>

{% capture code_3 %}// app.component.ts - Solució MANUAL sense rutes
@Component({
  selector: 'app-root',
  template: `
    <nav>
      <button (click)="vistaActual = 'cataleg'">Catàleg</button>
      <button (click)="vistaActual = 'cerca'">Cerca</button>
      <button (click)="vistaActual = 'preferits'">Preferits</button>
    </nav>
    <div *ngIf="vistaActual === 'cataleg'"><app-cataleg-page></app-cataleg-page></div>
    <div *ngIf="vistaActual === 'cerca'"><app-formulari-cerca></app-formulari-cerca></div>
    <div *ngIf="vistaActual === 'preferits'"><app-preferits-panel></app-preferits-panel></div>
  `
})
export class AppComponent {
  vistaActual = 'cataleg';
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_3 %}

  <p>Aquesta solució genera múltiples problemes:</p>
  <ul>
    <li><strong>URLs no reflecteixen l'estat:</strong> La barra d'adreces sempre mostra la mateixa URL. No es poden compartir enllaços específics ni crear marcadors per cada secció</li>
    <li><strong>Botons de navegació no funcionen:</strong> Els botons "Enrere" i "Endavant" del navegador no responen perquè la URL no canvia</li>
    <li><strong>Codi desorganitzat:</strong> Tot el codi de navegació queda en un sol component gegant, difícil de mantenir i provar</li>
    <li><strong>Càrrega innecessària:</strong> Tots els components es carreguen sempre, fins i tot els que l'usuari no visitarà mai</li>
    <li><strong>SEO impossible:</strong> Els motors de cerca només indexen una URL, no poden trobar contingut específic</li>
  </ul>

  <h4>1.2.3. Solució amb sistema de rutes</h4>
  <p>Angular Router soluciona tots aquests problemes amb un sistema centralitzat de navegació:</p>

{% capture code_4 %}// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { CatalegPageComponent } from './pages/cataleg-page/cataleg-page.component';
import { FormulariCercaComponent } from './components/formulari-cerca/formulari-cerca.component';
import { PreferitsPanelComponent } from './components/preferits-panel/preferits-panel.component';

export const routes: Routes = [
  { path: '', redirectTo: 'cataleg', pathMatch: 'full' },
  { path: 'cataleg', component: CatalegPageComponent, title: 'Catàleg d\\'elements' },
  { path: 'cerca', component: FormulariCercaComponent, title: 'Cerca d\\'elements' },
  { path: 'preferits', component: PreferitsPanelComponent, title: 'Els meus preferits' },
  { path: 'detall/:id', component: DetallElementComponent, title: 'Detall de l\\'element' },
  { path: '**', redirectTo: 'cataleg' }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_4 %}

{% capture code_5 %}// src/app/app.component.ts
import { Component } from '@angular/core';
import { RouterModule } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterModule],
  template: `
    <nav class="menu-principal">
      <a routerLink="/cataleg" routerLinkActive="actiu">Catàleg</a>
      <a routerLink="/cerca" routerLinkActive="actiu">Cerca</a>
      <a routerLink="/preferits" routerLinkActive="actiu">Preferits</a>
    </nav>
    <main><router-outlet></router-outlet></main>
  `
})
export class AppComponent {}{% endcapture %}
{% include code-block.html lang="typescript" code=code_5 %}

  <p><strong>Avantatges d'aquesta solució:</strong></p>
  <ul>
    <li><strong>URLs significatives:</strong> Cada vista té la seva URL única que es pot compartir, guardar com a marcador i recarregar mantenint l'estat</li>
    <li><strong>Navegació funcional:</strong> Els botons enrere/endavant del navegador funcionen correctament perquè el Router actualitza l'historial</li>
    <li><strong>Codi organitzat:</strong> Cada vista té el seu propi component amb responsabilitats clarament definides</li>
    <li><strong>Càrrega selectiva:</strong> El Router només carrega el component de la ruta activa, millorant el rendiment inicial</li>
    <li><strong>SEO optimitzat:</strong> Cada ruta és indexable pels motors de cerca amb el seu propi contingut i metadades</li>
  </ul>

  <h4>1.2.4. Components clau del sistema</h4>
  <p>El Router d'Angular es compon de diversos elements que treballen junts:</p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Component</th>
        <th>Tipus</th>
        <th>Funció</th>
        <th>Exemple</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Routes</strong></td>
        <td>Array TypeScript</td>
        <td>Mapeja URLs a components</td>
        <td><code>[{ path: 'cataleg', component: CatalegComponent }]</code></td>
      </tr>
      <tr>
        <td><strong>RouterModule</strong></td>
        <td>NgModule</td>
        <td>Proporciona directives i serveis</td>
        <td><code>imports: [RouterModule]</code></td>
      </tr>
      <tr>
        <td><strong>router-outlet</strong></td>
        <td>Directiva</td>
        <td>Marca on renderitzar el component actiu</td>
        <td><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></td>
      </tr>
      <tr>
        <td><strong>routerLink</strong></td>
        <td>Directiva</td>
        <td>Crea enllaços de navegació</td>
        <td><code>&lt;a routerLink="/cataleg"&gt;</code></td>
      </tr>
      <tr>
        <td><strong>routerLinkActive</strong></td>
        <td>Directiva</td>
        <td>Afegeix classe CSS a ruta activa</td>
        <td><code>&lt;a routerLinkActive="actiu"&gt;</code></td>
      </tr>
      <tr>
        <td><strong>Router</strong></td>
        <td>Servei</td>
        <td>Permet navegació programàtica</td>
        <td><code>this.router.navigate(['/cerca'])</code></td>
      </tr>
      <tr>
        <td><strong>ActivatedRoute</strong></td>
        <td>Servei</td>
        <td>Llegeix paràmetres de la ruta activa</td>
        <td><code>this.route.params.subscribe(...)</code></td>
      </tr>
    </tbody>
  </table>

  <h4>1.2.5. Casos d'ús reals del sistema de rutes</h4>
  <p><strong>1. E-commerce (Amazon, eBay):</strong></p>
{% capture code_6 %}/                           → Pàgina d'inici
/categories/electronics     → Categoria específica
/producte/B08N5WRWNW        → Detall producte
/carret                     → Cistella de compra
/checkout                   → Finalitzar compra
/comandes                   → Historial de comandes
/comanda/12345              → Detall d'una comanda{% endcapture %}
{% include code-block.html lang="text" code=code_6 %}

  <p><strong>2. Xarxa social (Twitter, Facebook):</strong></p>
{% capture code_7 %}/feed                       → Timeline principal
/perfil/usuari123           → Perfil d'usuari
/missatges                  → Xat privat
/missatges/conversa456      → Conversa específica
/notificacions              → Notificacions
/configuracio               → Configuració del compte{% endcapture %}
{% include code-block.html lang="text" code=code_7 %}

  <p><strong>3. Aplicació de gestió (Trello, Asana):</strong></p>
{% capture code_8 %}/dashboard                  → Panell principal
/projectes                  → Llistat de projectes
/projecte/789               → Vista d'un projecte
/projecte/789/tasques       → Tasques del projecte
/projecte/789/equip         → Equip del projecte
/calendari                  → Vista de calendari
/configuracio               → Configuració global{% endcapture %}
{% include code-block.html lang="text" code=code_8 %}

  <h4>1.2.6. Càlculs quantitatius: Impacte en experiència d'usuari</h4>
  <p><strong>Temps de navegació comparatiu:</strong></p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Acció</th>
        <th>Pàgines tradicionals</th>
        <th>SPA sense rutes</th>
        <th>SPA amb rutes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Càrrega inicial</strong></td>
        <td>2.5s</td>
        <td>2.5s</td>
        <td>0.8s</td>
      </tr>
      <tr>
        <td><strong>Primer canvi vista</strong></td>
        <td>2.0s (recàrrega HTML)</td>
        <td>0ms (ja carregat)</td>
        <td>75ms (carrega component)</td>
      </tr>
      <tr>
        <td><strong>Segon canvi vista</strong></td>
        <td>2.0s (recàrrega HTML)</td>
        <td>0ms (ja carregat)</td>
        <td>50ms (component en cache)</td>
      </tr>
      <tr>
        <td><strong>Tercer canvi vista</strong></td>
        <td>2.0s (recàrrega HTML)</td>
        <td>0ms (ja carregat)</td>
        <td>50ms (component en cache)</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Experiència acumulada en sessió de 10 minuts:</strong></p>
  <p>Usuari típic: 1 càrrega inicial + 15 navegacions</p>
  <ul>
    <li><strong>Pàgines tradicionals:</strong> 2.5s + (15 × 2.0s) = 32.5 segons esperant</li>
    <li><strong>SPA sense rutes:</strong> 2.5s + 0s = 2.5 segons esperant</li>
    <li><strong>SPA amb rutes:</strong> 0.8s + (15 × 0.06s) = 1.7 segons esperant</li>
  </ul>
  <p><strong>Millora:</strong> SPA amb rutes és <strong>19x més ràpid</strong> que pàgines tradicionals i <strong>1.5x més ràpid</strong> que SPA sense rutes (per la càrrega inicial reduïda).</p>

  <h4>1.2.7. Integració amb altres conceptes Angular</h4>
  <p>El sistema de rutes no treballa sol, sinó que s'integra amb altres conceptes d'Angular:</p>
  <p><strong>1. Serveis compartits:</strong></p>
{% capture code_9 %}@Injectable({ providedIn: 'root' })
export class ElementService {
  private elements = signal<ElementCataleg[]>([]);
  // Components de diferents rutes poden compartir aquestes dades
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_9 %}

  <p><strong>2. Guards (lectures posteriors):</strong></p>
{% capture code_10 %}{
  path: 'admin',
  component: AdminComponent,
  canActivate: [AuthGuard]  // Només usuaris autenticats
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_10 %}

  <p><strong>3. Lazy loading (lectures posteriors):</strong></p>
{% capture code_11 %}{
  path: 'estadistiques',
  loadComponent: () => import('./estadistiques.component')
    .then(m => m.EstadistiquesComponent)
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_11 %}

  <p><strong>4. Resolvers (lectures posteriors):</strong></p>
{% capture code_12 %}{
  path: 'detall/:id',
  component: DetallComponent,
  resolve: { element: ElementResolver }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_12 %}

  <h4>1.2.8. Analogia del món real: Sistema de transport públic</h4>
  <p>Penseu en el Router com un <strong>sistema de metro</strong> d'una ciutat:</p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Element Router</th>
        <th>Analogia Metro</th>
        <th>Explicació</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Routes array</strong></td>
        <td>Mapa de línies</td>
        <td>Defineix quines estacions (vistes) existeixen</td>
      </tr>
      <tr>
        <td><strong>URL</strong></td>
        <td>Nom de l'estació</td>
        <td>Indica on sou (<code>/cataleg</code> = "Estació Catàleg")</td>
      </tr>
      <tr>
        <td><strong>router-outlet</strong></td>
        <td>Andana</td>
        <td>Lloc on arriba el tren (component)</td>
      </tr>
      <tr>
        <td><strong>routerLink</strong></td>
        <td>Màquina de bitllets</td>
        <td>Compreu bitllet per anar a una estació</td>
      </tr>
      <tr>
        <td><strong>Component actiu</strong></td>
        <td>Tren a l'andana</td>
        <td>El que veieu actualment</td>
      </tr>
      <tr>
        <td><strong>Navegació</strong></td>
        <td>Viatge</td>
        <td>Canvieu d'estació (vista)</td>
      </tr>
      <tr>
        <td><strong>Historial navegador</strong></td>
        <td>Trajecte fet</td>
        <td>Recordeu per on heu passat (botó enrere)</td>
      </tr>
    </tbody>
  </table>

  <p>Quan feu clic a "Preferits":</p>
  <ol>
    <li>Compreu bitllet per "Estació Preferits" (routerLink)</li>
    <li>El sistema consulta el mapa (Routes array)</li>
    <li>Trobeu l'andana correcta (router-outlet)</li>
    <li>Arriba el tren "Preferits" (PreferitsComponent es renderitza)</li>
    <li>El tren anterior ("Catàleg") marxa (CatalegComponent es destrueix)</li>
  </ol>

  {% endcapture %}
  {% include section-point.html numero="1.2" titol="Marc conceptual" contingut=section_point_1_2 %}

  {% capture section_point_1_3 %}
  <h4>1.3.1. Imatge conceptual del sistema de rutes</h4>
  <p>Penseu en l'aplicació Angular com un <strong>edifici de múltiples habitacions</strong> on el Router actua com a <strong>recepcionista</strong>:</p>
{% capture code_13 %}┌──────────────────────────────────────────────────────────┐
│            APP COMPONENT (Edifici)                       │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │         MENÚ DE NAVEGACIÓ                      │    │
│  │  [Catàleg] [Cerca] [Preferits] [Admin]        │    │
│  │    (Botons de l'ascensor)                      │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │      <router-outlet>                            │    │
│  │  (Porta que mostra l'habitació actual)         │    │
│  │                                                  │    │
│  │  ┌──────────────────────────────────────┐     │    │
│  │  │  COMPONENT ACTIU                     │     │    │
│  │  │  (Habitació on sou ara)              │     │    │
│  │  │                                       │     │    │
│  │  │  [CatalegPageComponent]       o      │     │    │
│  │  │  [FormulariCercaComponent]    o      │     │    │
│  │  │  [PreferitsPanelComponent]    o      │     │    │
│  │  │  [DetallElementComponent]            │     │    │
│  │  │                                       │     │    │
│  │  └──────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  ROUTER (Recepcionista)                                 │
│  - Consulta mapa de rutes (Routes[])                    │
│  - Troba l'habitació (component) corresponent           │
│  - Obre la porta (router-outlet)                        │
└──────────────────────────────────────────────────────────┘{% endcapture %}
{% include code-block.html lang="text" code=code_13 %}

  <h4>1.3.2. Els 3 elements fonamentals</h4>
  <p><strong>1. Mapa de rutes (Routes[])</strong></p>
  <ul>
    <li><strong>Què és:</strong> Array TypeScript que relaciona URLs amb components</li>
    <li><strong>Analogia:</strong> Directori de l'edifici que indica a quina habitació correspon cada número de porta</li>
    <li><strong>Funció:</strong> Quan un usuari navega a <code>/cataleg</code>, el Router consulta aquest mapa i descobreix que ha de carregar <code>CatalegPageComponent</code></li>
  </ul>
{% capture code_14 %}const routes: Routes = [
  { path: 'cataleg', component: CatalegPageComponent },    // Habitació 1
  { path: 'cerca', component: FormulariCercaComponent },   // Habitació 2
  { path: 'preferits', component: PreferitsPanelComponent } // Habitació 3
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_14 %}

  <p><strong>Funcionament intern:</strong></p>
{% capture code_15 %}Usuari clica "Preferits"
  ↓
URL canvia a /preferits
  ↓
Router busca al mapa: path === 'preferits'
  ↓
Troba: { path: 'preferits', component: PreferitsPanelComponent }
  ↓
Carrega PreferitsPanelComponent al router-outlet{% endcapture %}
{% include code-block.html lang="text" code=code_15 %}

  <p><strong>2. Router Outlet (<code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>)</strong></p>
  <ul>
    <li><strong>Què és:</strong> Directiva que marca el lloc exacte on es renderitza el component de la ruta activa</li>
    <li><strong>Analogia:</strong> La porta d'entrada a l'habitació corresponent</li>
    <li><strong>Funció:</strong> Quan canvieu de ruta, l'outlet "esborra" el component anterior i "dibuxa" el nou al mateix lloc</li>
  </ul>
{% capture code_16 %}<main>
  <router-outlet></router-outlet>
  <!-- Aquí apareix: CatalegPageComponent, CercaComponent, etc. segons la ruta -->
</main>{% endcapture %}
{% include code-block.html lang="html" code=code_16 %}

  <p><strong>Cicle de vida:</strong></p>
{% capture code_17 %}Component anterior renderitzat al outlet
  ↓
Navegació a nova ruta
  ↓
Angular crida ngOnDestroy() del component anterior
  ↓
Component anterior desapareix del DOM
  ↓
Angular crea instància del nou component
  ↓
Angular crida ngOnInit() del nou component
  ↓
Nou component es renderitza al outlet{% endcapture %}
{% include code-block.html lang="text" code=code_17 %}

  <p><strong>3. Router Links (<code>routerLink</code>)</strong></p>
  <ul>
    <li><strong>Què és:</strong> Directiva per crear enllaços de navegació interna</li>
    <li><strong>Analogia:</strong> Botons de l'ascensor que us porten a cada pis</li>
    <li><strong>Funció:</strong> Quan feu clic, actualitza la URL i l'outlet canvia el component automàticament</li>
  </ul>
{% capture code_18 %}<a routerLink="/cataleg">Catàleg</a>
<!-- Clic → URL canvia a /cataleg → Outlet mostra CatalegComponent -->{% endcapture %}
{% include code-block.html lang="html" code=code_18 %}

  <p><strong>Per què routerLink i no href?</strong></p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Atribut</th>
        <th>Comportament</th>
        <th>Velocitat</th>
        <th>Historial</th>
        <th>Ús recomanat</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>href="/cataleg"</code></td>
        <td>Recàrrega completa de la pàgina</td>
        <td>2-3 segons</td>
        <td>Perd l'estat</td>
        <td>Pàgines tradicionals</td>
      </tr>
      <tr>
        <td><code>routerLink="/cataleg"</code></td>
        <td>Canvi de component al DOM</td>
        <td>50-100ms</td>
        <td>Manté l'estat</td>
        <td><i class="bi bi-check-circle text-success"></i> SPAs amb Angular</td>
      </tr>
    </tbody>
  </table>

  <h4>1.3.3. Flux complet de navegació pas a pas</h4>
  <p>Quan l'usuari fa clic a "Preferits", aquest és el procés complet:</p>
{% capture code_19 %}1. Event de clic detectat
   <a routerLink="/preferits" (click)="...">
   ↓
2. routerLink intercepta el clic
   event.preventDefault() → evita recàrrega de pàgina
   ↓
3. Router actualitza la URL del navegador
   window.history.pushState({}, '', '/preferits')
   cataleg-app.com/preferits
   ↓
4. Router consulta el mapa de rutes
   routes.find(r => r.path === 'preferits')
   ↓
5. Router troba el component associat
   { path: 'preferits', component: PreferitsPanelComponent }
   ↓
6. Router destrueix el component anterior
   ngOnDestroy() de CatalegPageComponent
   ↓
7. Router crea instància del nou component
   new PreferitsPanelComponent()
   ↓
8. Router inicialitza el component
   ngOnInit() de PreferitsPanelComponent
   ↓
9. Router renderitza al router-outlet
   <app-preferits-panel></app-preferits-panel>
   ↓
10. Usuari veu la nova vista
    SENSE recàrrega de pàgina!{% endcapture %}
{% include code-block.html lang="text" code=code_19 %}

  <p><strong>Temps total:</strong> 50-100 milisegons (imperceptible per l'usuari)</p>

  <h4>1.3.4. Model mental clau: Un sol HTML, components intercanviables</h4>
  <p>La clau per comprendre el Router:</p>
  {% include warning_box.html contingut="<strong>MALAMENT (model mental incorrecte):</strong><br>\"Cada ruta és una pàgina HTML diferent\"" %}
  {% include success_box.html contingut="<strong>CORRECTE (model mental correcte):</strong><br>\"Hi ha UN SOL index.html que carrega TOTS els components, però el router-outlet només en mostra un alhora\"" %}

  <p>Aquesta comprensió és fonamental per entendre:</p>
  <ul>
    <li>Per què és tan ràpid (no descarrega res nou)</li>
    <li>Per què funciona offline (tot ja està al navegador)</li>
    <li>Per què es pot compartir estat entre rutes (mateix context d'execució)</li>
    <li>Per què lazy loading millora el rendiment (retarda càrrega de components no essencials)</li>
  </ul>

  {% endcapture %}
  {% include section-point.html numero="1.3" titol="Model mental" contingut=section_point_1_3 %}

  {% capture section_point_1_4 %}
  <p><strong>Objectiu:</strong> Comprendre el concepte de Single Page Application (SPA) i com el sistema de rutes permet gestionar múltiples vistes sense recarregar la pàgina.</p>

  <h4>1.4.1. Definició de Single Page Application</h4>
  <p>Una <strong>Single Page Application (SPA)</strong> és una aplicació web que carrega un únic document HTML i actualitza dinàmicament el contingut sense recarregar la pàgina sencera. Tota la lògica de navegació i renderitzat s'executa al navegador mitjançant JavaScript.</p>

  <p><strong>Diferència fonamental:</strong></p>
{% capture code_20 %}Aplicació tradicional (Multi-Page):
  Inici (index.html) → Clic "Cerca" → Servidor retorna cerca.html → Recàrrega completa

SPA (Single-Page):
  Inici (index.html carregat UNA vegada) → Clic "Cerca" → JavaScript canvia el contingut del DOM{% endcapture %}
{% include code-block.html lang="text" code=code_20 %}

  <h4>1.4.2. Per què Angular és una SPA</h4>
  <p>Quan executeu <code>ng serve</code> i obriu <code>http://localhost:4200</code>, el navegador descarrega:</p>
  <ol>
    <li><strong>index.html</strong> (estructura bàsica)</li>
    <li><strong>main.js</strong> (tot el codi TypeScript compilat)</li>
    <li><strong>styles.css</strong> (tots els estils)</li>
  </ol>
  <p>A partir d'aquí, <strong>NO hi ha més descàrregues d'HTML</strong>. Tota la navegació es gestiona manipulant el DOM amb JavaScript.</p>

  <h4>1.4.3. El repte: Com gestionar múltiples vistes</h4>
  <p>Si només teniu un <code>index.html</code>, com mostreu diferents pantalles (catàleg, cerca, preferits)?</p>

  <p><strong>Solució 1 (manual i dolenta):</strong></p>
{% capture code_21 %}// Mostrar/ocultar components amb *ngIf
<app-cataleg *ngIf="vistaActual === 'cataleg'"></app-cataleg>
<app-cerca *ngIf="vistaActual === 'cerca'"></app-cerca>{% endcapture %}
{% include code-block.html lang="typescript" code=code_21 %}

  <p><strong>Problemes:</strong> URLs no canvien, no funciona botó enrere, no es pot compartir enllaços.</p>

  <p><strong>Solució 2 (Router Angular - correcta):</strong></p>
{% capture code_22 %}// Sistema de rutes que mapeja URLs a components
const routes: Routes = [
  { path: 'cataleg', component: CatalegComponent },
  { path: 'cerca', component: CercaComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_22 %}

  <p><strong>Avantatges:</strong> URLs úniques, historial del navegador, enllaços compartibles.</p>

  <h4>1.4.4. Què fa exactament el sistema de rutes</h4>
  <p>El Router d'Angular:</p>
  <ol>
    <li><strong>Escolta canvis a la URL:</strong> Quan l'usuari clica un enllaç o el botó enrere</li>
    <li><strong>Consulta el mapa de rutes:</strong> Troba quin component correspon a la nova URL</li>
    <li><strong>Actualitza el DOM:</strong> Destrueix el component anterior i renderitza el nou</li>
    <li><strong>Manté l'historial:</strong> Registra la navegació perquè funcionin els botons enrere/endavant</li>
  </ol>

  <p><strong>Exemple visual:</strong></p>
{% capture code_23 %}URL: /cataleg
  ↓ [Router consulta mapa]
Component: CatalegPageComponent
  ↓ [Router renderitza]
DOM: <app-cataleg-page></app-cataleg-page>

Usuari clica "Preferits"
  ↓
URL: /preferits
  ↓ [Router consulta mapa]
Component: PreferitsPanelComponent
  ↓ [Router destrueix anterior i renderitza nou]
DOM: <app-preferits-panel></app-preferits-panel>{% endcapture %}
{% include code-block.html lang="text" code=code_23 %}

  {% include info_box.html contingut="<strong>Clau:</strong> Tot això passa sense recarregar index.html. El Router només canvia una petita part del DOM (el contingut del <code>&lt;router-outlet&gt;</code>)." %}

  <p><strong>Resultat:</strong> Compreniu que una SPA amb sistema de rutes permet tenir múltiples vistes amb URLs úniques sense recarregar la pàgina, oferint una experiència d'usuari fluida i ràpida similar a aplicacions natives.</p>

  {% endcapture %}
  {% include section-point.html numero="1.4" titol="Què és el sistema de rutes: gestionar múltiples vistes en una aplicació d'una sola pàgina (SPA)" contingut=section_point_1_4 %}

  {% capture section_point_1_5 %}
  <p><strong>Objectiu:</strong> Identificar els beneficis concrets i mesurables del sistema de rutes per a desenvolupadors i usuaris.</p>

  <h4>1.5.1. Avantatge 1: Organització del codi</h4>
  <p><strong>Sense rutes:</strong> Tot el codi viu en un sol component gegant:</p>
{% capture code_24 %}// app.component.ts - 800+ línies
export class AppComponent {
  vistaActual = 'cataleg';

  // Mètodes del catàleg (200 línies)
  obtenirElements() { /* ... */ }
  filtrarElements() { /* ... */ }

  // Mètodes de cerca (150 línies)
  cercar() { /* ... */ }
  aplicarFiltres() { /* ... */ }

  // Mètodes de preferits (200 línies)
  afegirPreferit() { /* ... */ }
  eliminarPreferit() { /* ... */ }

  // ... 250 línies més
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_24 %}

  <p><strong>Amb rutes:</strong> Cada funcionalitat en el seu propi fitxer:</p>
{% capture code_25 %}src/app/
├── pages/
│   ├── cataleg-page/
│   │   ├── cataleg-page.component.ts      (200 línies)
│   │   ├── cataleg-page.component.html    (50 línies)
│   │   └── cataleg-page.component.scss    (30 línies)
│   ├── cerca-page/
│   │   └── ... (150 línies totals)
│   └── preferits-page/
│       └── ... (200 línies totals)
└── app.component.ts                        (20 línies - només navegació){% endcapture %}
{% include code-block.html lang="text" code=code_25 %}

  <p><strong>Beneficis mesurables:</strong></p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Aspecte</th>
        <th>Sense rutes</th>
        <th>Amb rutes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Línies per fitxer</td>
        <td>800+</td>
        <td>100-200</td>
      </tr>
      <tr>
        <td>Temps per trobar codi</td>
        <td>5-10 min</td>
        <td>30 seg</td>
      </tr>
      <tr>
        <td>Risc de conflictes Git</td>
        <td>Alt</td>
        <td>Baix</td>
      </tr>
      <tr>
        <td>Facilitat de proves</td>
        <td>Difícil</td>
        <td>Fàcil</td>
      </tr>
    </tbody>
  </table>

  <h4>1.5.2. Avantatge 2: URLs llegibles i semàntiques</h4>
  <p><strong>URLs tradicionals (inútils):</strong></p>
{% capture code_26 %}https://cataleg-app.com/index.html
https://cataleg-app.com/index.html?page=cerca
https://cataleg-app.com/index.html?page=preferits&id=123{% endcapture %}
{% include code-block.html lang="text" code=code_26 %}

  <p><strong>URLs amb rutes (significatives):</strong></p>
{% capture code_27 %}https://cataleg-app.com/cataleg
https://cataleg-app.com/cerca
https://cataleg-app.com/preferits
https://cataleg-app.com/detall/elem-001{% endcapture %}
{% include code-block.html lang="text" code=code_27 %}

  <p><strong>Per què importa:</strong></p>
  <ol>
    <li><strong>Comprensibilitat:</strong> Un usuari pot endevinar què veurà abans de clicar</li>
    <li><strong>Compartició:</strong> <code>cataleg-app.com/detall/elem-001</code> és compartible, <code>index.html?page=detall&id=123</code> no ho és tant</li>
    <li><strong>SEO:</strong> Google indexa millor URLs semàntiques</li>
    <li><strong>Analytics:</strong> Més fàcil analitzar quines pàgines són més visitades</li>
  </ol>

  <h4>1.5.3. Avantatge 3: Navegabilitat millorada</h4>
  <p><strong>Funcionalitats del navegador que funcionen:</strong></p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Funcionalitat</th>
        <th>Sense rutes</th>
        <th>Amb rutes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Botó "Enrere"</td>
        <td><i class="bi bi-x-circle text-danger"></i> No funciona</td>
        <td><i class="bi bi-check-circle text-success"></i> Torna a la vista anterior</td>
      </tr>
      <tr>
        <td>Botó "Endavant"</td>
        <td><i class="bi bi-x-circle text-danger"></i> No funciona</td>
        <td><i class="bi bi-check-circle text-success"></i> Avança a la vista següent</td>
      </tr>
      <tr>
        <td>Marcadors</td>
        <td><i class="bi bi-x-circle text-danger"></i> Sempre apunta a inici</td>
        <td><i class="bi bi-check-circle text-success"></i> Desa vista específica</td>
      </tr>
      <tr>
        <td>Historial</td>
        <td><i class="bi bi-x-circle text-danger"></i> Buit</td>
        <td><i class="bi bi-check-circle text-success"></i> Registra cada navegació</td>
      </tr>
      <tr>
        <td>F5 (recarregar)</td>
        <td><i class="bi bi-x-circle text-danger"></i> Torna a inici</td>
        <td><i class="bi bi-check-circle text-success"></i> Manté vista actual</td>
      </tr>
      <tr>
        <td>Copiar enllaç</td>
        <td><i class="bi bi-x-circle text-danger"></i> URL genèrica</td>
        <td><i class="bi bi-check-circle text-success"></i> URL específica</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Escenari real:</strong> Usuari navega: Inici → Catàleg → Detall elem-001 → Preferits → Detall elem-002</p>

  <p><strong>Sense rutes:</strong></p>
{% capture code_28 %}Historial del navegador: [cataleg-app.com/]
Clic "Enrere": No passa res{% endcapture %}
{% include code-block.html lang="text" code=code_28 %}

  <p><strong>Amb rutes:</strong></p>
{% capture code_29 %}Historial del navegador:
  [/] → [/cataleg] → [/detall/elem-001] → [/preferits] → [/detall/elem-002]

Clic "Enrere": Torna a /preferits
Clic "Enrere": Torna a /detall/elem-001
Clic "Endavant": Avança a /preferits{% endcapture %}
{% include code-block.html lang="text" code=code_29 %}

  <h4>1.5.4. Avantatge 4: Escalabilitat del projecte</h4>
  <p>Quan l'aplicació creix de 3 vistes a 20 vistes:</p>

  <p><strong>Amb rutes:</strong></p>
{% capture code_30 %}// app.routes.ts - escalabilitat fàcil
export const routes: Routes = [
  { path: 'cataleg', component: CatalegComponent },
  { path: 'cerca', component: CercaComponent },
  { path: 'preferits', component: PreferitsComponent },
  { path: 'admin', loadComponent: () => import('./admin.component') },
  // ... afegir rutes noves és trivial
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_30 %}

  <p><strong>Beneficis:</strong></p>
  <ul>
    <li>Només carrega el component necessari</li>
    <li>Lazy loading per components pesats</li>
    <li>Fàcil afegir noves rutes sense tocar codi existent</li>
  </ul>

  {% include success_box.html contingut="<strong>Clau:</strong> El sistema de rutes facilita organització del codi, millora URLs per SEO i compartició, restaura funcionalitats esperades del navegador, coherentitza UX i permet escalar l'aplicació sense problemes de rendiment." %}

  <p><strong>Resultat:</strong> Identifiqueu que les rutes no són opcionals en aplicacions modernes, sinó essencials per crear experiències d'usuari professionals i codis mantenibles.</p>

  {% endcapture %}
  {% include section-point.html numero="1.5" titol="Avantatges de les rutes: organització, URLs llegibles, navegabilitat" contingut=section_point_1_5 %}

  {% capture section_point_1_6 %}
  <p><strong>Objectiu:</strong> Configurar Angular per utilitzar el sistema de rutes a nivell d'aplicació.</p>

  <h4>1.6.1. Configuració a aplicacions standalone (Angular 18+)</h4>
  <p>Angular 18 utilitza <strong>standalone components</strong> per defecte. La configuració de rutes es fa mitjançant <code>provideRouter()</code> en lloc de <code>RouterModule.forRoot()</code>.</p>

  <p><strong>Fitxer clau:</strong> <code>src/main.ts</code></p>
  <p>Aquest fitxer és el punt d'entrada de l'aplicació. Aquí configurem tots els proveïdors globals, incloent-hi el Router.</p>

  <p><strong>Estat inicial (sense rutes):</strong></p>
{% capture code_31 %}// src/main.ts - Aplicació sense rutes
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, {
  providers: []
}).catch(err => console.error(err));{% endcapture %}
{% include code-block.html lang="typescript" code=code_31 %}

  <p><strong>Estat final (amb rutes configurades):</strong></p>
{% capture code_32 %}// src/main.ts - Aplicació amb rutes
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes)  // ← Configura el Router amb les nostres rutes
  ]
}).catch(err => console.error(err));{% endcapture %}
{% include code-block.html lang="typescript" code=code_32 %}

  <h4>1.6.2. Què fa provideRouter()</h4>
  <p>La funció <code>provideRouter()</code>:</p>
  <ol>
    <li><strong>Registra el servei Router:</strong> El fa disponible per injecció de dependències a tota l'aplicació</li>
    <li><strong>Configura les directives:</strong> <code>routerLink</code>, <code>routerLinkActive</code>, <code>router-outlet</code> queden disponibles</li>
    <li><strong>Inicialitza l'historial del navegador:</strong> Connecta amb la History API del navegador</li>
    <li><strong>Carrega la ruta inicial:</strong> Analitza la URL actual i carrega el component corresponent</li>
  </ol>

  <p><strong>Seqüència d'inicialització:</strong></p>
{% capture code_33 %}1. Navegador carrega index.html
   ↓
2. Navegador executa main.ts
   ↓
3. bootstrapApplication() s'executa
   ↓
4. provideRouter(routes) configura el Router
   ↓
5. AppComponent es renderitza
   ↓
6. Router llegeix URL actual (ex: /cataleg)
   ↓
7. Router carrega CatalegComponent al router-outlet
   ↓
8. Aplicació completament inicialitzada{% endcapture %}
{% include code-block.html lang="text" code=code_33 %}

  <h4>1.6.3. Verificació de la configuració</h4>
  <p><strong>Pas 1:</strong> Obriu <code>src/main.ts</code> i verifiqueu que <code>provideRouter(routes)</code> està present.</p>

  <p><strong>Pas 2:</strong> Executeu el linter per detectar errors:</p>
{% capture code_34 %}npm run lint{% endcapture %}
{% include code-block.html lang="bash" code=code_34 %}

  <p><strong>Pas 3:</strong> Inicieu el servidor de desenvolupament:</p>
{% capture code_35 %}ng serve{% endcapture %}
{% include code-block.html lang="bash" code=code_35 %}

  <p><strong>Pas 4:</strong> Obriu la consola del navegador (F12) i comproveu que no hi ha errors relacionats amb el Router.</p>

  <p><strong>Indicadors d'èxit:</strong></p>
  <ul>
    <li><i class="bi bi-check-circle text-success"></i> No hi ha errors de compilació</li>
    <li><i class="bi bi-check-circle text-success"></i> L'aplicació arrenca sense errors a la consola</li>
    <li><i class="bi bi-check-circle text-success"></i> Podeu veure "Angular is running in development mode"</li>
    <li><i class="bi bi-check-circle text-success"></i> NO veieu errors "Router configuration is missing"</li>
  </ul>

  <h4>1.6.4. Errors comuns en aquesta fase</h4>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Error</th>
        <th>Causa</th>
        <th>Solució</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Router configuration is missing</code></td>
        <td><code>provideRouter()</code> no cridat</td>
        <td>Afegir <code>provideRouter(routes)</code> a main.ts</td>
      </tr>
      <tr>
        <td><code>Cannot find name 'routes'</code></td>
        <td>Import de routes oblidat</td>
        <td><code>import { routes } from './app/app.routes'</code></td>
      </tr>
      <tr>
        <td><code>provideRouter is not a function</code></td>
        <td>Import incorrecte</td>
        <td><code>import { provideRouter } from '@angular/router'</code></td>
      </tr>
    </tbody>
  </table>

  {% include success_box.html contingut="<strong>Clau:</strong> <code>provideRouter(routes)</code> a <code>main.ts</code> és l'única configuració necessària per habilitar el sistema de rutes a Angular 18+." %}

  <p><strong>Resultat:</strong> Teniu el Router configurat globalment a l'aplicació i esteu preparats per definir rutes específiques.</p>

  {% endcapture %}
  {% include section-point.html numero="1.6" titol="Importar mòdul de rutes: configuració inicial del projecte" contingut=section_point_1_6 %}

  {% capture section_point_1_7 %}
  <p><strong>Objectiu:</strong> Crear el fitxer de definició de rutes i comprendre l'estructura de l'array <code>Routes</code>.</p>

  <h4>1.7.1. Ubicació estàndard del fitxer de rutes</h4>
  <p>Per convenció, el fitxer de rutes principal es col·loca a:</p>
{% capture code_36 %}src/app/app.routes.ts{% endcapture %}
{% include code-block.html lang="text" code=code_36 %}

  <p>Aquest nom i ubicació són estàndard en aplicacions Angular 18+. Versions anteriors utilitzaven <code>app-routing.module.ts</code>.</p>

  <h4>1.7.2. Crear el fitxer de rutes</h4>
  <p><strong>PowerShell (Windows):</strong></p>
{% capture code_37 %}Set-Location $env:USERPROFILE\workspace\catalog-elements
New-Item -Path "src\app\app.routes.ts" -ItemType File
code src\app\app.routes.ts{% endcapture %}
{% include code-block.html lang="powershell" code=code_37 %}

  <p><strong>bash/zsh (macOS/Linux):</strong></p>
{% capture code_38 %}cd ~/workspace/catalog-elements
touch src/app/app.routes.ts
code src/app/app.routes.ts{% endcapture %}
{% include code-block.html lang="bash" code=code_38 %}

  <h4>1.7.3. Estructura mínima del fitxer</h4>
{% capture code_39 %}// src/app/app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [];{% endcapture %}
{% include code-block.html lang="typescript" code=code_39 %}

  <p><strong>Explicació:</strong></p>
  <ul>
    <li><code>import { Routes }</code>: Importa el tipus TypeScript per definir rutes</li>
    <li><code>export const routes</code>: Exporta l'array perquè <code>main.ts</code> el pugui importar</li>
    <li><code>: Routes</code>: Tipus TypeScript que assegura que l'array té l'estructura correcta</li>
    <li><code>= []</code>: Array buit inicialment (afegirem rutes a la següent secció)</li>
  </ul>

  <h4>1.7.4. Anatomia d'una ruta completa</h4>
  <p>Cada objecte de l'array <code>Routes</code> representa una ruta individual:</p>
{% capture code_40 %}{
  path: 'cataleg',                    // URL (sense /)
  component: CatalegPageComponent,    // Component a renderitzar
  title: 'Catàleg d\'elements',       // Títol de la pestanya del navegador
  data: { breadcrumb: 'Catàleg' },    // Dades personalitzades (opcional)
  canActivate: [AuthGuard]            // Guards de protecció (opcional)
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_40 %}

  <p><strong>Propietats principals:</strong></p>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Propietat</th>
        <th>Tipus</th>
        <th>Obligatòria</th>
        <th>Funció</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>path</code></td>
        <td>string</td>
        <td><i class="bi bi-check-circle text-success"></i> Sí</td>
        <td>URL que activa aquesta ruta (sense <code>/</code> inicial)</td>
      </tr>
      <tr>
        <td><code>component</code></td>
        <td>Component</td>
        <td><i class="bi bi-exclamation-circle text-warning"></i> Sí*</td>
        <td>Component a renderitzar</td>
      </tr>
      <tr>
        <td><code>loadComponent</code></td>
        <td>Function</td>
        <td><i class="bi bi-exclamation-circle text-warning"></i> Sí*</td>
        <td>Carrega component amb lazy loading</td>
      </tr>
      <tr>
        <td><code>title</code></td>
        <td>string</td>
        <td><i class="bi bi-x-circle text-danger"></i> No</td>
        <td>Títol de la pestanya del navegador</td>
      </tr>
      <tr>
        <td><code>redirectTo</code></td>
        <td>string</td>
        <td><i class="bi bi-x-circle text-danger"></i> No</td>
        <td>Redirigeix a una altra ruta</td>
      </tr>
      <tr>
        <td><code>pathMatch</code></td>
        <td>'full' | 'prefix'</td>
        <td><i class="bi bi-x-circle text-danger"></i> No</td>
        <td>Com coincideix el path</td>
      </tr>
      <tr>
        <td><code>children</code></td>
        <td>Routes[]</td>
        <td><i class="bi bi-x-circle text-danger"></i> No</td>
        <td>Rutes niades (lectures posteriors)</td>
      </tr>
      <tr>
        <td><code>canActivate</code></td>
        <td>Guard[]</td>
        <td><i class="bi bi-x-circle text-danger"></i> No</td>
        <td>Guards que protegeixen l'accés</td>
      </tr>
    </tbody>
  </table>
  <p><em>*Nota: Cal <code>component</code> o <code>loadComponent</code>, però no ambdós alhora.</em></p>

  <h4>1.7.5. Tipus de rutes bàsiques</h4>
  <p><strong>1. Ruta normal (amb component):</strong></p>
{% capture code_41 %}{ path: 'cataleg', component: CatalegPageComponent }{% endcapture %}
{% include code-block.html lang="typescript" code=code_41 %}
  <p>Quan l'usuari navega a <code>/cataleg</code>, es renderitza <code>CatalegPageComponent</code>.</p>

  <p><strong>2. Ruta de redirecció:</strong></p>
{% capture code_42 %}{ path: '', redirectTo: 'cataleg', pathMatch: 'full' }{% endcapture %}
{% include code-block.html lang="typescript" code=code_42 %}
  <p>Quan l'usuari navega a <code>/</code> (arrel), es redirigeix automàticament a <code>/cataleg</code>.</p>
  {% include warning_box.html contingut="<strong>Atenció:</strong> Sempre cal <code>pathMatch: 'full'</code> amb <code>redirectTo</code> per evitar redireccions no desitjades." %}

  <p><strong>3. Ruta amb paràmetres (lectures posteriors):</strong></p>
{% capture code_43 %}{ path: 'detall/:id', component: DetallElementComponent }{% endcapture %}
{% include code-block.html lang="typescript" code=code_43 %}
  <p><code>:id</code> és un paràmetre variable. <code>/detall/elem-001</code> i <code>/detall/elem-002</code> utilitzen la mateixa ruta.</p>

  <p><strong>4. Ruta comodí (404):</strong></p>
{% capture code_44 %}{ path: '**', redirectTo: 'cataleg' }{% endcapture %}
{% include code-block.html lang="typescript" code=code_44 %}
  <p><code>**</code> coincideix amb qualsevol URL que no hagi coincidit abans. Sempre ha d'anar <strong>al final</strong> de l'array.</p>

  <h4>1.7.6. Ordre de les rutes: CRÍTIC</h4>
  <p>L'ordre de l'array <code>Routes</code> importa:</p>

  <p><strong>Exemple incorrecte:</strong></p>
{% capture code_45 %}// MALAMENT - El comodí està primer
export const routes: Routes = [
  { path: '**', redirectTo: 'cataleg' },  // Coincideix amb TOT
  { path: 'cerca', component: CercaComponent }  // Mai s'arribarà aquí!
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_45 %}

  <p><strong>Exemple correcte:</strong></p>
{% capture code_46 %}// CORRECTE - Rutes específiques primer, comodí al final
export const routes: Routes = [
  { path: 'cerca', component: CercaComponent },
  { path: '**', redirectTo: 'cataleg' }  // Només coincideix si res més ho fa
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_46 %}

  {% include info_box.html contingut="<strong>Regla d'or:</strong> Rutes més específiques primer, comodí sempre al final." %}

  <h4>1.7.7. Exemple complet del fitxer</h4>
{% capture code_47 %}// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { CatalegPageComponent } from './pages/cataleg-page/cataleg-page.component';
import { FormulariCercaComponent } from './components/formulari-cerca/formulari-cerca.component';
import { PreferitsPanelComponent } from './components/preferits-panel/preferits-panel.component';

export const routes: Routes = [
  // Redirecció de l'arrel
  { path: '', redirectTo: 'cataleg', pathMatch: 'full' },

  // Rutes principals
  { path: 'cataleg', component: CatalegPageComponent, title: 'Catàleg d\'elements' },
  { path: 'cerca', component: FormulariCercaComponent, title: 'Cerca d\'elements' },
  { path: 'preferits', component: PreferitsPanelComponent, title: 'Els meus preferits' },

  // Ruta comodí (404)
  { path: '**', redirectTo: 'cataleg' }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_47 %}

  {% include success_box.html contingut="<strong>Clau:</strong> L'arxiu <code>app.routes.ts</code> conté un array <code>Routes</code> que mapeja URLs a components. L'ordre de les rutes és crític: específiques primer, comodí al final." %}

  <p><strong>Resultat:</strong> Teniu un fitxer de rutes estructurat correctament i compreniu com definir rutes bàsiques amb redireccions.</p>

  {% endcapture %}
  {% include section-point.html numero="1.7" titol="Arxiu de rutes: on es defineixen, estructura bàsica" contingut=section_point_1_7 %}

  {% capture section_point_1_8 %}
  <p><strong>Objectiu:</strong> Crear la primera ruta funcional de l'aplicació (<code>/cataleg</code>) i comprendre la relació path-component.</p>

  <h4>1.8.1. Afegir imports necessaris</h4>
  <p>Abans de definir rutes, cal importar els components que utilitzarem:</p>
{% capture code_48 %}// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { CatalegPageComponent } from './pages/cataleg-page/cataleg-page.component';{% endcapture %}
{% include code-block.html lang="typescript" code=code_48 %}

  <p><strong>Ruta de l'import:</strong> L'import utilitza una ruta <strong>relativa</strong> des de <code>app.routes.ts</code>:</p>
{% capture code_49 %}app.routes.ts
└── app/
    └── pages/
        └── cataleg-page/
            └── cataleg-page.component.ts{% endcapture %}
{% include code-block.html lang="text" code=code_49 %}
  <p>Ruta relativa: <code>'./pages/cataleg-page/cataleg-page.component'</code></p>

  <h4>1.8.2. Definir la primera ruta</h4>
{% capture code_50 %}export const routes: Routes = [
  {
    path: 'cataleg',
    component: CatalegPageComponent,
    title: 'Catàleg d\'elements'
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_50 %}

  <p><strong>Anàlisi de cada propietat:</strong></p>

  <p><strong>1. <code>path: 'cataleg'</code></strong></p>
  <ul>
    <li>Defineix la URL que activa aquesta ruta</li>
    <li><strong>Sense <code>/</code> inicial:</strong> Escriviu <code>'cataleg'</code>, NO <code>'/cataleg'</code></li>
    <li>Quan l'usuari navega a <code>http://localhost:4200/cataleg</code>, aquesta ruta s'activa</li>
    <li>Pot contenir caràcters alfanumèrics i guions: <code>'cerca-avancada'</code>, <code>'elements-populars'</code></li>
  </ul>

  <p><strong>2. <code>component: CatalegPageComponent</code></strong></p>
  <ul>
    <li>Especifica quin component es renderitzarà al <code>&lt;router-outlet&gt;</code></li>
    <li>Cal que el component estigui importat al principi del fitxer</li>
    <li>El component ha de ser standalone (Angular 18+) o estar declarat en un mòdul</li>
  </ul>

  <p><strong>3. <code>title: 'Catàleg d\'elements'</code></strong></p>
  <ul>
    <li>Estableix el títol de la pestanya del navegador</li>
    <li>Es veu a la pestanya i a l'historial del navegador</li>
    <li>Millora l'experiència d'usuari i el SEO</li>
    <li>Opcional, però recomanat</li>
  </ul>

  <h4>1.8.3. Provar la ruta manualment</h4>
  <p><strong>Pas 1:</strong> Assegureu-vos que <code>ng serve</code> està actiu:</p>
{% capture code_51 %}ng serve{% endcapture %}
{% include code-block.html lang="bash" code=code_51 %}

  <p><strong>Pas 2:</strong> Obriu el navegador a:</p>
{% capture code_52 %}http://localhost:4200/cataleg{% endcapture %}
{% include code-block.html lang="text" code=code_52 %}

  <p><strong>Què hauria de passar:</strong></p>
  <ol>
    <li>La URL del navegador mostra <code>/cataleg</code></li>
    <li>El títol de la pestanya canvia a "Catàleg d'elements"</li>
    <li><code>CatalegPageComponent</code> es renderitza (veureu el contingut del catàleg)</li>
  </ol>

  <h4>1.8.4. Afegir redirecció de l'arrel</h4>
  <p>Normalment no voleu que <code>/</code> mostri una pàgina buida. Afegiu una redirecció:</p>
{% capture code_53 %}export const routes: Routes = [
  // Redirecció: / → /cataleg
  { path: '', redirectTo: 'cataleg', pathMatch: 'full' },

  // Ruta principal
  { path: 'cataleg', component: CatalegPageComponent, title: 'Catàleg d\'elements' }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_53 %}

  <p><strong>Explicació de <code>pathMatch: 'full'</code>:</strong></p>
  <ul>
    <li><code>'full'</code>: La URL ha de coincidir <strong>exactament</strong> amb <code>''</code> (arrel)</li>
    <li>Sense <code>pathMatch: 'full'</code>, qualsevol URL començaria per <code>''</code> i sempre redirigiria</li>
  </ul>

  {% include warning_box.html contingut="Sempre cal <code>pathMatch: 'full'</code> amb <code>redirectTo</code> per evitar redireccions no desitjades." %}

  <h4>1.8.5. Afegir més rutes</h4>
  <p>Seguint el mateix patró, afegiu les altres rutes:</p>
{% capture code_54 %}export const routes: Routes = [
  { path: '', redirectTo: 'cataleg', pathMatch: 'full' },
  { path: 'cataleg', component: CatalegPageComponent, title: 'Catàleg d\'elements' },
  { path: 'cerca', component: FormulariCercaComponent, title: 'Cerca d\'elements' },
  { path: 'preferits', component: PreferitsPanelComponent, title: 'Els meus preferits' }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_54 %}

  <h4>1.8.6. Errors comuns i solucions</h4>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Error</th>
        <th>Causa probable</th>
        <th>Solució</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Cannot match any routes for URL</code></td>
        <td>Path escrit malament</td>
        <td>Verificar <code>path: 'cataleg'</code> sense <code>/</code></td>
      </tr>
      <tr>
        <td><code>Component is not a function</code></td>
        <td>Import incorrecte del component</td>
        <td>Verificar ruta d'import i que el component existeix</td>
      </tr>
      <tr>
        <td>Redirecció infinita</td>
        <td><code>pathMatch</code> oblidat</td>
        <td>Afegir <code>pathMatch: 'full'</code> a redireccions</td>
      </tr>
      <tr>
        <td>Component no es renderitza</td>
        <td><code>router-outlet</code> absent</td>
        <td>Afegir <code>&lt;router-outlet&gt;</code> a AppComponent (pròxima secció)</td>
      </tr>
    </tbody>
  </table>

  {% include success_box.html contingut="<strong>Clau:</strong> Cada ruta mapeja un <code>path</code> (URL) a un <code>component</code> (vista). Les redireccions necessiten <code>pathMatch: 'full'</code> per funcionar correctament." %}

  <p><strong>Resultat:</strong> Teniu 3-4 rutes definides i compreniu com relacionar URLs amb components.</p>

  {% endcapture %}
  {% include section-point.html numero="1.8" titol="Definir primera ruta: path, component associat" contingut=section_point_1_8 %}

  {% capture section_point_1_9 %}
  <p><strong>Objectiu:</strong> Afegir la directiva <code>&lt;router-outlet&gt;</code> al component principal i comprendre com funciona el punt d'injecció de components.</p>

  <h4>1.9.1. Què és el router-outlet</h4>
  <p><code>&lt;router-outlet&gt;</code> és una <strong>directiva</strong> d'Angular que actua com a <strong>marcador de posició</strong> (placeholder) on es renderitzen els components de les rutes actives.</p>

  <p><strong>Analogia:</strong> És com un marc de quadre on el Router "penja" el component que correspon a la ruta actual.</p>
{% capture code_55 %}<div class="app">
  <nav>...</nav>

  <main>
    <router-outlet></router-outlet>
    <!-- ↑ Aquí "apareix" CatalegComponent, CercaComponent, etc. -->
  </main>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_55 %}

  <h4>1.9.2. Comportament dinàmic del router-outlet</h4>
  <p>Quan l'usuari navega entre rutes, el Router:</p>
  <ol>
    <li><strong>Destrueix</strong> el component anterior (crida <code>ngOnDestroy()</code>)</li>
    <li><strong>Neteja</strong> el contingut del <code>&lt;router-outlet&gt;</code></li>
    <li><strong>Crea</strong> instància del nou component</li>
    <li><strong>Renderitza</strong> el nou component dins del <code>&lt;router-outlet&gt;</code></li>
    <li><strong>Inicialitza</strong> el component (crida <code>ngOnInit()</code>)</li>
  </ol>

  <p><strong>Exemple visual:</strong></p>
{% capture code_56 %}Estat inicial (URL: /cataleg):
<router-outlet>
  <app-cataleg-page></app-cataleg-page>  ← Component actiu
</router-outlet>

Usuari clica "Cerca" → URL canvia a /cerca:
<router-outlet>
  <!-- CatalegPageComponent destruït -->
  <app-formulari-cerca></app-formulari-cerca>  ← Nou component
</router-outlet>{% endcapture %}
{% include code-block.html lang="text" code=code_56 %}

  <h4>1.9.3. Afegir router-outlet a AppComponent</h4>
  <p><strong>Pas 1:</strong> Obriu <code>src/app/app.component.ts</code></p>

  <p><strong>Pas 2:</strong> Importeu <code>RouterModule</code>:</p>
{% capture code_57 %}import { Component } from '@angular/core';
import { RouterModule } from '@angular/router';  // ← Afegir

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterModule],  // ← Afegir
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss'
})
export class AppComponent {}{% endcapture %}
{% include code-block.html lang="typescript" code=code_57 %}

  {% include info_box.html contingut="<strong>Per què cal importar RouterModule?</strong><br><code>RouterModule</code> proporciona les directives <code>router-outlet</code>, <code>routerLink</code> i <code>routerLinkActive</code>. Sense aquest import, Angular no reconeixerà aquestes directives." %}

  <p><strong>Pas 3:</strong> Actualitzeu la plantilla (<code>app.component.html</code>):</p>
{% capture code_58 %}<div class="app-container">
  <header>
    <h1>Catàleg d'Elements</h1>
  </header>

  <main>
    <router-outlet></router-outlet>
  </main>

  <footer>
    <p>&copy; 2025 Catàleg Elements</p>
  </footer>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_58 %}

  <p><strong>Estructura semàntica:</strong></p>
  <ul>
    <li><code>&lt;header&gt;</code>: Capçalera fixa de l'aplicació (sempre visible)</li>
    <li><code>&lt;main&gt;</code>: Contingut principal que canvia segons la ruta</li>
    <li><code>&lt;router-outlet&gt;</code>: Dins de <code>&lt;main&gt;</code>, marca on es renderitzen els components</li>
    <li><code>&lt;footer&gt;</code>: Peu fix de l'aplicació (sempre visible)</li>
  </ul>

  <h4>1.9.4. Verificar que funciona</h4>
  <p><strong>Pas 1:</strong> Assegureu-vos que <code>ng serve</code> està actiu</p>

  <p><strong>Pas 2:</strong> Obriu <code>http://localhost:4200/cataleg</code></p>

  <p><strong>Què hauria de passar:</strong></p>
  <ol>
    <li>Veieu el <code>&lt;header&gt;</code> amb "Catàleg d'Elements"</li>
    <li>Veieu el contingut de <code>CatalegPageComponent</code> (llistat d'elements)</li>
    <li>Veieu el <code>&lt;footer&gt;</code> amb el copyright</li>
    <li>La URL mostra <code>/cataleg</code></li>
  </ol>

  <p><strong>Pas 3:</strong> Canvieu manualment la URL a <code>http://localhost:4200/cerca</code></p>

  <p><strong>Què hauria de passar:</strong></p>
  <ol>
    <li>El <code>&lt;header&gt;</code> i <code>&lt;footer&gt;</code> es mantenen (no canvien)</li>
    <li>El contingut del <code>&lt;main&gt;</code> canvia (ara veieu <code>FormulariCercaComponent</code>)</li>
    <li><strong>NO hi ha recàrrega de pàgina</strong> (transició suau)</li>
  </ol>

  <h4>1.9.5. Errors comuns</h4>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Error</th>
        <th>Causa</th>
        <th>Solució</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>router-outlet is not a known element</code></td>
        <td>RouterModule no importat</td>
        <td>Afegir <code>imports: [RouterModule]</code> a AppComponent</td>
      </tr>
      <tr>
        <td>Component no es renderitza</td>
        <td>router-outlet absent</td>
        <td>Afegir <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> a la plantilla</td>
      </tr>
    </tbody>
  </table>

  {% include success_box.html contingut="<strong>Clau:</strong> <code>&lt;router-outlet&gt;</code> marca el lloc exacte on el Router injectarà els components de les rutes actives. Cal importar <code>RouterModule</code> per utilitzar aquesta directiva." %}

  <p><strong>Resultat:</strong> Teniu un router-outlet funcional i veieu com els components es renderitzen dinàmicament en navegar entre rutes.</p>

  {% endcapture %}
  {% include section-point.html numero="1.9" titol="Outlet de rutes: on es renderitzen els components de cada ruta" contingut=section_point_1_9 %}

  {% capture section_point_1_10 %}
  <p><strong>Objectiu:</strong> Crear un menú de navegació amb la directiva <code>routerLink</code> i indicadors visuals de ruta activa amb <code>routerLinkActive</code>.</p>

  <h4>1.10.1. Problema amb enllaços tradicionals</h4>
  <p>Si utilitzeu enllaços HTML tradicionals:</p>
{% capture code_59 %}<a href="/cataleg">Catàleg</a>{% endcapture %}
{% include code-block.html lang="html" code=code_59 %}

  <p><strong>Què passa en clicar:</strong></p>
  <ol>
    <li>El navegador detecta el clic</li>
    <li>El navegador envia petició HTTP al servidor per <code>/cataleg</code></li>
    <li>El servidor respon amb <code>index.html</code></li>
    <li><strong>La pàgina es recarrega completament</strong></li>
    <li>Angular s'inicialitza de nou</li>
    <li>Es perd l'estat de l'aplicació</li>
  </ol>
  <p><strong>Temps total:</strong> 1-2 segons (recàrrega completa)</p>

  <h4>1.10.2. Solució amb routerLink</h4>
  <p><code>routerLink</code> és una directiva que intercepta clics i utilitza el Router d'Angular:</p>
{% capture code_60 %}<a routerLink="/cataleg">Catàleg</a>{% endcapture %}
{% include code-block.html lang="html" code=code_60 %}

  <p><strong>Què passa en clicar:</strong></p>
  <ol>
    <li><code>routerLink</code> detecta el clic</li>
    <li><code>routerLink</code> crida <code>event.preventDefault()</code> (evita recàrrega)</li>
    <li><code>routerLink</code> crida <code>router.navigate(['/cataleg'])</code></li>
    <li>El Router actualitza la URL</li>
    <li>El Router canvia el component al router-outlet</li>
    <li><strong>NO hi ha recàrrega de pàgina</strong></li>
  </ol>
  <p><strong>Temps total:</strong> 50-100 ms (transició suau)</p>

  <h4>1.10.3. Afegir menú de navegació a AppComponent</h4>
  <p><strong>Actualitzeu <code>app.component.html</code>:</strong></p>
{% capture code_61 %}<div class="app-container">
  <header>
    <h1>Catàleg d'Elements</h1>

    <nav class="menu-principal">
      <a routerLink="/cataleg" routerLinkActive="actiu">Catàleg</a>
      <a routerLink="/cerca" routerLinkActive="actiu">Cerca</a>
      <a routerLink="/preferits" routerLinkActive="actiu">Preferits</a>
    </nav>
  </header>

  <main>
    <router-outlet></router-outlet>
  </main>

  <footer>
    <p>&copy; 2025 Catàleg Elements</p>
  </footer>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_61 %}

  <p><strong>Explicació:</strong></p>
  <ul>
    <li><code>routerLink="/cataleg"</code>: Defineix la ruta destí (amb <code>/</code> inicial)</li>
    <li><code>routerLinkActive="actiu"</code>: Afegeix la classe CSS <code>actiu</code> quan aquesta ruta està activa</li>
  </ul>

  <h4>1.10.4. Indicador visual de ruta activa</h4>
  <p><code>routerLinkActive</code> afegeix automàticament una classe CSS quan la ruta està activa:</p>
{% capture code_62 %}<a routerLink="/cataleg" routerLinkActive="actiu">Catàleg</a>{% endcapture %}
{% include code-block.html lang="html" code=code_62 %}

  <p><strong>Comportament:</strong></p>
{% capture code_63 %}URL actual: /cataleg
  → Classe 'actiu' s'afegeix a l'enllaç "Catàleg"
  → DOM: <a class="actiu">Catàleg</a>

URL actual: /cerca
  → Classe 'actiu' s'elimina de "Catàleg"
  → Classe 'actiu' s'afegeix a l'enllaç "Cerca"
  → DOM: <a class="actiu">Cerca</a>{% endcapture %}
{% include code-block.html lang="text" code=code_63 %}

  <h4>1.10.5. Afegir estils per a la ruta activa</h4>
  <p><strong>Actualitzeu <code>app.component.scss</code>:</strong></p>
{% capture code_64 %}.app-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

header {
  background-color: #3498db;
  color: white;
  padding: 1rem 2rem;

  h1 {
    margin: 0 0 1rem;
    font-size: 1.8rem;
  }
}

.menu-principal {
  display: flex;
  gap: 1.5rem;

  a {
    color: white;
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    transition: background-color 0.3s;

    &:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    &.actiu {
      background-color: rgba(255, 255, 255, 0.2);
      font-weight: 600;
      border-bottom: 2px solid white;
    }
  }
}

main {
  flex: 1;
  padding: 2rem;
  background-color: #f5f5f5;
}

footer {
  background-color: #34495e;
  color: white;
  text-align: center;
  padding: 1rem;

  p {
    margin: 0;
  }
}{% endcapture %}
{% include code-block.html lang="scss" code=code_64 %}

  <p><strong>Efecte visual:</strong></p>
  <ul>
    <li>Enllaç normal: Text blanc sobre blau</li>
    <li>Enllaç hover: Fons lleugerament més clar</li>
    <li>Enllaç actiu: Fons més clar, text en negreta, línia blanca inferior</li>
  </ul>

  <h4>1.10.6. Provar el menú</h4>
  <p><strong>Pas 1:</strong> Assegureu-vos que <code>ng serve</code> està actiu</p>

  <p><strong>Pas 2:</strong> Obriu <code>http://localhost:4200</code></p>

  <p><strong>Pas 3:</strong> Observeu el menú:</p>
  <ul>
    <li>L'enllaç "Catàleg" hauria de tenir la classe <code>actiu</code> (fons més clar, negreta, línia)</li>
    <li>Feu clic a "Cerca"</li>
    <li>La URL canvia a <code>/cerca</code> <strong>sense recarregar</strong></li>
    <li>L'enllaç "Cerca" ara té la classe <code>actiu</code></li>
    <li>L'enllaç "Catàleg" perd la classe <code>actiu</code></li>
  </ul>

  <p><strong>Pas 4:</strong> Proveu el botó enrere del navegador:</p>
  <ul>
    <li>Hauria de tornar a <code>/cataleg</code></li>
    <li>L'indicador visual hauria de canviar automàticament</li>
  </ul>

  {% include success_box.html contingut="<strong>Clau:</strong> <code>routerLink</code> permet navegació sense recàrrega i <code>routerLinkActive</code> proporciona feedback visual automàtic de la ruta actual." %}

  <p><strong>Resultat:</strong> Teniu un menú de navegació funcional amb indicadors visuals de ruta activa que millora l'experiència d'usuari.</p>

  {% endcapture %}
  {% include section-point.html numero="1.10" titol="Enllaços de navegació: crear menú amb rutes actives" contingut=section_point_1_10 %}

  {% capture section_point_1_11 %}
  <p><strong>Objectiu:</strong> Executar proves manuals per verificar que tot el sistema de rutes funciona correctament.</p>

  <h4>1.11.1. Checklist de verificació completa</h4>

  <p><strong>1. Càrrega inicial:</strong></p>
  {% include checklist.html elements="Obriu http://localhost:4200|La URL es redirigeix automàticament a /cataleg (gràcies a redirectTo)|Veieu el contingut de CatalegPageComponent|El títol de la pestanya és \"Catàleg d'elements\"|L'enllaç \"Catàleg\" al menú té la classe actiu" %}

  <p><strong>2. Navegació amb menú:</strong></p>
  {% include checklist.html elements="Feu clic a \"Cerca\" al menú|La URL canvia a /cerca sense recàrrega de pàgina (no hi ha parpelleig)|El contingut canvia a FormulariCercaComponent|El títol de la pestanya canvia a \"Cerca d'elements\"|L'enllaç \"Cerca\" ara té la classe actiu|L'enllaç \"Catàleg\" perd la classe actiu" %}

  <p><strong>3. Navegació amb URL manual:</strong></p>
  {% include checklist.html elements="Escriviu manualment http://localhost:4200/cerca a la barra d'adreces|Premeu Enter|Veieu FormulariCercaComponent|L'indicador visual del menú mostra \"Cerca\" actiu" %}

  <p><strong>4. Botons de navegació del navegador:</strong></p>
  {% include checklist.html elements="Navegueu: Catàleg → Cerca → Preferits|Feu clic al botó \"Enrere\" del navegador (2 vegades)|Hauríeu de tornar a Catàleg passant per Cerca|Feu clic al botó \"Endavant\"|Hauríeu d'avançar cap a Cerca" %}

  <p><strong>5. Recàrrega de pàgina (F5):</strong></p>
  {% include checklist.html elements="Navegueu a /preferits|Premeu F5 (recarregar pàgina)|Després de recarregar, encara esteu a /preferits|El contingut és PreferitsPanelComponent|L'indicador visual és correcte" %}

  <p><strong>6. Ruta inexistent (404):</strong></p>
  {% include checklist.html elements="Escriviu manualment http://localhost:4200/ruta-inexistent|La URL es redirigeix a /cataleg (gràcies a la ruta comodí **)|Veieu el catàleg normalment" %}

  <h4>1.11.2. Documentar la configuració</h4>
  <p>Creeu o actualitzeu <code>docs/navegacio.md</code>:</p>
{% capture code_65 %}# Sistema de rutes

## Configuració bàsica

### Rutes definides

| Ruta | Component | Títol | Descripció |
|------|-----------|-------|------------|
| `/` | — | — | Redirigeix a `/cataleg` |
| `/cataleg` | CatalegPageComponent | Catàleg d'elements | Llistat principal d'elements |
| `/cerca` | FormulariCercaComponent | Cerca d'elements | Formulari de cerca reactiu |
| `/preferits` | PreferitsPanelComponent | Els meus preferits | Llista de preferits amb notes |
| `/**` | — | — | Redirigeix a `/cataleg` (404) |

### Fitxers modificats

- `src/main.ts`: Afegit `provideRouter(routes)`
- `src/app/app.routes.ts`: Definició de rutes
- `src/app/app.component.ts`: Importat `RouterModule`
- `src/app/app.component.html`: Afegit `<router-outlet>` i menú de navegació
- `src/app/app.component.scss`: Estils per ruta activa

### Proves realitzades

- Navegació amb menú funcional
- Navegació amb URL manual funcional
- Botons enrere/endavant del navegador funcionals
- Recàrrega (F5) manté la ruta actual
- Rutes inexistents redireccionen a `/cataleg`
- Indicador visual de ruta activa funciona
- No hi ha recàrregues de pàgina en navegar

### Rendiment mesurat

- Càrrega inicial: ~1.2 MB, ~800 ms
- Navegació entre rutes: 0 KB, ~50 ms
- Millora vs pàgines tradicionals: 40-60x més ràpid{% endcapture %}
{% include code-block.html lang="markdown" code=code_65 %}

  {% include success_box.html contingut="<strong>Clau:</strong> Les proves manuals exhaustives asseguren que el sistema de rutes funciona correctament en tots els escenaris (menú, URL manual, navegació del navegador, recàrregues, 404)." %}

  <p><strong>Resultat:</strong> Teniu un sistema de rutes completament funcional i verificat, documentat i preparat per ampliacions futures (paràmetres, guards, lazy loading).</p>

  {% endcapture %}
  {% include section-point.html numero="1.11" titol="Verificar al navegador: navegació funcional entre pàgines" contingut=section_point_1_11 %}

  {% capture section_point_1_12 %}
  <ol>
    <li><strong>Crear fitxer de rutes</strong> (<code>src/app/app.routes.ts</code>) amb array <code>Routes</code> buit</li>
    <li><strong>Configurar provideRouter</strong> a <code>src/main.ts</code> per habilitar el sistema de rutes globalment</li>
    <li><strong>Definir 3-4 rutes</strong> amb <code>path</code>, <code>component</code> i <code>title</code>, incloent redirecció d'arrel i ruta comodí</li>
    <li><strong>Importar RouterModule</strong> a <code>AppComponent</code> per utilitzar directives del Router</li>
    <li><strong>Afegir router-outlet</strong> a la plantilla d'<code>AppComponent</code> per marcar punt d'injecció de components</li>
    <li><strong>Crear menú de navegació</strong> amb <code>routerLink</code> i <code>routerLinkActive="actiu"</code> per enllaços amb indicadors visuals</li>
    <li><strong>Afegir estils</strong> per remarcar la ruta activa (fons diferent, negreta, subratllat)</li>
    <li><strong>Provar navegació</strong> amb menú, URL manual, botons enrere/endavant i recàrregues</li>
    <li><strong>Verificar rendiment</strong> amb DevTools Network (0 peticions HTTP en navegar)</li>
    <li><strong>Documentar configuració</strong> a <code>docs/navegacio.md</code> amb taula de rutes i proves realitzades</li>
  </ol>

  <p><strong>Resultat esperat:</strong> Aplicació amb 3-4 vistes navegables mitjançant menú i URL, amb transicions suaus sense recàrregues, botons del navegador funcionals i indicadors visuals de ruta activa.</p>

  {% endcapture %}
  {% include section-point.html numero="1.12" titol="Mini exemple pràctic - Configuració de rutes bàsica" contingut=section_point_1_12 %}

  {% capture section_point_1_13 %}
  <h4>1.13.1. Errors transversals (tots els sistemes operatius)</h4>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Error</th>
        <th>Causa</th>
        <th>Solució</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Cannot match any routes for URL: segment</code></td>
        <td>Ruta no definida a <code>app.routes.ts</code></td>
        <td>Afegir ruta: <code>{ path: 'segment', component: ComponentName }</code></td>
      </tr>
      <tr>
        <td><code>'router-outlet' is not a known element</code></td>
        <td><code>RouterModule</code> no importat</td>
        <td>Afegir <code>imports: [RouterModule]</code> a <code>AppComponent</code></td>
      </tr>
      <tr>
        <td><code>Cannot find name 'routes'</code></td>
        <td>Import oblidat a <code>main.ts</code></td>
        <td>Afegir <code>import { routes } from './app/app.routes'</code></td>
      </tr>
      <tr>
        <td><code>Component is not a function</code></td>
        <td>Import de component incorrecte</td>
        <td>Verificar: <code>import { Comp } from './path/comp.component'</code></td>
      </tr>
      <tr>
        <td>Redirecció infinita (<code>/</code> → <code>/cataleg</code> → <code>/</code> → ...)</td>
        <td><code>pathMatch</code> oblidat</td>
        <td>Afegir <code>pathMatch: 'full'</code> a redirecció</td>
      </tr>
      <tr>
        <td>Ruta comodí captura totes les rutes</td>
        <td>Comodí no està al final</td>
        <td>Moure <code>{ path: '**', ... }</code> al final de l'array</td>
      </tr>
      <tr>
        <td><code>routerLink</code> no fa res (recarrega pàgina)</td>
        <td>Atribut <code>href</code> en lloc de <code>routerLink</code></td>
        <td>Canviar <code>href="/ruta"</code> per <code>routerLink="/ruta"</code></td>
      </tr>
      <tr>
        <td>Classe <code>actiu</code> no s'aplica</td>
        <td><code>routerLinkActive</code> mal escrit</td>
        <td>Verificar: <code>routerLinkActive="actiu"</code> (cometes correctes)</td>
      </tr>
    </tbody>
  </table>

  <h4>1.13.2. Errors de configuració (multiplataforma)</h4>
  <table class="table table-bordered">
    <thead>
      <tr>
        <th>Error</th>
        <th>Causa</th>
        <th>Solució</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Cannot find module '@angular/router'</code></td>
        <td>Dependència no instal·lada</td>
        <td><code>npm install</code></td>
      </tr>
      <tr>
        <td><code>ng serve</code> no arrenca</td>
        <td>Port 4200 ocupat</td>
        <td><code>ng serve --port 4300</code></td>
      </tr>
      <tr>
        <td>Hot reload no funciona després de canviar rutes</td>
        <td>Cache de ng serve</td>
        <td>Aturar amb Ctrl+C i tornar a executar <code>ng serve</code></td>
      </tr>
    </tbody>
  </table>

  {% endcapture %}
  {% include section-point.html numero="1.13" titol="Resolució de problemes" contingut=section_point_1_13 %}

  {% capture section_point_1_14 %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Ets un desenvolupador Angular senior especialitzat en sistemes de navegació i arquitectura SPA. <strong>Context:</strong> Estic aprenent a configurar el sistema de rutes d'Angular per primera vegada. He completat la lectura 4.1.1 on he configurat rutes bàsiques amb <code>routerLink</code>, <code>router-outlet</code> i <code>routerLinkActive</code>. <strong>Tasca:</strong> Crea una taula comparativa que m'ajudi a comprendre quan utilitzar cada tipus de navegació (routerLink vs navegació programàtica vs redireccions). Inclou 3-4 exemples pràctics per cada tipus. <strong>Format:</strong> Taula markdown amb columnes: Tipus de navegació | Quan utilitzar | Exemple de codi | Cas d'ús real." %}
{% include prompt-ai.html contingut="<strong>Rol:</strong> Ets un auditor de qualitat d'aplicacions web especialitzat en UX. <strong>Context:</strong> He configurat un sistema de rutes Angular amb 4 vistes principals (catàleg, cerca, preferits, detall). Cada ruta té el seu URL, títol i indicador visual de ruta activa al menú. <strong>Tasca:</strong> Genera un pla de proves manuals exhaustiu per verificar que el sistema de rutes funciona correctament. Inclou proves de navegació, URLs, botons del navegador, recàrregues i casos límit (URLs inexistents, etc.). <strong>Format:</strong> Llista numerada amb 15-20 casos de prova. Cada cas ha de tenir: Descripció de l'acció | Resultat esperat | Com verificar que funciona." %}

  {% endcapture %}
  {% include section-point.html numero="1.14" titol="Prompts d'IA" contingut=section_point_1_14 %}

  {% capture section_point_1_15 %}
  <h4>1.15.1. Criteris objectius (Definition of Done)</h4>

  <p><strong>Configuració tècnica:</strong></p>
  {% include checklist.html elements="He configurat provideRouter(routes) a src/main.ts correctament|He creat src/app/app.routes.ts amb almenys 3 rutes definides|He afegit redirecció de l'arrel (path: '') a una ruta principal|He afegit ruta comodí (path: '**') al final de l'array per gestionar 404|Cada ruta té path, component i title definits" %}

  <p><strong>Component principal:</strong></p>
  {% include checklist.html elements="He importat RouterModule a AppComponent|He afegit <router-outlet></router-outlet> a la plantilla|He creat menú de navegació amb routerLink a cada vista|He afegit routerLinkActive=\"actiu\" a cada enllaç del menú|He afegit estils CSS per remarcar la ruta activa" %}

  <p><strong>Funcionalitat verificada:</strong></p>
  {% include checklist.html elements="Puc navegar entre vistes clicant el menú|La URL canvia correctament en navegar (sense recàrrega)|El títol de la pestanya canvia segons la ruta|L'indicador visual mostra correctament la ruta activa|El botó \"Enrere\" del navegador funciona|El botó \"Endavant\" del navegador funciona|Puc escriure URLs manualment i funcionen|Recarregar (F5) manté la ruta actual|URLs inexistents redireccionen correctament" %}

  <p><strong>Documentació:</strong></p>
  {% include checklist.html elements="He creat/actualitzat docs/navegacio.md amb taula de rutes|He documentat les proves realitzades|He documentat els fitxers modificats" %}

  <h4>1.15.2. Competències adquirides</h4>

  <p><strong>Conceptes de navegació:</strong></p>
  {% include checklist.html elements="Comprenc què és una SPA i per què necessita sistema de rutes|Identifico els avantatges de les rutes (organització, URLs, navegabilitat)|Entenc la diferència entre pàgines tradicionals i SPAs amb Router|Sé explicar com funciona el cicle de navegació (URL → Router → Component)" %}

  <p><strong>Configuració d'Angular:</strong></p>
  {% include checklist.html elements="Configuro el Router a nivell d'aplicació amb provideRouter|Creo fitxers de rutes amb l'estructura correcta|Defineixo rutes amb path, component i title|Implemento redireccions amb redirectTo i pathMatch: 'full'|Gestiono rutes inexistents amb el comodí **" %}

  <p><strong>Implementació de components:</strong></p>
  {% include checklist.html elements="Utilitzo <router-outlet> per marcar punt d'injecció de components|Creo enllaços de navegació amb routerLink|Implemento indicadors visuals amb routerLinkActive|Aplico estils CSS per diferenciar rutes actives" %}

  <p><strong>Debugging i verificació:</strong></p>
  {% include checklist.html elements="Utilitzo DevTools per verificar navegació sense peticions HTTP|Comprovo que els botons del navegador funcionen correctament|Detecto i soluciono errors comuns de configuració|Documento la configuració per a referència futura" %}

  <p><strong>Bones pràctiques:</strong></p>
  {% include checklist.html elements="Organitzo rutes en fitxers separats|Utilitzo routerLink en lloc de href per enllaços interns|Afegeixo títols significatius a cada ruta per millorar UX i SEO|Proporciono redirecció per rutes inexistents (UX)|Documento decisions tècniques" %}

  {% endcapture %}
  {% include section-point.html numero="1.15" titol="Autoavaluació" contingut=section_point_1_15 %}

  {% capture section_point_1_16 %}
  <h4>1.16.1. Què hem aconseguit</h4>
  <p>Disposeu d'un <strong>sistema de rutes funcional</strong> a l'aplicació Angular del catàleg d'elements:</p>
  <ol>
    <li><strong>Configuració global:</strong> <code>provideRouter(routes)</code> a <code>main.ts</code> habilita el Router a tota l'aplicació</li>
    <li><strong>Mapa de rutes:</strong> <code>app.routes.ts</code> defineix 3-4 rutes principals amb URLs significatives</li>
    <li><strong>Redireccions intel·ligents:</strong> Arrel redirigeix a catàleg, rutes inexistents gestionen 404</li>
    <li><strong>Punt d'injecció:</strong> <code>&lt;router-outlet&gt;</code> marca on es renderitzen components de rutes actives</li>
    <li><strong>Menú de navegació:</strong> Enllaços amb <code>routerLink</code> permeten navegació fluida sense recàrregues</li>
    <li><strong>Indicadors visuals:</strong> <code>routerLinkActive</code> mostra automàticament quina ruta està activa</li>
    <li><strong>Navegació completa:</strong> Menú, URLs manuals, botons del navegador, tot funciona coherentment</li>
  </ol>

  <h4>1.16.2. Què queda preparat per a la següent lectura</h4>
  <p>A la <strong>Lectura 4.1.2 (Paràmetres de ruta i navegació programàtica)</strong> podreu:</p>
  <ul>
    <li>Afegir <strong>rutes amb paràmetres</strong> per passar IDs (<code>/detall/:id</code>)</li>
    <li>Capturar <strong>paràmetres al component</strong> amb <code>ActivatedRoute</code></li>
    <li>Implementar <strong>navegació programàtica</strong> des del TypeScript (<code>router.navigate()</code>)</li>
    <li>Utilitzar <strong>query params</strong> per filtres opcionals (<code>/cerca?q=arduino&categoria=electronics</code>)</li>
    <li>Passar <strong>estat temporal</strong> entre rutes sense mostrar-lo a la URL</li>
  </ul>

  <h4>1.16.3. Contracte de sortida</h4>
  <ul>
    <li><i class="bi bi-check-circle text-success"></i> Sistema de rutes configurat i funcional</li>
    <li><i class="bi bi-check-circle text-success"></i> Mapa de rutes amb 3-4 vistes principals</li>
    <li><i class="bi bi-check-circle text-success"></i> Menú de navegació amb indicadors visuals</li>
    <li><i class="bi bi-check-circle text-success"></i> URLs significatives i compartibles</li>
    <li><i class="bi bi-check-circle text-success"></i> Botons del navegador funcionals</li>
    <li><i class="bi bi-check-circle text-success"></i> Navegació sense recàrregues de pàgina</li>
    <li><i class="bi bi-check-circle text-success"></i> Gestió de rutes inexistents (404)</li>
    <li><i class="bi bi-check-circle text-success"></i> Documentació tècnica de la configuració</li>
  </ul>

  {% include success_box.html contingut="<strong>Esteu preparats per aprendre navegació avançada amb paràmetres!</strong>" %}

  {% endcapture %}
  {% include section-point.html numero="1.16" titol="Síntesi" contingut=section_point_1_16 %}

  {% capture section_point_1_17 %}
  <h4>1.17.1. Conceptes fonamentals</h4>
  <ul>
    <li><strong>SPA (Single Page Application):</strong> Aplicació web que carrega un sol HTML i actualitza contingut dinàmicament sense recàrregues</li>
    <li><strong>Router d'Angular:</strong> Servei que mapeja URLs a components i gestiona navegació sense recàrregues</li>
    <li><strong>Routes array:</strong> Col·lecció d'objectes que defineixen les rutes de l'aplicació</li>
    <li><strong>path:</strong> URL que activa una ruta (sense <code>/</code> inicial)</li>
    <li><strong>component:</strong> Component que es renderitza quan la ruta s'activa</li>
    <li><strong>redirectTo:</strong> Redirigeix automàticament a una altra ruta</li>
    <li><strong>pathMatch:</strong> <code>'full'</code> assegura coincidència exacta per redireccions</li>
    <li><strong>Ruta comodí (<code>**</code>):</strong> Captura URLs que no coincideixen amb cap altra ruta (404)</li>
  </ul>

  <h4>1.17.2. Directives del Router</h4>
  <ul>
    <li><strong>router-outlet:</strong> Marca el punt d'injecció on es renderitzen components de rutes actives</li>
    <li><strong>routerLink:</strong> Crea enllaços de navegació interna sense recàrregues</li>
    <li><strong>routerLinkActive:</strong> Afegeix classe CSS automàticament quan la ruta està activa</li>
  </ul>

  <h4>1.17.3. Configuració</h4>
  <ul>
    <li><strong>provideRouter(routes):</strong> Funció que configura el Router globalment a l'aplicació (Angular 18+)</li>
    <li><strong>RouterModule:</strong> Mòdul que proporciona directives i serveis del Router</li>
    <li><strong>main.ts:</strong> Punt d'entrada on es configura <code>provideRouter</code></li>
    <li><strong>app.routes.ts:</strong> Fitxer estàndard on es defineixen les rutes</li>
  </ul>

  <h4>1.17.4. Flux de navegació</h4>
  <ol>
    <li>Usuari clica enllaç amb <code>routerLink</code> o escriu URL manualment</li>
    <li>Router intercepta l'acció i actualitza la URL del navegador</li>
    <li>Router consulta el mapa de rutes per trobar coincidència</li>
    <li>Router destrueix el component anterior (crida <code>ngOnDestroy</code>)</li>
    <li>Router crea instància del nou component</li>
    <li>Router renderitza el nou component al <code>router-outlet</code></li>
    <li>Router inicialitza el component (crida <code>ngOnInit</code>)</li>
  </ol>

  {% endcapture %}
  {% include section-point.html numero="1.17" titol="Repàs de conceptes" contingut=section_point_1_17 %}

</div>

<!-- SECCIÓ 2: Paràmetres de ruta i navegació programàtica -->
<div class="section" id="Unitat4_Bloc1_Seccio2">
  <h2 id="Unitat4_Bloc1_Seccio2">2. Paràmetres de ruta i navegació programàtica</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=1 seccio=2 %}


  {% include objectius.html llista="Definir rutes amb paràmetres obligatoris (:id) i capturar-los als components|Utilitzar query params per a paràmetres opcionals (filtres, cerca, paginació)|Implementar navegació programàtica des de codi TypeScript amb Router|Passar dades temporals entre vistes durant la navegació sense exposar-les a la URL" %}

  {% include info_box.html contingut="<strong>RA4 · Criteri 1</strong> — Configura la navegació entre pantalles i la gestió de paràmetres." %}

  {% capture section_point_2_1 %}
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Lectura 4.1.1 completada:</strong> Sistema de rutes configurat amb navegació bàsica funcional</li>
<li><strong>Projecte catalog-elements operatiu:</strong> Aplicació executant-se amb <code>ng serve --port 4300</code> sense errors</li>
<li><strong>Components de llistat i detall:</strong> Mínim un component de llista d'elements i un component de detall preparat (pot estar buit)</li>
<li><strong>Servei amb dades:</strong> Servei que retorna llista d'elements amb identificador únic (pot usar JSONPlaceholder)</li>
</ul>
<p><strong>Verificació ràpida:</strong></p>
<p><strong>PowerShell (Windows):</strong></p>
{% capture code_66 %}Set-Location $env:USERPROFILE\workspace\catalog-elements
Get-Content .\src\app\navegacio\app.routes.ts{% endcapture %}
{% include code-block.html lang="powershell" code=code_66 %}
<p><strong>bash/zsh (macOS/Linux):</strong></p>
{% capture code_67 %}cd ~/workspace/catalog-elements
cat src/app/navegacio/app.routes.ts{% endcapture %}
{% include code-block.html lang="bash" code=code_67 %}
<p><strong>Punt d'autocomprovació:</strong> Heu de veure almenys 2-3 rutes definides (per exemple: <code>''</code>, <code>'cataleg'</code>, <code>'preferits'</code>). Si obriu l'aplicació al navegador (<code>http://localhost:4300</code>), heu de poder navegar entre les diferents rutes clicant enllaços del menú.</p>
  {% endcapture %}
  {% include section-point.html numero="2.1" titol="Prerequisits" contingut=section_point_2_1 %}

  {% capture section_point_2_2 %}
<h4>2.2.1. Què són els paràmetres de ruta i la navegació programàtica</h4>
<p>Els <strong>paràmetres de ruta</strong> són valors dinàmics que es passen com a part de la URL per identificar recursos específics. Per exemple, <code>/cataleg/42</code> on <code>42</code> és l'identificador d'un element. La <strong>navegació programàtica</strong> permet navegar entre vistes des de codi TypeScript (no només amb enllaços HTML), proporcionant control total sobre el moment i la manera de navegar.</p>
<h4>2.2.2. Problema sense paràmetres de ruta ni navegació programàtica</h4>
<p><strong>Situació abans:</strong></p>
<p>Imagineu una aplicació de catàleg amb 500 elements. Sense paràmetres de ruta, heu de crear 500 rutes estàtiques diferents:</p>
{% capture code_68 %}export const routes: Routes = [
  { path: 'element-1', component: DetallComponent },
  { path: 'element-2', component: DetallComponent },
  { path: 'element-3', component: DetallComponent },
  // ... 497 rutes més ...
  { path: 'element-500', component: DetallComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_68 %}
<p><strong>Estructura sense navegació programàtica:</strong></p>
<p>Sense navegació programàtica, només podeu navegar amb enllaços HTML. Això impedeix navegar després de validacions, operacions asíncrones o lògica condicional:</p>
{% capture code_69 %}<div *ngFor="let element of elements">
  <a [routerLink]="['/element-' + element.id]">{{ element.nom }}</a>
</div>{% endcapture %}
{% include code-block.html lang="html" code=code_69 %}
<p><strong>Problemes que genera:</strong></p>
<p><strong>1. Impossibilitat de crear aplicacions dinàmiques amb dades variables</strong></p>
<p>Amb rutes estàtiques, cada nou element del catàleg requereix afegir una ruta manualment al codi font. Si els elements venen d'una base de dades (API externa), això és completament inviable.</p>
<p><strong>Exemple real:</strong> Una botiga online amb 10.000 productes. Cada dia s'afegeixen 50 productes nous. Sense paràmetres de ruta, hauríeu de:</p>
<ol>
<li>Editar <code>app.routes.ts</code> manualment per afegir 50 rutes noves</li>
<li>Re-compilar l'aplicació</li>
<li>Re-desplegar al servidor</li>
</ol>
<p><strong>Resultat:</strong> Inviable. Amb paràmetres de ruta, una sola ruta <code>/producte/:id</code> gestiona tots els productes (actuals i futurs).</p>
<p><strong>2. Duplicació massiva de codi sense reutilització</strong></p>
<p>Sense paràmetres, cada ruta apunta al mateix component però no podem reutilitzar-lo eficaç. Acabem duplicant lògica o creant components massa genèrics que no saben quin element mostrar.</p>
<p><strong>Exemple de duplicació:</strong></p>
{% capture code_70 %}export class DetallElement1Component {
  element = { id: 1, nom: 'Element 1', preu: 15 };
}
export class DetallElement2Component {
  element = { id: 2, nom: 'Element 2', preu: 22 };
}
// ... 498 components més amb codi gairebé idèntic!{% endcapture %}
{% include code-block.html lang="typescript" code=code_70 %}
<p><strong>Cost de manteniment:</strong> Canviar la plantilla de detall requereix modificar 500 fitxers!</p>
<p><strong>3. URLs no amigables i problemes de SEO</strong></p>
<p>Sense query params per a filtres i opcions, heu de crear rutes estàtiques per a cada combinació:</p>
{% capture code_71 %}{ path: 'cataleg-categoria-1', component: CatalegComponent },
{ path: 'cataleg-categoria-2', component: CatalegComponent },
{ path: 'cataleg-categoria-1-preu-baix', component: CatalegComponent },
{ path: 'cataleg-categoria-1-preu-alt', component: CatalegComponent },
{ path: 'cataleg-categoria-2-preu-baix', component: CatalegComponent },
// ... 1000+ rutes per totes les combinacions!{% endcapture %}
{% include code-block.html lang="typescript" code=code_71 %}
<p><strong>Amb 5 categories, 3 opcions de preu i 4 opcions d'ordenació:</strong> 5 × 3 × 4 = <strong>60 rutes diferents</strong> només per filtres bàsics!</p>
<p><strong>Problema SEO:</strong> Google penalitza URLs no amigables. <code>/cataleg-categoria-1-preu-baix-ordenacio-nom-asc</code> és horrorosa. Amb query params: <code>/cataleg?categoria=1&preu=baix&ordre=nom</code> és molt més clara i indexable.</p>
<p><strong>4. Impossibilitat de navegar després de validacions o operacions</strong></p>
<p>Només amb enllaços HTML (<code>&lt;a routerLink&gt;</code>), no podeu navegar després de:</p>
<ul>
<li>Validar un formulari</li>
<li>Desar dades a la base de dades</li>
<li>Comprovar permisos d'usuari</li>
<li>Mostrar un diàleg de confirmació</li>
</ul>
<p><strong>Exemple real - Formulari de creació:</strong></p>
{% capture code_72 %}crearElement(dades: Element): void {
  this.service.crear(dades).subscribe({
    next: (elementCreat) => {
      // COM NAVEGO A /element/42 des d'aquí?
      // NO puc usar routerLink perquè és HTML, no TypeScript
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_72 %}
<p><strong>Resultat:</strong> No podeu navegar al detall de l'element acabat de crear perquè no teniu control programàtic de la navegació.</p>
<p><strong>5. Experiència d'usuari limitada sense control de navegació</strong></p>
<p>No podeu implementar fluxos complexos com:</p>
<ul>
<li>Navegar automàticament després de 3 segons</li>
<li>Redirigir segons el rol de l'usuari (admin vs usuari normal)</li>
<li>Navegar amb condicions (si té permisos → detall, si no → llista)</li>
<li>Passar dades temporals sense exposar-les a la URL (informació sensible)</li>
</ul>
<p><strong>Exemple - Redirecció condicional:</strong></p>
{% capture code_73 %}iniciarSessio(credencials): void {
  this.authService.login(credencials).subscribe({
    next: (usuari) => {
      if (usuari.rol === 'admin') {
        // Vull navegar a /admin-panel
      } else {
        // Vull navegar a /cataleg
      }
      // COM HO FER sense navegació programàtica?
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_73 %}
<h4>2.2.3. Solució amb paràmetres de ruta i navegació programàtica</h4>
<p>Els paràmetres de ruta permeten crear URLs dinàmiques que s'adapten a qualsevol dada. La navegació programàtica proporciona control total sobre quan i com navegar des de codi TypeScript.</p>
<p><strong>Avantatges principals:</strong></p>
<p><strong>1. Una sola ruta per a recursos dinàmics infinits</strong></p>
<p>Amb paràmetres, una ruta <code>/cataleg/:id</code> gestiona 1, 100 o 10.000 elements sense modificar el codi.</p>
<p><strong>2. Reutilització completa de components</strong></p>
<p>Un únic component <code>DetallComponent</code> serveix per mostrar qualsevol element, capturant l'ID de la ruta i carregant les dades corresponents.</p>
<p><strong>3. URLs amigables i SEO-friendly</strong></p>
<p>Query params permeten filtres clarament separats: <code>/cataleg?categoria=electrònica&preu=baix&ordre=nom</code>.</p>
<p><strong>4. Control total de la navegació</strong></p>
<p>Podeu navegar després de validacions, operacions asíncrones, condicions complexes i amb dades temporals no visibles a la URL.</p>
<p><strong>5. Fluxos d'usuari sofisticats</strong></p>
<p>Implementeu redireccions condicionals, navegació automàtica, passada de dades sensibles i qualsevol lògica personalitzada.</p>
<h4>2.2.4. Exemple real: Abans vs Després dels paràmetres de ruta</h4>
<p><strong>ABANS (500 rutes estàtiques):</strong></p>
{% capture code_74 %}export const routes: Routes = [
  { path: 'element-1', component: DetallElement1Component },
  { path: 'element-2', component: DetallElement2Component },
  { path: 'element-3', component: DetallElement3Component },
  // ... 497 rutes més ...
];
export class DetallElement1Component {
  element = { id: 1, nom: 'Portàtil Dell', preu: 850 };
}
export class DetallElement2Component {
  element = { id: 2, nom: 'Ratolí Logitech', preu: 25 };
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_74 %}
<p><strong>Cost de desenvolupament:</strong> 500 components × 5 minuts/component = <strong>42 hores</strong> només per crear els components!</p>
<p><strong>DESPRÉS (1 ruta dinàmica amb paràmetre):</strong></p>
{% capture code_75 %}export const routes: Routes = [
  { path: 'element/:id', component: DetallComponent }
];
export class DetallComponent implements OnInit {
  element?: Element;
  constructor(
    private route: ActivatedRoute,
    private service: ElementsService
  ) {}
  ngOnInit(): void {
    const id = Number(this.route.snapshot.paramMap.get('id'));
    this.service.obtenirPerID(id).subscribe(element => {
      this.element = element;
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_75 %}
<p><strong>Cost de desenvolupament:</strong> 1 component × 5 minuts = <strong>5 minuts</strong>. Estalvi: 41 hores 55 minuts! (99.8% reducció)</p>
<p><strong>URLs generades automàticament:</strong></p>
<ul>
<li><code>/element/1</code> → Mostra Portàtil Dell</li>
<li><code>/element/2</code> → Mostra Ratolí Logitech</li>
<li><code>/element/42</code> → Mostra qualsevol element amb ID 42</li>
<li><code>/element/9999</code> → Funciona per a elements futurs sense canvis de codi</li>
</ul>
<h4>2.2.5. Exemple real: Navegació només amb enllaços vs Navegació programàtica</h4>
<p><strong>ABANS (només enllaços HTML):</strong></p>
{% capture code_76 %}crearElement(formulari: FormGroup): void {
  if (formulari.invalid) {
    return;
  }
  this.service.crear(formulari.value).subscribe({
    next: (elementCreat) => {
      console.log('Element creat amb ID:', elementCreat.id);
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_76 %}
<p><strong>Experiència d'usuari:</strong> L'usuari clica "Crear", veu un missatge "Element creat", però ha de clicar un altre enllaç per veure el detall. 2 clics en lloc d'1!</p>
<p><strong>DESPRÉS (navegació programàtica):</strong></p>
{% capture code_77 %}constructor(
  private router: Router,
  private service: ElementsService
) {}
crearElement(formulari: FormGroup): void {
  if (formulari.invalid) {
    return;
  }
  this.service.crear(formulari.value).subscribe({
    next: (elementCreat) => {
      this.router.navigate(['/element', elementCreat.id]);
    },
    error: (error) => {
      alert('Error al crear element');
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_77 %}
<p><strong>Experiència d'usuari:</strong> L'usuari clica "Crear" i <strong>automàticament</strong> veu el detall del nou element. 1 clic, transició fluida! (50% reducció de fricció)</p>
<h4>2.2.6. Comparativa quantitativa: Abans vs Després</h4>
<table>
<thead>
<tr>
<th>Mètrica</th>
<th>Abans (estàtic)</th>
<th>Després (paràmetres + navegació programàtica)</th>
<th>Millora</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Rutes necessàries</strong></td>
<td>500 (1 per element)</td>
<td>1 (<code>/element/:id</code>)</td>
<td><strong>-99.8%</strong></td>
</tr>
<tr>
<td><strong>Components necessaris</strong></td>
<td>500</td>
<td>1</td>
<td><strong>-99.8%</strong></td>
</tr>
<tr>
<td><strong>Temps de desenvolupament</strong></td>
<td>42 hores</td>
<td>5 minuts</td>
<td><strong>-99.8%</strong></td>
</tr>
<tr>
<td><strong>Línies de codi</strong></td>
<td>15.000 (500 × 30 línies)</td>
<td>30</td>
<td><strong>-99.8%</strong></td>
</tr>
<tr>
<td><strong>Clics per veure detall després de crear</strong></td>
<td>2 (crear + enllaç)</td>
<td>1 (crear → auto-navega)</td>
<td><strong>-50%</strong></td>
</tr>
<tr>
<td><strong>Suport per elements futurs</strong></td>
<td>Cal afegir ruta manualment</td>
<td>Automàtic</td>
<td><strong>∞</strong></td>
</tr>
<tr>
<td><strong>Flexibilitat de filtres</strong></td>
<td>60 rutes (explosió combinatòria)</td>
<td>1 ruta + query params</td>
<td><strong>-98.3%</strong></td>
</tr>
</tbody>
</table>
<h4>2.2.7. Taula de conceptes clau</h4>
<table>
<thead>
<tr>
<th>Concepte</th>
<th>Definició</th>
<th>Exemple d'ús</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Route params</strong></td>
<td>Paràmetres obligatoris definits amb <code>:nom</code> a la ruta</td>
<td><code>/element/:id</code> → <code>/element/42</code></td>
</tr>
<tr>
<td><strong>Query params</strong></td>
<td>Paràmetres opcionals afegits amb <code>?clau=valor</code></td>
<td><code>/cataleg?categoria=3&preu=baix</code></td>
</tr>
<tr>
<td><strong>ActivatedRoute</strong></td>
<td>Servei que proporciona accés als paràmetres de la ruta actual</td>
<td><code>this.route.snapshot.paramMap.get('id')</code></td>
</tr>
<tr>
<td><strong>Router</strong></td>
<td>Servei per a navegació programàtica des de TypeScript</td>
<td><code>this.router.navigate(['/element', 42])</code></td>
</tr>
<tr>
<td><strong>paramMap</strong></td>
<td>Mapa de paràmetres de ruta (route params)</td>
<td><code>paramMap.get('id')</code> retorna <code>'42'</code></td>
</tr>
<tr>
<td><strong>queryParamMap</strong></td>
<td>Mapa de query params</td>
<td><code>queryParamMap.get('categoria')</code> retorna <code>'3'</code></td>
</tr>
<tr>
<td><strong>snapshot</strong></td>
<td>Captura instantània dels paràmetres (no reactiva)</td>
<td><code>snapshot.paramMap.get('id')</code> - valor actual</td>
</tr>
<tr>
<td><strong>subscribe</strong></td>
<td>Subscripció reactiva als canvis de paràmetres</td>
<td><code>this.route.paramMap.subscribe(...)</code> - reacciona a canvis</td>
</tr>
<tr>
<td><strong>NavigationExtras</strong></td>
<td>Opcions addicionals per a navegació (query params, estat, etc.)</td>
<td><code>{ queryParams: { filtre: 'actiu' } }</code></td>
</tr>
<tr>
<td><strong>Router state</strong></td>
<td>Estat temporal passat durant la navegació (no visible a la URL)</td>
<td><code>{ state: { dadesSensibles: {...} } }</code></td>
</tr>
</tbody>
</table>
<h4>2.2.8. Quan usar paràmetres de ruta vs query params</h4>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar route params (<code>:id</code>) quan:</strong></p>
<ul>
<li>L'identificador és <strong>obligatori</strong> per renderitzar la vista (sense ell, la pàgina no té sentit)</li>
<li>Exemple: <code>/element/42</code> - sense ID, no hi ha element a mostrar</li>
<li>Exemple: <code>/usuari/maria</code> - sense nom d'usuari, no hi ha perfil</li>
</ul>
<p><strong><i class="bi bi-check-circle" aria-hidden="true"></i> Usar query params (<code>?clau=valor</code>) quan:</strong></p>
<ul>
<li>Els paràmetres són <strong>opcionals</strong> i la vista té un estat per defecte sense ells</li>
<li>Exemple: <code>/cataleg?categoria=3&ordre=preu</code> - sense paràmetres, mostra tots els elements sense filtrar</li>
<li>Exemple: <code>/cerca?q=angular&pàgina=2</code> - sense query, mostra pàgina 1 sense cerca</li>
</ul>
<p><strong><i class="bi bi-x-circle" aria-hidden="true"></i> NO barrejar-los incorrectament:</strong></p>
<ul>
<li><i class="bi bi-x-circle" aria-hidden="true"></i> <code>/cataleg/:categoria/:ordre</code> - Forçar l'usuari a especificar categoria i ordre sempre</li>
<li><i class="bi bi-check-circle" aria-hidden="true"></i> <code>/cataleg?categoria=3&ordre=preu</code> - Opcionals, poden ometre's</li>
</ul>
<p><strong>Regla pràctica:</strong> Si pots dir "la pàgina encara té sentit sense aquest valor", és un query param. Si dius "sense aquest valor, no hi ha res a mostrar", és un route param.</p>
<h4>2.2.9. Característiques principals dels paràmetres i navegació programàtica</h4>
<p><strong>1. Captura reactiva i estàtica de paràmetres</strong></p>
<p>Angular ofereix dos mètodes per capturar paràmetres:</p>
<ul>
<li><strong>snapshot:</strong> Captura instantània (més ràpid, no reactiu)</li>
<li><strong>subscribe:</strong> Subscripció reactiva (actualitza automàticament si els paràmetres canvien)</li>
</ul>
<p><strong>Snapshot (ús més comú):</strong></p>
{% capture code_78 %}const id = this.route.snapshot.paramMap.get('id');{% endcapture %}
{% include code-block.html lang="typescript" code=code_78 %}
<p><strong>Subscribe (quan els paràmetres canvien sense recarregar el component):</strong></p>
{% capture code_79 %}this.route.paramMap.subscribe(params => {
  const id = params.get('id');
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_79 %}
<p><strong>Quan usar cada un:</strong></p>
<ul>
<li><strong>Snapshot:</strong> 95% dels casos. Quan navegueu a <code>/element/42</code>, el component es destrueix i es crea de nou amb el nou ID</li>
<li><strong>Subscribe:</strong> Casos especials on Angular reutilitza el mateix component amb diferent ID (rutes niades complexes)</li>
</ul>
<p><strong>2. Navegació programàtica amb múltiples opcions</strong></p>
<p>El servei <code>Router</code> proporciona diversos mètodes de navegació:</p>
{% capture code_80 %}this.router.navigate(['/element', 42]);
this.router.navigate(['/cataleg'], {
  queryParams: { categoria: 3, ordre: 'preu' }
});
this.router.navigate(['/detall'], {
  state: { dadesSensibles: { token: 'abc123' } }
});
this.router.navigate(['../germà'], { relativeTo: this.route });{% endcapture %}
{% include code-block.html lang="typescript" code=code_80 %}
<p><strong>3. Passar dades temporals amb Router state</strong></p>
<p>Podeu passar dades entre components sense exposar-les a la URL (útil per dades sensibles o grans):</p>
{% capture code_81 %}this.router.navigate(['/confirmacio'], {
  state: { comanda: { productes: [...], total: 350 } }
});
constructor(private router: Router) {
  const navigation = this.router.getCurrentNavigation();
  const state = navigation?.extras.state as { comanda: Comanda };
  this.comanda = state?.comanda;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_81 %}
<p><strong>Avantatge:</strong> Les dades NO apareixen a la URL (més netes, més segures).<br><strong>Desavantatge:</strong> Si l'usuari recarrega la pàgina (F5), les dades es perden (no persisteixen).</p>
<p><strong>4. Combinació de route params i query params</strong></p>
<p>Podeu combinar ambdós tipus en la mateixa navegació:</p>
{% capture code_82 %}this.router.navigate(['/element', 42], {
  queryParams: { vista: 'detallada', llegir: 'false' }
});
// Resultat: /element/42?vista=detallada&llegir=false{% endcapture %}
{% include code-block.html lang="typescript" code=code_82 %}
<p><strong>Captura als dos llocs:</strong></p>
{% capture code_83 %}const id = this.route.snapshot.paramMap.get('id');
const vista = this.route.snapshot.queryParamMap.get('vista');
const llegir = this.route.snapshot.queryParamMap.get('llegir');{% endcapture %}
{% include code-block.html lang="typescript" code=code_83 %}
<p><strong>5. Validació i conversió de tipus</strong></p>
<p>Els paràmetres de ruta i query params <strong>sempre són strings</strong>. Cal convertir-los:</p>
{% capture code_84 %}const id = Number(this.route.snapshot.paramMap.get('id'));
const idString = this.route.snapshot.paramMap.get('id');
const id = Number(idString);
if (isNaN(id) || id <= 0) {
  this.router.navigate(['/error']);
  return;
}
this.service.obtenirPerID(id).subscribe(...);{% endcapture %}
{% include code-block.html lang="typescript" code=code_84 %}
<h4>2.2.10. Integració amb el flux de treball del projecte catalog-elements</h4>
<p>En el projecte <code>catalog-elements</code>, aplicarem paràmetres de ruta per navegar del llistat al detall d'elements, i navegació programàtica per redirigir després d'operacions com afegir a preferits:</p>
<p><strong>Rutes amb paràmetres:</strong></p>
<ul>
<li><code>/cataleg</code> - Llista tots els elements</li>
<li><code>/cataleg/:id</code> - Detall d'un element específic (ID capturat dinàmicament)</li>
<li><code>/preferits?ordre=data</code> - Llista de preferits amb ordenació opcional</li>
</ul>
<p><strong>Navegació programàtica:</strong></p>
<ul>
<li>Després d'afegir un element a preferits → navegar a <code>/preferits</code></li>
<li>Després de clicar un element del catàleg → navegar a <code>/cataleg/42</code></li>
<li>Després de guardar canvis a la configuració → navegar a <code>/</code> (inici)</li>
</ul>
<p><strong>Flux d'usuari optimitzat:</strong></p>
<ol>
<li>L'usuari navega a <code>/cataleg</code> → Veu llista d'elements</li>
<li>Clica un element → Navegació programàtica a <code>/cataleg/42</code></li>
<li>Component detall captura <code>id = 42</code> i carrega dades</li>
<li>Usuari clica "Afegir a preferits" → Després de desar, navegació automàtica a <code>/preferits</code></li>
</ol>
<p><strong>Resultat:</strong> Flux fluid sense clics innecessaris, URLs netes i amigables, i dades carregades dinàmicament segons l'ID de la ruta.</p>
  {% endcapture %}
  {% include section-point.html numero="2.2" titol="Marc conceptual" contingut=section_point_2_2 %}

  {% capture section_point_2_3 %}
<h4>2.3.1. Paràmetres de ruta com variables d'una funció</h4>
<p>Imagina que cada vista és una funció i els paràmetres de ruta són els seus arguments. <code>/element/:id</code> és com <code>mostrarElement(id)</code>. Sense paràmetres, hauríeu de crear funcions separades: <code>mostrarElement1()</code>, <code>mostrarElement2()</code>, etc. Amb paràmetres, una sola funció serveix per a tots.</p>
<h4>2.3.2. Query params com opcions configurables</h4>
<p>Els query params són com opcions addicionals que personalitzen el resultat sense canviar la funció base. <code>/cataleg?ordre=preu</code> és com <code>mostrarCataleg({ ordre: 'preu' })</code>. Sense ells, la funció té valors per defecte raonables.</p>
<h4>2.3.3. Navegació programàtica com un comandament</h4>
<p>Amb enllaços HTML (<code>&lt;a&gt;</code>), l'usuari té el control: tu només ofereixes botons i ell decideix quan clicar. Amb navegació programàtica (<code>router.navigate()</code>), tu tens el control: pots navegar automàticament quan les condicions són correctes, com un pilot automàtic.</p>
<h4>2.3.4. Snapshot vs Subscribe com foto vs vídeo</h4>
<p><code>snapshot.paramMap</code> és com fer una foto: captura el valor actual en un instant. <code>paramMap.subscribe()</code> és com gravar un vídeo: et notifica cada vegada que els paràmetres canvien, frame a frame.</p>
<h4>2.3.5. Router state com notes adhesives temporals</h4>
<p>Passar dades amb <code>router state</code> és com enganxar una nota adhesiva al dorso d'un document. Les dades viatgen amb la navegació, però no són permanents (si recarregues la pàgina, es perden). Útil per informació temporal que no vols exposar a la URL.</p>
  {% endcapture %}
  {% include section-point.html numero="2.3" titol="Model mental" contingut=section_point_2_3 %}

  {% capture section_point_2_4 %}
<h4>2.4.1. Objectiu</h4>
<p>Comprendre per què les aplicacions reals necessiten passar informació entre vistes i els problemes que resolen els paràmetres.</p>
<h4>2.4.2. Per què els paràmetres són essencials</h4>
<p>Les aplicacions modernes rarament tenen pàgines completament estàtiques. Quan un usuari clica un element d'una llista, vol veure el detall d'<strong>aquest element específic</strong>. Quan cerca "portàtils", vol veure resultats filtrats per "portàtils", no tots els productes. Aquests valors dinàmics són els paràmetres.</p>
<p><strong>1. Identificar recursos individuals</strong></p>
<p>En qualsevol aplicació amb llistes (productes, usuaris, articles, comandes), necessiteu identificar un element concret per mostrar-ne el detall. Els paràmetres de ruta permeten passar l'identificador únic:</p>
<ul>
<li><strong>Botiga online:</strong> <code>/producte/42</code> - Producte amb ID 42</li>
<li><strong>Xarxa social:</strong> <code>/usuari/maria</code> - Perfil de Maria</li>
<li><strong>Blog:</strong> <code>/article/com-aprendre-angular</code> - Article amb slug "com-aprendre-angular"</li>
</ul>
<p><strong>Sense paràmetres:</strong> Imposible. Hauríeu de crear una ruta i component separats per a cada producte, usuari o article (inviable amb milers de registres).</p>
<p><strong>2. Filtrar i cercar resultats</strong></p>
<p>Les llistes grans necessiten filtres per ser útils. Els query params permeten passar criteris de cerca i ordenació sense alterar la ruta base:</p>
<ul>
<li><strong>Catàleg:</strong> <code>/productes?categoria=electrònica&preu_max=500&ordre=popularitat</code></li>
<li><strong>Cerca:</strong> <code>/cerca?q=angular&tipus=articles&data=recent</code></li>
<li><strong>Paginació:</strong> <code>/blog?pàgina=3&per_pàgina=10</code></li>
</ul>
<p><strong>Avantatge:</strong> Els filtres són opcionals. Si l'usuari no especifica cap filtre, la pàgina mostra resultats per defecte (tots els productes, primera pàgina, etc.).</p>
<p><strong>3. Mantenir l'estat a la URL (compartible i marcable)</strong></p>
<p>Quan els paràmetres estan a la URL, l'usuari pot:</p>
<ul>
<li><strong>Copiar i enganxar</strong> la URL per compartir-la (exemple: <code>/producte/42</code> compartit a WhatsApp)</li>
<li><strong>Marcar la pàgina</strong> als favorits del navegador (exemple: <code>/cataleg?categoria=llibres&ordre=preu</code>)</li>
<li><strong>Navegar endavant/enrere</strong> amb les fletxes del navegador sense perdre l'estat</li>
</ul>
<p><strong>Sense paràmetres a la URL:</strong> Impossible compartir o marcar una cerca específica. Cada vegada que l'usuari obre l'aplicació, comença des de zero.</p>
<h4>2.4.3. Tipus de paràmetres segons la necessitat</h4>
<p><strong>Route params (<code>:nom</code>) - Obligatoris i essencials:</strong></p>
<p>Quan el paràmetre és necessari per renderitzar la vista. Sense ell, la pàgina no té sentit.</p>
<p><strong>Exemples:</strong></p>
<ul>
<li><code>/element/:id</code> - Sense ID, no hi ha element a mostrar</li>
<li><code>/comanda/:numeroComanda</code> - Sense número de comanda, no hi ha comanda</li>
<li><code>/usuari/:nomUsuari</code> - Sense nom d'usuari, no hi ha perfil</li>
</ul>
<p><strong>Query params (<code>?clau=valor</code>) - Opcionals i configurables:</strong></p>
<p>Quan el paràmetre personalitza o filtra la vista, però la vista té un estat per defecte sense ell.</p>
<p><strong>Exemples:</strong></p>
<ul>
<li><code>/cataleg?categoria=3</code> - Sense categoria, mostra tots els elements</li>
<li><code>/cerca?q=angular</code> - Sense query, mostra pàgina de cerca buida</li>
<li><code>/blog?pàgina=2</code> - Sense pàgina, mostra pàgina 1 per defecte</li>
</ul>
<h4>2.4.4. Analogia amb funcions de programació</h4>
<p>Els paràmetres de ruta són com arguments de funcions:</p>
{% capture code_85 %}function mostrarElement(id: number) {
  return database.obtenirElement(id);
}
function llistarElements(categoria?: string, ordre?: string) {
  categoria = categoria ?? 'totes';
  ordre = ordre ?? 'data';
  return database.llistarElements(categoria, ordre);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_85 %}
<p><strong>Traducció a rutes:</strong></p>
<ul>
<li><code>mostrarElement(42)</code> → <code>/element/42</code> (route param obligatori)</li>
<li><code>llistarElements('llibres', 'preu')</code> → <code>/cataleg?categoria=llibres&ordre=preu</code> (query params opcionals)</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> Els paràmetres de ruta permeten passar identificadors, filtres i configuracions entre vistes, fent les aplicacions dinàmiques, compartibles i marcables. Route params són obligatoris (<code>:id</code>), query params són opcionals (<code>?clau=valor</code>)." %}
<h4>2.4.5. Resultat esperat</h4>
<p>Compreneu per què les aplicacions reals necessiten paràmetres per identificar recursos, filtrar resultats i mantenir l'estat compartible a la URL.</p>
  {% endcapture %}
  {% include section-point.html numero="2.4" titol="Per què necessitem paràmetres: passar identificadors, filtres, etc." contingut=section_point_2_4 %}

  {% capture section_point_2_5 %}
<h4>2.5.1. Objectiu</h4>
<p>Aprendre la sintaxi per definir rutes amb paràmetres obligatoris i entendre com Angular els interpreta.</p>
<h4>2.5.2. Sintaxi de definició</h4>
<p>Els <strong>paràmetres de ruta obligatoris</strong> es defineixen amb dos punts (<code>:</code>) seguits del nom del paràmetre. Per exemple, <code>/element/:id</code> significa que la ruta espera un valor després de <code>/element/</code>, com ara <code>/element/42</code> o <code>/element/999</code>.</p>
{% capture code_86 %}import { Routes } from '@angular/router';
import { DetallElementComponent } from '../cataleg/detall-element.component';
export const routes: Routes = [
  {
    path: 'element/:id',
    component: DetallElementComponent
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_86 %}
<p><strong>Interpretació d'Angular:</strong></p>
<ul>
<li><code>element</code> és un segment estàtic (literal)</li>
<li><code>:id</code> és un segment dinàmic (variable)</li>
</ul>
<p><strong>URLs que coincideixen:</strong></p>
<ul>
<li><code>/element/1</code> → <code>id = '1'</code></li>
<li><code>/element/42</code> → <code>id = '42'</code></li>
<li><code>/element/abc</code> → <code>id = 'abc'</code> (Angular accepta qualsevol string)</li>
<li><code>/element/999-portàtil-dell</code> → <code>id = '999-portàtil-dell'</code></li>
</ul>
<p><strong>URLs que NO coincideixen:</strong></p>
<ul>
<li><code>/element</code> → Falta el paràmetre <code>id</code> (404 Not Found)</li>
<li><code>/element/42/extra</code> → Té segments addicionals (404, a menys que hi hagi ruta niada)</li>
</ul>
<h4>2.5.3. Múltiples paràmetres a la mateixa ruta</h4>
<p>Podeu definir múltiples paràmetres obligatoris:</p>
{% capture code_87 %}{
  path: 'categoria/:nomCategoria/element/:id',
  component: DetallElementComponent
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_87 %}
<p><strong>URLs que coincideixen:</strong></p>
<ul>
<li><code>/categoria/electrònica/element/42</code> → <code>nomCategoria = 'electrònica'</code>, <code>id = '42'</code></li>
<li><code>/categoria/llibres/element/7</code> → <code>nomCategoria = 'llibres'</code>, <code>id = '7'</code></li>
</ul>
<p><strong>Captura al component:</strong></p>
{% capture code_88 %}const categoria = this.route.snapshot.paramMap.get('nomCategoria');
const id = this.route.snapshot.paramMap.get('id');{% endcapture %}
{% include code-block.html lang="typescript" code=code_88 %}
<h4>2.5.4. Nomenament de paràmetres: convencions</h4>
<p><strong>Bona pràctica:</strong></p>
<ul>
<li>Usar noms descriptius: <code>:id</code>, <code>:userId</code>, <code>:nomCategoria</code>, <code>:slug</code></li>
<li>camelCase per a noms compostos: <code>:numeroComanda</code>, <code>:nomUsuari</code></li>
<li>Evitar noms genèrics com <code>:param</code>, <code>:valor</code>, <code>:x</code></li>
</ul>
<p><strong>Exemples bons:</strong></p>
{% capture code_89 %}{ path: 'usuari/:nomUsuari', component: PerfilComponent }
{ path: 'producte/:id', component: DetallProducteComponent }
{ path: 'article/:slug', component: ArticleComponent }{% endcapture %}
{% include code-block.html lang="typescript" code=code_89 %}
<p><strong>Exemples dolents:</strong></p>
{% capture code_90 %}{ path: 'usuari/:x', component: PerfilComponent }
{ path: 'producte/:param', component: DetallProducteComponent }
{ path: 'article/:a', component: ArticleComponent }{% endcapture %}
{% include code-block.html lang="typescript" code=code_90 %}
<h4>2.5.5. Ordre de definició de rutes: rutes estàtiques primer</h4>
<p>Quan teniu rutes amb paràmetres, és important l'ordre de definició. Angular avalua les rutes <strong>de dalt a baix</strong> i retorna la primera coincidència:</p>
{% capture code_91 %}export const routes: Routes = [
  { path: 'element/:id', component: DetallComponent },
  { path: 'element/crear', component: CrearComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_91 %}
<p><strong>Problema:</strong> Quan l'usuari navega a <code>/element/crear</code>, Angular veu <code>element/:id</code> primer i assigna <code>id = 'crear'</code>. La ruta <code>element/crear</code> no s'avalua mai.</p>
{% capture code_92 %}export const routes: Routes = [
  { path: 'element/crear', component: CrearComponent },
  { path: 'element/:id', component: DetallComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_92 %}
<p><strong>Resultat:</strong> <code>/element/crear</code> coincideix amb la ruta estàtica. <code>/element/42</code> coincideix amb la ruta dinàmica.</p>
<h4>2.5.6. Paràmetres vs segments estàtics: diferències</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Segment estàtic</th>
<th>Paràmetre dinàmic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Definició</strong></td>
<td>Text literal</td>
<td>Prefixat amb <code>:</code></td>
</tr>
<tr>
<td><strong>Exemple</strong></td>
<td><code>path: 'element'</code></td>
<td><code>path: 'element/:id'</code></td>
</tr>
<tr>
<td><strong>Coincidència</strong></td>
<td>Només si la URL és exactament <code>element</code></td>
<td>Qualsevol valor després de <code>element/</code></td>
</tr>
<tr>
<td><strong>Captura</strong></td>
<td>No hi ha res a capturar</td>
<td>Valor accessible amb <code>paramMap.get('id')</code></td>
</tr>
<tr>
<td><strong>Ús típic</strong></td>
<td>Rutes fixes (<code>/inici</code>, <code>/contacte</code>)</td>
<td>Recursos dinàmics (<code>/usuari/42</code>)</td>
</tr>
</tbody>
</table>
<h4>2.5.7. Validació de paràmetres: responsabilitat del component</h4>
<p>Angular NO valida els paràmetres automàticament. Accepta qualsevol string:</p>
{% capture code_93 %}/element/42
/element/abc
/element/-1
/element/{% endcapture %}
{% include code-block.html lang="text" code=code_93 %}
<p><strong>Responsabilitat del component:</strong> Validar i convertir el paràmetre:</p>
{% capture code_94 %}ngOnInit(): void {
  const idString = this.route.snapshot.paramMap.get('id');
  const id = Number(idString);
  if (isNaN(id) || id <= 0) {
    this.router.navigate(['/error']);
    return;
  }
  this.service.obtenirPerID(id).subscribe(element => {
    this.element = element;
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_94 %}
{% include success_box.html contingut="<strong>Clau:</strong> Els paràmetres de ruta obligatoris es defineixen amb <code>:nom</code> al <code>path</code>. Angular captura qualsevol valor en aquesta posició com a string. Cal validar i convertir els paràmetres al component. Rutes estàtiques han de definir-se abans de rutes dinàmiques per evitar captures incorrectes." %}
<h4>2.5.8. Resultat esperat</h4>
<p>Sabeu definir rutes amb paràmetres obligatoris, enteneu com Angular les interpreta, coneixeu la importància de l'ordre de definició i sabeu que cal validar els paràmetres al component.</p>
  {% endcapture %}
  {% include section-point.html numero="2.5" titol="Paràmetres de ruta obligatoris: definició amb dos punts (:id)" contingut=section_point_2_5 %}

  {% capture section_point_2_6 %}
<h4>2.6.1. Objectiu</h4>
<p>Aprendre a capturar els paràmetres de ruta al component i entendre les diferències entre <code>snapshot</code> i <code>subscribe</code>.</p>
<h4>2.6.2. Servei ActivatedRoute: accés als paràmetres</h4>
<p>Un cop definida una ruta amb paràmetres (<code>element/:id</code>), el component necessita accedir al valor del paràmetre per carregar les dades corresponents. Angular proporciona el servei <code>ActivatedRoute</code> per accedir als paràmetres.</p>
<p>El servei <code>ActivatedRoute</code> representa la ruta activa i proporciona accés a:</p>
<ul>
<li><code>paramMap</code>: Mapa de route params (<code>:id</code>, <code>:nomUsuari</code>, etc.)</li>
<li><code>queryParamMap</code>: Mapa de query params (<code>?categoria=3</code>, <code>?ordre=preu</code>, etc.)</li>
<li><code>snapshot</code>: Captura instantània dels paràmetres actuals</li>
<li><code>data</code>: Dades estàtiques definides a la ruta</li>
<li><code>url</code>: Segments de la URL actual</li>
</ul>
<p><strong>Injecció del servei:</strong></p>
{% capture code_95 %}import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
@Component({
  selector: 'app-detall-element',
  templateUrl: './detall-element.component.html'
})
export class DetallElementComponent implements OnInit {
  constructor(private route: ActivatedRoute) {}
  ngOnInit(): void {
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_95 %}
<h4>2.6.3. Mètode 1: Captura amb snapshot (ús més comú)</h4>
<p>El <strong>snapshot</strong> proporciona una captura instantània dels paràmetres en el moment en què el component s'inicialitza:</p>
{% capture code_96 %}ngOnInit(): void {
  const idString = this.route.snapshot.paramMap.get('id');
  const id = Number(idString);
  console.log('ID capturat:', id);
  this.service.obtenirPerID(id).subscribe(element => {
    this.element = element;
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_96 %}
<p><strong>Característiques del snapshot:</strong></p>
<ul>
<li><strong>Ràpid:</strong> Accés síncron, no requereix subscripció</li>
<li><strong>Estàtic:</strong> Captura el valor actual en el moment d'inicialització</li>
<li><strong>No reactiu:</strong> Si l'usuari navega a <code>/element/99</code> sense recarregar el component, el valor NO s'actualitza</li>
</ul>
<p><strong>Quan usar snapshot:</strong></p>
<ul>
<li>95% dels casos</li>
<li>Quan navegueu entre rutes diferents que destrueixen i creen el component de nou</li>
<li>Exemple: Navegar de <code>/element/42</code> a <code>/element/99</code> destrueix <code>DetallElementComponent</code> i el crea de nou → <code>ngOnInit()</code> s'executa de nou amb el nou ID</li>
</ul>
<h4>2.6.4. Mètode 2: Subscripció reactiva (casos especials)</h4>
<p>La <strong>subscripció a <code>paramMap</code></strong> proporciona un Observable que emet cada vegada que els paràmetres canvien:</p>
{% capture code_97 %}ngOnInit(): void {
  this.route.paramMap.subscribe(params => {
    const idString = params.get('id');
    const id = Number(idString);
    console.log('ID ha canviat a:', id);
    this.service.obtenirPerID(id).subscribe(element => {
      this.element = element;
    });
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_97 %}
<p><strong>Característiques de la subscripció:</strong></p>
<ul>
<li><strong>Reactiu:</strong> S'executa cada vegada que l'ID canvia</li>
<li><strong>Continu:</strong> L'Observable emet múltiples vegades durant la vida del component</li>
<li><strong>Requereix cleanup:</strong> Cal fer <code>unsubscribe()</code> a <code>ngOnDestroy()</code> per evitar memory leaks</li>
</ul>
<p><strong>Quan usar subscripció:</strong></p>
<ul>
<li>Casos especials on Angular reutilitza el mateix component amb diferent ID</li>
<li>Rutes niades complexes on només canvia el paràmetre sense destruir el component</li>
<li>Exemple: Navegació dins d'un component pare que no es destrueix</li>
</ul>
<h4>2.6.5. Comparativa: Snapshot vs Subscribe</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Snapshot</th>
<th>Subscribe</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Sintaxi</strong></td>
<td><code>route.snapshot.paramMap.get('id')</code></td>
<td><code>route.paramMap.subscribe(params => ...)</code></td>
</tr>
<tr>
<td><strong>Tipus de retorn</strong></td>
<td><code>string | null</code> (síncron)</td>
<td><code>Observable&lt;ParamMap&gt;</code> (asíncron)</td>
</tr>
<tr>
<td><strong>Reacciona a canvis</strong></td>
<td>No</td>
<td>Sí</td>
</tr>
<tr>
<td><strong>Requereix unsubscribe</strong></td>
<td>No</td>
<td>Sí (bona pràctica)</td>
</tr>
<tr>
<td><strong>Ús recomanat</strong></td>
<td>95% dels casos</td>
<td>Casos especials amb reutilització de component</td>
</tr>
<tr>
<td><strong>Complexitat</strong></td>
<td>Baixa</td>
<td>Mitjana (cal gestionar Observable)</td>
</tr>
</tbody>
</table>
<h4>2.6.6. Exemple complet: Captura amb validació</h4>
{% capture code_98 %}import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { ElementsService } from '../services/elements.service';
import { Element } from '../models/element.interface';
@Component({
  selector: 'app-detall-element',
  templateUrl: './detall-element.component.html'
})
export class DetallElementComponent implements OnInit {
  element?: Element;
  carregant = true;
  error = false;
  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private service: ElementsService
  ) {}
  ngOnInit(): void {
    const idString = this.route.snapshot.paramMap.get('id');
    if (!idString) {
      this.router.navigate(['/error']);
      return;
    }
    const id = Number(idString);
    if (isNaN(id) || id <= 0) {
      this.router.navigate(['/error']);
      return;
    }
    this.service.obtenirPerID(id).subscribe({
      next: (element) => {
        this.element = element;
        this.carregant = false;
      },
      error: (err) => {
        console.error('Error al carregar element:', err);
        this.error = true;
        this.carregant = false;
      }
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_98 %}
<h4>2.6.7. Capturar múltiples paràmetres</h4>
<p>Si la ruta té múltiples paràmetres (<code>/categoria/:nomCategoria/element/:id</code>), captureu-los individualment:</p>
{% capture code_99 %}ngOnInit(): void {
  const categoria = this.route.snapshot.paramMap.get('nomCategoria');
  const idString = this.route.snapshot.paramMap.get('id');
  const id = Number(idString);
  console.log(`Carregant element ${id} de la categoria ${categoria}`);
  this.service.obtenirPerCategoriaIID(categoria!, id).subscribe(...);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_99 %}
<h4>2.6.8. Unsubscribe en subscripcions (bona pràctica)</h4>
<p>Si useu <code>paramMap.subscribe()</code>, cal fer unsubscribe per evitar memory leaks:</p>
{% capture code_100 %}import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
export class DetallElementComponent implements OnInit, OnDestroy {
  private paramsSub?: Subscription;
  ngOnInit(): void {
    this.paramsSub = this.route.paramMap.subscribe(params => {
      const id = Number(params.get('id'));
    });
  }
  ngOnDestroy(): void {
    this.paramsSub?.unsubscribe();
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_100 %}
<p><strong>Nota:</strong> Amb <code>snapshot</code>, NO cal unsubscribe perquè no hi ha Observable.</p>
{% include success_box.html contingut="<strong>Clau:</strong> Per capturar paràmetres de ruta, useu <code>ActivatedRoute.snapshot.paramMap.get('nom')</code> en el 95% dels casos. Si necessiteu reactivitat (el component es reutilitza amb diferent ID), useu <code>paramMap.subscribe()</code> i feu unsubscribe a <code>ngOnDestroy()</code>. Sempre valideu i convertiu els paràmetres (són strings)." %}
<h4>2.6.9. Resultat esperat</h4>
<p>Sabeu capturar paràmetres de ruta amb <code>snapshot</code> i <code>subscribe</code>, enteneu les diferències entre ambdós mètodes, i sabeu validar i convertir paràmetres abans d'usar-los.</p>
  {% endcapture %}
  {% include section-point.html numero="2.6" titol="Capturar paràmetres al component: subscriure's a canvis" contingut=section_point_2_6 %}

  {% capture section_point_2_7 %}
<h4>2.7.1. Objectiu</h4>
<p>Implementar un component de detall complet que captura l'ID de la ruta i carrega les dades corresponents de l'API.</p>
<h4>2.7.2. Pas 1: Definir la ruta amb paràmetre</h4>
<p><code>src/app/navegacio/app.routes.ts</code>:</p>
{% capture code_101 %}import { Routes } from '@angular/router';
import { CatalegComponent } from '../cataleg/cataleg.component';
import { DetallElementComponent } from '../cataleg/detall-element.component';
export const routes: Routes = [
  { path: '', redirectTo: '/cataleg', pathMatch: 'full' },
  { path: 'cataleg', component: CatalegComponent },
  { path: 'element/:id', component: DetallElementComponent }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_101 %}
<h4>2.7.3. Pas 2: Crear el component de detall</h4>
<p><strong>PowerShell (Windows):</strong></p>
{% capture code_102 %}Set-Location $env:USERPROFILE\workspace\catalog-elements
ng generate component cataleg/detall-element --skip-tests{% endcapture %}
{% include code-block.html lang="powershell" code=code_102 %}
<p><strong>bash/zsh (macOS/Linux):</strong></p>
{% capture code_103 %}cd ~/workspace/catalog-elements
ng generate component cataleg/detall-element --skip-tests{% endcapture %}
{% include code-block.html lang="bash" code=code_103 %}
<h4>2.7.4. Pas 3: Implementar la lògica del component</h4>
<p><code>src/app/cataleg/detall-element.component.ts</code>:</p>
{% capture code_104 %}import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { ElementsService } from '../services/elements.service';
import { Element } from '../models/element.interface';
@Component({
  selector: 'app-detall-element',
  standalone: true,
  imports: [CommonModule, RouterLink],
  templateUrl: './detall-element.component.html',
  styleUrls: ['./detall-element.component.scss']
})
export class DetallElementComponent implements OnInit {
  element?: Element;
  carregant = true;
  error = false;
  missatgeError = '';
  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private service: ElementsService
  ) {}
  ngOnInit(): void {
    const idString = this.route.snapshot.paramMap.get('id');
    if (!idString) {
      this.router.navigate(['/cataleg']);
      return;
    }
    const id = Number(idString);
    if (isNaN(id) || id <= 0) {
      this.error = true;
      this.missatgeError = 'ID d\'element invàlid';
      this.carregant = false;
      return;
    }
    this.service.obtenirPerID(id).subscribe({
      next: (element) => {
        this.element = element;
        this.carregant = false;
      },
      error: (err) => {
        console.error('Error al carregar element:', err);
        this.error = true;
        this.missatgeError = 'No s\'ha pogut carregar l\'element';
        this.carregant = false;
      }
    });
  }
  tornarAlCataleg(): void {
    this.router.navigate(['/cataleg']);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_104 %}
<h4>2.7.5. Pas 4: Implementar la plantilla HTML</h4>
<p><code>src/app/cataleg/detall-element.component.html</code>:</p>
{% capture code_105 %}{% raw %}<div class="detall-element">
<div *ngIf="carregant" class="carregant">
<p>Carregant element...</p>
</div>
<div *ngIf="error" class="error">
<h2>Error</h2>
<p>{{ missatgeError }}</p>
<button (click)="tornarAlCataleg()">Tornar al catàleg</button>
</div>
<div *ngIf="!carregant && !error && element" class="contingut">
<button (click)="tornarAlCataleg()" class="btn-tornar">← Tornar</button>
<div class="informacio">
<h1>{{ element.title }}</h1>
<div class="descripcio">
<p>{{ element.body }}</p>
</div>
<div class="metadades">
<p><strong>ID:</strong> {{ element.id }}</p>
<p><strong>Usuari:</strong> {{ element.userId }}</p>
</div>
<div class="accions">
<button class="btn-primari">Afegir a preferits</button>
<button class="btn-secundari">Compartir</button>
</div>
</div>
</div>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_105 %}
<h4>2.7.6. Pas 5: Afegir enllaços al catàleg</h4>
<p>Modifiqueu el component de catàleg per navegar al detall:</p>
<p><code>src/app/cataleg/cataleg.component.html</code>:</p>
{% capture code_106 %}{% raw %}<div class="cataleg">
<h1>Catàleg d'elements</h1>
<div class="llista" *ngIf="elements$ | async as elements">
<div class="targeta" *ngFor="let element of elements">
<h3>{{ element.title }}</h3>
<p>{{ element.body | slice:0:100 }}...</p>
<a [routerLink]="['/element', element.id]" class="btn-veure-mes">
Veure detall →
</a>
</div>
</div>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_106 %}
<h4>2.7.7. Pas 6: Verificar el funcionament</h4>
<ol>
<li><strong>Executar l'aplicació:</strong></li>
</ol>
{% capture code_107 %}ng serve --port 4300{% endcapture %}
{% include code-block.html lang="bash" code=code_107 %}
<ol start="2">
<li><strong>Obrir al navegador:</strong> <code>http://localhost:4300/cataleg</code></li>
<li><strong>Clicar un element:</strong> La URL canvia a <code>/element/1</code> (o l'ID que sigui)</li>
<li><strong>Comprovar que es carrega el detall:</strong> Heu de veure la informació completa de l'element</li>
<li><strong>Provar amb diferents IDs:</strong> Navegar directament a <code>/element/5</code>, <code>/element/99</code>, etc.</li>
<li><strong>Provar ID invàlid:</strong> Navegar a <code>/element/abc</code> → Ha de mostrar error</li>
<li><strong>Comprovar el botó "Tornar":</strong> Ha de navegar de tornada a <code>/cataleg</code></li>
</ol>
{% include success_box.html contingut="<strong>Clau:</strong> Un component de detall captura l'ID de la ruta amb <code>ActivatedRoute</code>, valida el paràmetre, carrega les dades de l'API i les mostra. La navegació des del llistat utilitza <code>[routerLink]=\"['/element', element.id]\"</code> per passar l'ID dinàmicament." %}
<h4>2.7.8. Resultat esperat</h4>
<p>Sabeu implementar un component de detall complet que captura paràmetres de ruta, els valida, carrega dades i mostra errors apropiats. El flux llistat → detall → tornar funciona correctament amb navegació dinàmica.</p>
  {% endcapture %}
  {% include section-point.html numero="2.7" titol="Exemple pràctic: vista de detall que rep identificador" contingut=section_point_2_7 %}

  {% capture section_point_2_8 %}
<h4>2.8.1. Objectiu</h4>
<p>Aprendre a utilitzar query params per a paràmetres opcionals com filtres, cerca i paginació, i entendre quan preferir-los per sobre dels route params.</p>
<h4>2.8.2. Sintaxi de query params</h4>
<p>Els <strong>query params</strong> són paràmetres opcionals que s'afegeixen a la URL després d'un símbol <code>?</code>. A diferència dels route params (<code>:id</code>), els query params NO són part del <code>path</code> de la ruta i NO són obligatoris. Són ideals per a filtres, cerca, ordenació i paginació.</p>
<p><strong>Exemple d'URL amb query params:</strong></p>
{% capture code_108 %}/cataleg?categoria=electrònica&preu_max=500&ordre=popularitat{% endcapture %}
{% include code-block.html lang="text" code=code_108 %}
<p><strong>Estructura:</strong></p>
<ul>
<li><code>/cataleg</code> - Ruta base</li>
<li><code>?</code> - Indica inici de query params</li>
<li><code>categoria=electrònica</code> - Primer paràmetre</li>
<li><code>&</code> - Separador entre paràmetres</li>
<li><code>preu_max=500</code> - Segon paràmetre</li>
<li><code>&ordre=popularitat</code> - Tercer paràmetre</li>
</ul>
<h4>2.8.3. Passar query params amb routerLink</h4>
<p><strong>Enllaç HTML amb query params:</strong></p>
{% capture code_109 %}{% raw %}<a [routerLink]="['/cataleg']" [queryParams]="{ categoria: 'electrònica', ordre: 'preu' }">
  Electrònica ordenada per preu
</a>
<a [routerLink]="['/cataleg']" [queryParams]="{ categoria: categoriaSeleccionada, pàgina: pàginaActual }">
  Filtrar per categoria
</a>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_109 %}
<p><strong>Resultat:</strong> Navega a <code>/cataleg?categoria=electrònica&ordre=preu</code></p>
<h4>2.8.4. Capturar query params al component</h4>
<p>Similar als route params, useu <code>ActivatedRoute</code> però amb <code>queryParamMap</code>:</p>
{% capture code_110 %}import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
@Component({
  selector: 'app-cataleg',
  templateUrl: './cataleg.component.html'
})
export class CatalegComponent implements OnInit {
  constructor(private route: ActivatedRoute) {}
  ngOnInit(): void {
    const categoria = this.route.snapshot.queryParamMap.get('categoria');
    const preuMax = this.route.snapshot.queryParamMap.get('preu_max');
    const ordre = this.route.snapshot.queryParamMap.get('ordre');
    console.log('Filtres aplicats:', { categoria, preuMax, ordre });
    this.carregarElements({
      categoria: categoria ?? 'totes',
      preuMax: preuMax ? Number(preuMax) : undefined,
      ordre: ordre ?? 'data'
    });
  }
  carregarElements(filtres: any): void {
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_110 %}
<h4>2.8.5. Subscripció reactiva a query params</h4>
<p>Si voleu reaccionar a canvis de query params sense recarregar el component:</p>
{% capture code_111 %}ngOnInit(): void {
  this.route.queryParamMap.subscribe(params => {
    const categoria = params.get('categoria') ?? 'totes';
    const ordre = params.get('ordre') ?? 'data';
    console.log('Query params han canviat:', { categoria, ordre });
    this.carregarElements({ categoria, ordre });
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_111 %}
<p><strong>Cas d'ús:</strong> L'usuari canvia filtres sense navegar a una nova pàgina. Els query params canvien (<code>/cataleg?categoria=llibres</code> → <code>/cataleg?categoria=música</code>) però el component <code>CatalegComponent</code> no es destrueix. La subscripció detecta el canvi i recarrega els elements.</p>
<h4>2.8.6. Navegació programàtica amb query params</h4>
<p>Des de codi TypeScript, utilitzeu <code>Router.navigate()</code> amb <code>queryParams</code>:</p>
{% capture code_112 %}import { Router } from '@angular/router';
constructor(private router: Router) {}
aplicarFiltres(): void {
  this.router.navigate(['/cataleg'], {
    queryParams: {
      categoria: this.categoriaSeleccionada,
      preu_max: this.preuMaxim,
      ordre: 'preu'
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_112 %}
<p><strong>Resultat:</strong> Navega a <code>/cataleg?categoria=electrònica&preu_max=500&ordre=preu</code></p>
<h4>2.8.7. Exemple pràctic: Filtre de catàleg amb query params</h4>
<p><code>src/app/cataleg/cataleg.component.ts</code>:</p>
{% capture code_113 %}import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { ElementsService } from '../services/elements.service';
import { Element } from '../models/element.interface';
@Component({
  selector: 'app-cataleg',
  templateUrl: './cataleg.component.html'
})
export class CatalegComponent implements OnInit {
  elements: Element[] = [];
  categoriaActual = 'totes';
  ordreActual = 'data';
  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private service: ElementsService
  ) {}
  ngOnInit(): void {
    this.route.queryParamMap.subscribe(params => {
      this.categoriaActual = params.get('categoria') ?? 'totes';
      this.ordreActual = params.get('ordre') ?? 'data';
      this.carregarElements();
    });
  }
  carregarElements(): void {
    this.service.obtenirTots().subscribe(elements => {
      let resultats = elements;
      if (this.categoriaActual !== 'totes') {
        resultats = resultats.filter(e => e.categoria === this.categoriaActual);
      }
      if (this.ordreActual === 'preu') {
        resultats.sort((a, b) => a.preu - b.preu);
      } else {
        resultats.sort((a, b) => b.data.getTime() - a.data.getTime());
      }
      this.elements = resultats;
    });
  }
  canviarCategoria(categoria: string): void {
    this.router.navigate(['/cataleg'], {
      queryParams: { categoria, ordre: this.ordreActual }
    });
  }
  canviarOrdre(ordre: string): void {
    this.router.navigate(['/cataleg'], {
      queryParams: { categoria: this.categoriaActual, ordre }
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_113 %}
<p><code>src/app/cataleg/cataleg.component.html</code>:</p>
{% capture code_114 %}{% raw %}<div class="cataleg">
<h1>Catàleg d'elements</h1>
<div class="filtres">
<div class="filtre-grup">
<label>Categoria:</label>
<button (click)="canviarCategoria('totes')" [class.actiu]="categoriaActual === 'totes'">
Totes
</button>
<button (click)="canviarCategoria('electrònica')" [class.actiu]="categoriaActual === 'electrònica'">
Electrònica
</button>
<button (click)="canviarCategoria('llibres')" [class.actiu]="categoriaActual === 'llibres'">
Llibres
</button>
</div>
<div class="filtre-grup">
<label>Ordenar per:</label>
<button (click)="canviarOrdre('data')" [class.actiu]="ordreActual === 'data'">
Data
</button>
<button (click)="canviarOrdre('preu')" [class.actiu]="ordreActual === 'preu'">
Preu
</button>
</div>
</div>
<div class="llista">
<div class="targeta" *ngFor="let element of elements">
<h3>{{ element.title }}</h3>
<p>{{ element.body }}</p>
<a [routerLink]="['/element', element.id]">Veure detall</a>
</div>
</div>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_114 %}
<h4>2.8.8. Quan usar query params vs route params</h4>
<table>
<thead>
<tr>
<th>Situació</th>
<th>Tipus recomanat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>Identificar un recurs únic (obligatori)</td>
<td>Route param</td>
<td><code>/element/:id</code></td>
</tr>
<tr>
<td>Filtrar resultats (opcional)</td>
<td>Query param</td>
<td><code>/cataleg?categoria=3</code></td>
</tr>
<tr>
<td>Cerca (opcional)</td>
<td>Query param</td>
<td><code>/cerca?q=angular</code></td>
</tr>
<tr>
<td>Paginació (opcional)</td>
<td>Query param</td>
<td><code>/blog?pàgina=2</code></td>
</tr>
<tr>
<td>Ordenació (opcional)</td>
<td>Query param</td>
<td><code>/productes?ordre=preu</code></td>
</tr>
<tr>
<td>Vista detall amb categoria (obligatòria)</td>
<td>Route param</td>
<td><code>/categoria/:nom/element/:id</code></td>
</tr>
</tbody>
</table>
<p><strong>Regla:</strong> Si és obligatori per renderitzar la vista → route param. Si és opcional i la vista té estat per defecte → query param.</p>
{% include success_box.html contingut="<strong>Clau:</strong> Els query params són ideals per a filtres, cerca, paginació i ordenació opcionals. S'afegeixen amb <code>[queryParams]</code> en enllaços HTML o <code>{ queryParams }</code> en navegació programàtica. Es capturen amb <code>queryParamMap.get('nom')</code>. A diferència dels route params, els query params NO afecten la coincidència de rutes i són sempre opcionals." %}
<h4>2.8.9. Resultat esperat</h4>
<p>Sabeu utilitzar query params per a paràmetres opcionals, enteneu quan preferir-los per sobre dels route params, i sabeu implementar filtres i ordenació amb query params que persisteixen a la URL i són compartibles.</p>
  {% endcapture %}
  {% include section-point.html numero="2.8" titol="Paràmetres opcionals (query params): quan usar-los" contingut=section_point_2_8 %}

  {% capture section_point_2_9 %}
<h4>2.9.1. Objectiu</h4>
<p>Dominar la navegació programàtica amb el servei <code>Router</code> per navegar des de codi TypeScript després de validacions, operacions asíncrones o lògica condicional.</p>
<h4>2.9.2. Servei Router: navegació des de TypeScript</h4>
<p>La <strong>navegació programàtica</strong> permet navegar entre vistes des de codi TypeScript, no només amb enllaços HTML (<code>&lt;a routerLink&gt;</code>). Això és essencial per navegar després de validacions, operacions asíncrones (guardar dades, autenticar usuari) o lògica condicional (redirigir segons el rol).</p>
<p>El servei <code>Router</code> proporciona mètodes per navegar programàticament:</p>
{% capture code_115 %}import { Component } from '@angular/core';
import { Router } from '@angular/router';
@Component({
  selector: 'app-exemple',
  templateUrl: './exemple.component.html'
})
export class ExempleComponent {
  constructor(private router: Router) {}
  navegarAlCataleg(): void {
    this.router.navigate(['/cataleg']);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_115 %}
<h4>2.9.3. Sintaxi de navigate: array de segments</h4>
<p>El mètode <code>navigate()</code> accepta un array de segments de la URL:</p>
{% capture code_116 %}this.router.navigate(['/cataleg']);
this.router.navigate(['/element', 42]);
this.router.navigate(['/categoria', 'electrònica', 'element', 99]);{% endcapture %}
{% include code-block.html lang="typescript" code=code_116 %}
<p><strong>Important:</strong> Els segments es concatenen amb <code>/</code> automàticament. NO cal afegir barres manuals.</p>
<h4>2.9.4. Navegació amb query params</h4>
<p>Afegiu query params amb l'objecte <code>NavigationExtras</code>:</p>
{% capture code_117 %}this.router.navigate(['/cataleg'], {
  queryParams: { categoria: 'electrònica', ordre: 'preu' }
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_117 %}
<h4>2.9.5. Casos d'ús reals de navegació programàtica</h4>
<p><strong>1. Navegar després de validar un formulari:</strong></p>
{% capture code_118 %}crearElement(formulari: FormGroup): void {
  if (formulari.invalid) {
    alert('Formulari invàlid');
    return;
  }
  this.service.crear(formulari.value).subscribe({
    next: (elementCreat) => {
      this.router.navigate(['/element', elementCreat.id]);
    },
    error: (err) => {
      alert('Error al crear element');
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_118 %}
<p><strong>2. Redirecció condicional segons el rol de l'usuari:</strong></p>
{% capture code_119 %}iniciarSessio(credencials): void {
  this.authService.login(credencials).subscribe({
    next: (usuari) => {
      if (usuari.rol === 'admin') {
        this.router.navigate(['/admin-panel']);
      } else {
        this.router.navigate(['/cataleg']);
      }
    }
  });
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_119 %}
<p><strong>3. Navegar automàticament després d'uns segons:</strong></p>
{% capture code_120 %}confirmarAccio(): void {
  alert('Acció completada!');
  setTimeout(() => {
    this.router.navigate(['/inici']);
  }, 3000);
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_120 %}
<p><strong>4. Navegar amb estat temporal (no visible a la URL):</strong></p>
{% capture code_121 %}veureDetall(element: Element): void {
  this.router.navigate(['/detall'], {
    state: { element: element }
  });
}
constructor(private router: Router) {
  const navigation = this.router.getCurrentNavigation();
  const state = navigation?.extras.state as { element: Element };
  this.element = state?.element;
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_121 %}
<p><strong>Avantatge:</strong> Les dades NO apareixen a la URL (més netes).<br><strong>Desavantatge:</strong> Si l'usuari recarrega la pàgina (F5), les dades es perden.</p>
<h4>2.9.6. NavigationExtras: opcions avançades</h4>
<p>L'objecte <code>NavigationExtras</code> proporciona opcions addicionals per a la navegació:</p>
{% capture code_122 %}this.router.navigate(['/element', 42], {
  queryParams: { vista: 'detallada' },
  fragment: 'seccio-comentaris',
  state: { origen: 'cataleg' },
  replaceUrl: true,
  skipLocationChange: true
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_122 %}
<p><strong>Opcions més usades:</strong></p>
<ul>
<li><code>queryParams</code>: Afegir query params</li>
<li><code>fragment</code>: Afegir fragment (scroll a secció)</li>
<li><code>state</code>: Passar dades temporals</li>
<li><code>replaceUrl: true</code>: Substituir la URL actual en lloc d'afegir una nova entrada a l'historial (útil per redireccions)</li>
</ul>
<h4>2.9.7. Navegació relativa</h4>
<p>Podeu navegar relativament a la ruta actual:</p>
{% capture code_123 %}this.router.navigate(['../germanà'], { relativeTo: this.route });
this.router.navigate(['./fill'], { relativeTo: this.route });{% endcapture %}
{% include code-block.html lang="typescript" code=code_123 %}
<p><strong>Exemple:</strong> Esteu a <code>/categoria/electrònica/element/42</code>. Navegar a <code>../element/99</code> genera <code>/categoria/electrònica/element/99</code>.</p>
<h4>2.9.8. Diferència entre navigate i navigateByUrl</h4>
<p>Angular ofereix dos mètodes per navegar:</p>
<p><strong>1. <code>navigate(['/segment', param])</code></strong> - Array de segments (recomanat)</p>
{% capture code_124 %}this.router.navigate(['/element', 42]);{% endcapture %}
{% include code-block.html lang="typescript" code=code_124 %}
<p><strong>2. <code>navigateByUrl('/url/completa')</code></strong> - String complet</p>
{% capture code_125 %}this.router.navigateByUrl('/element/42');{% endcapture %}
{% include code-block.html lang="typescript" code=code_125 %}
<p><strong>Recomanació:</strong> Useu <code>navigate()</code> amb array de segments. És més segur (Angular escapa caràcters especials automàticament) i més llegible.</p>
{% include success_box.html contingut="<strong>Clau:</strong> La navegació programàtica amb <code>Router.navigate()</code> permet navegar des de codi TypeScript després de validacions, operacions asíncrones o lògica condicional. Accepta arrays de segments, query params, estat temporal i opcions avançades. És essencial per fluxos d'usuari sofisticats on la navegació depèn de condicions dinàmiques." %}
<h4>2.9.9. Resultat esperat</h4>
<p>Domineu la navegació programàtica amb <code>Router</code>, sabeu navegar amb paràmetres i query params des de codi, i enteneu casos d'ús reals com navegar després de validar formularis, redirigir segons el rol o passar dades temporals amb <code>state</code>.</p>
  {% endcapture %}
  {% include section-point.html numero="2.9" titol="Navegació programàtica: des de codi, no només enllaços" contingut=section_point_2_9 %}

  {% capture section_point_2_10 %}
<h4>2.10.1. Objectiu</h4>
<p>Aprendre a passar dades temporals entre components durant la navegació sense exposar-les a la URL, utilitzant <code>Router state</code>.</p>
<h4>2.10.2. Per què necessitem Router state</h4>
<p>Fins ara hem passat informació entre vistes amb paràmetres de ruta (<code>:id</code>) i query params (<code>?categoria=3</code>). Però aquests mètodes exposen les dades a la URL, que és problemàtic per:</p>
<ul>
<li>Dades sensibles (tokens, informació personal)</li>
<li>Objectes complexos (molt grans per a la URL)</li>
<li>Informació temporal que només és rellevant durant una navegació (missatges de confirmació)</li>
</ul>
<p>El <strong>Router state</strong> permet passar dades temporals que NO apareixen a la URL.</p>
<h4>2.10.3. Passar dades amb Router state</h4>
<p>Utilitzeu l'opció <code>state</code> en la navegació:</p>
{% capture code_126 %}this.router.navigate(['/confirmacio'], {
  state: {
    comanda: { id: 42, productes: [...], total: 350 },
    missatge: 'Comanda realitzada correctament'
  }
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_126 %}
<p><strong>Resultat:</strong> L'usuari veu la URL neta <code>/confirmacio</code>, però les dades viatgen amb la navegació.</p>
<h4>2.10.4. Capturar l'estat al component destí</h4>
<p>El component destí captura l'estat amb <code>getCurrentNavigation()</code>:</p>
{% capture code_127 %}import { Component } from '@angular/core';
import { Router } from '@angular/router';
@Component({
  selector: 'app-confirmacio',
  templateUrl: './confirmacio.component.html'
})
export class ConfirmacioComponent {
  comanda?: any;
  missatge = '';
  constructor(private router: Router) {
    const navigation = this.router.getCurrentNavigation();
    const state = navigation?.extras.state as { comanda: any, missatge: string };
    if (state) {
      this.comanda = state.comanda;
      this.missatge = state.missatge;
    } else {
      this.router.navigate(['/cataleg']);
    }
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_127 %}
<p><strong>Important:</strong> <code>getCurrentNavigation()</code> només funciona al constructor. A <code>ngOnInit()</code> ja no està disponible.</p>
<h4>2.10.5. Exemple pràctic: Confirmació després de crear element</h4>
<p><strong>Component origen (crear-element):</strong></p>
{% capture code_128 %}import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { ElementsService } from '../services/elements.service';
@Component({
  selector: 'app-crear-element',
  templateUrl: './crear-element.component.html'
})
export class CrearElementComponent {
  constructor(
    private router: Router,
    private service: ElementsService
  ) {}
  crear(dades: any): void {
    this.service.crear(dades).subscribe({
      next: (elementCreat) => {
        this.router.navigate(['/confirmacio'], {
          state: {
            element: elementCreat,
            missatge: `Element "${elementCreat.title}" creat correctament`,
            accio: 'crear'
          }
        });
      }
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_128 %}
<p><strong>Component destí (confirmacio):</strong></p>
{% capture code_129 %}import { Component } from '@angular/core';
import { Router, RouterLink } from '@angular/router';
import { CommonModule } from '@angular/common';
interface NavigationState {
  element: any;
  missatge: string;
  accio: string;
}
@Component({
  selector: 'app-confirmacio',
  standalone: true,
  imports: [CommonModule, RouterLink],
  templateUrl: './confirmacio.component.html'
})
export class ConfirmacioComponent {
  element?: any;
  missatge = '';
  accio = '';
  constructor(private router: Router) {
    const navigation = this.router.getCurrentNavigation();
    const state = navigation?.extras.state as NavigationState;
    if (state) {
      this.element = state.element;
      this.missatge = state.missatge;
      this.accio = state.accio;
    } else {
      console.warn('Accés directe a /confirmacio sense estat');
      this.router.navigate(['/cataleg']);
    }
  }
  veureElement(): void {
    if (this.element) {
      this.router.navigate(['/element', this.element.id]);
    }
  }
  tornarAlCataleg(): void {
    this.router.navigate(['/cataleg']);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_129 %}
<h4>2.10.6. Avantatges i limitacions del Router state</h4>
<p><strong>Avantatges:</strong></p>
<ul>
<li><strong>URLs netes:</strong> Les dades NO apareixen a la URL</li>
<li><strong>Seguretat:</strong> Informació sensible no és visible ni compartible</li>
<li><strong>Objectes complexos:</strong> Podeu passar objectes grans sense límits de longitud de URL</li>
</ul>
<p><strong>Limitacions:</strong></p>
<ul>
<li><strong>No persistent:</strong> Si l'usuari recarrega la pàgina (F5), les dades es perden</li>
<li><strong>No compartible:</strong> No podeu copiar la URL per compartir-la amb les dades</li>
<li><strong>No marcable:</strong> No podeu afegir la pàgina als favorits amb l'estat</li>
</ul>
<p><strong>Quan usar Router state:</strong></p>
<ul>
<li>Confirmacions temporals després d'accions (crear, editar, eliminar)</li>
<li>Passar objectes grans entre components</li>
<li>Informació sensible que no ha d'exposar-se (tokens temporals, no passwords!)</li>
</ul>
<p><strong>Quan NO usar Router state:</strong></p>
<ul>
<li>Informació que ha de persistir si l'usuari recarrega (usar route/query params)</li>
<li>Dades que volen compartir-se (usar route/query params)</li>
<li>Navegació directa a URLs (l'estat no estarà disponible)</li>
</ul>
<h4>2.10.7. Comparativa: Route params vs Query params vs Router state</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Route params</th>
<th>Query params</th>
<th>Router state</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Visibilitat a la URL</strong></td>
<td>Sí (<code>/element/42</code>)</td>
<td>Sí (<code>?categoria=3</code>)</td>
<td>No</td>
</tr>
<tr>
<td><strong>Persistent amb recàrrega</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No (es perd)</td>
</tr>
<tr>
<td><strong>Compartible</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Marcable</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Longitud límit</strong></td>
<td>Sí (~2000 caràcters)</td>
<td>Sí (~2000 caràcters)</td>
<td>No</td>
</tr>
<tr>
<td><strong>Ús típic</strong></td>
<td>Identificadors obligatoris</td>
<td>Filtres opcionals</td>
<td>Dades temporals</td>
</tr>
<tr>
<td><strong>Exemple</strong></td>
<td><code>/element/:id</code></td>
<td><code>/cataleg?ordre=preu</code></td>
<td>Confirmació després de crear</td>
</tr>
</tbody>
</table>
{% include success_box.html contingut="<strong>Clau:</strong> Router state permet passar dades temporals entre components sense exposar-les a la URL. És ideal per confirmacions, objectes grans i informació sensible. Les dades es perden si l'usuari recarrega la pàgina. S'accedeix amb <code>router.getCurrentNavigation()</code> al constructor del component destí." %}
<h4>2.10.8. Resultat esperat</h4>
<p>Sabeu passar dades temporals amb Router state, enteneu les diferències respecte a route params i query params, i sabeu implementar pàgines de confirmació que reben dades sense exposar-les a la URL.</p>
  {% endcapture %}
  {% include section-point.html numero="2.10" titol="Passar dades durant la navegació: estat temporal" contingut=section_point_2_10 %}

  {% capture section_point_2_11 %}
<h4>2.11.1. Objectiu</h4>
<p>Consolidar el coneixement sobre les tres estratègies per passar informació entre vistes i saber escollir la més adequada segons el cas d'ús.</p>
<h4>2.11.2. Les tres estratègies</h4>
<p>Hem après tres maneres de passar informació entre vistes. Cada una té casos d'ús específics:</p>
<p><strong>1. Route params (<code>:id</code>) - Identificadors obligatoris</strong></p>
<p><strong>Característiques:</strong></p>
<ul>
<li>Obligatoris (la ruta no coincideix sense ells)</li>
<li>Visibles a la URL: <code>/element/42</code></li>
<li>Persistents (recarregar/compartir/marcar funciona)</li>
<li>Definició: <code>path: 'element/:id'</code></li>
</ul>
<p><strong>Ús ideal:</strong></p>
<ul>
<li>Identificadors únics de recursos (ID, slug, nom d'usuari)</li>
<li>Informació essencial sense la qual la pàgina no té sentit</li>
</ul>
<p><strong>Exemples:</strong></p>
<ul>
<li><code>/element/42</code> - Detall d'element amb ID 42</li>
<li><code>/usuari/maria</code> - Perfil de l'usuària Maria</li>
<li><code>/categoria/electrònica/element/99</code> - Element 99 de la categoria electrònica</li>
</ul>
<p><strong>Captura:</strong></p>
{% capture code_130 %}const id = Number(this.route.snapshot.paramMap.get('id'));{% endcapture %}
{% include code-block.html lang="typescript" code=code_130 %}
<p><strong>2. Query params (<code>?clau=valor</code>) - Paràmetres opcionals</strong></p>
<p><strong>Característiques:</strong></p>
<ul>
<li>Opcionals (la pàgina funciona sense ells, amb valors per defecte)</li>
<li>Visibles a la URL: <code>/cataleg?categoria=3&ordre=preu</code></li>
<li>Persistents (recarregar/compartir/marcar funciona)</li>
<li>Afegits amb <code>[queryParams]</code> o <code>{ queryParams }</code></li>
</ul>
<p><strong>Ús ideal:</strong></p>
<ul>
<li>Filtres, cerca, ordenació, paginació</li>
<li>Opcions de visualització (vista llista vs quadrícula)</li>
<li>Qualsevol configuració opcional</li>
</ul>
<p><strong>Exemples:</strong></p>
<ul>
<li><code>/cataleg?categoria=electrònica&ordre=popularitat</code> - Filtrar i ordenar</li>
<li><code>/cerca?q=angular&tipus=articles</code> - Cerca amb filtre de tipus</li>
<li><code>/blog?pàgina=3&per_pàgina=10</code> - Paginació</li>
</ul>
<p><strong>Captura:</strong></p>
{% capture code_131 %}const categoria = this.route.snapshot.queryParamMap.get('categoria') ?? 'totes';
const ordre = this.route.snapshot.queryParamMap.get('ordre') ?? 'data';{% endcapture %}
{% include code-block.html lang="typescript" code=code_131 %}
<p><strong>3. Router state - Dades temporals no visibles</strong></p>
<p><strong>Característiques:</strong></p>
<ul>
<li>NO visibles a la URL (netes i segures)</li>
<li>NO persistents (es perden amb recàrrega)</li>
<li>NO compartibles ni marcables</li>
<li>Passades amb <code>{ state: { dades } }</code></li>
</ul>
<p><strong>Ús ideal:</strong></p>
<ul>
<li>Confirmacions temporals després d'accions</li>
<li>Objectes grans o complexos</li>
<li>Informació sensible que no ha d'exposar-se a la URL</li>
</ul>
<p><strong>Exemples:</strong></p>
<ul>
<li>Confirmació després de crear element (passar element creat)</li>
<li>Missatges de feedback (success/error)</li>
<li>Objectes grans que no caben a la URL</li>
</ul>
<p><strong>Passar:</strong></p>
{% capture code_132 %}this.router.navigate(['/confirmacio'], {
  state: { element: elementCreat, missatge: 'Creat correctament' }
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_132 %}
<p><strong>Captura:</strong></p>
{% capture code_133 %}const navigation = this.router.getCurrentNavigation();
const state = navigation?.extras.state as { element: any, missatge: string };{% endcapture %}
{% include code-block.html lang="typescript" code=code_133 %}
<h4>2.11.3. Arbre de decisió: Quina estratègia usar?</h4>
<pre>
1. ¿La informació és obligatòria per renderitzar la vista?
   SÍ → Route param (:id)
   NO → Continua...

2. ¿Vols que sigui compartible/marcable/persistent?
   SÍ → Query param (?clau=valor)
   NO → Continua...

3. ¿És informació temporal només rellevant durant aquesta navegació?
   SÍ → Router state ({ state })
   NO → Reconsiderar els requisits
</pre>
<h4>2.11.4. Taula resum comparativa</h4>
<table>
<thead>
<tr>
<th>Aspecte</th>
<th>Route params</th>
<th>Query params</th>
<th>Router state</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Obligatori/Opcional</strong></td>
<td>Obligatori</td>
<td>Opcional</td>
<td>Opcional</td>
</tr>
<tr>
<td><strong>Visibilitat URL</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Persistent recàrrega</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Compartible</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Longitud límit</strong></td>
<td>Sí</td>
<td>Sí</td>
<td>No</td>
</tr>
<tr>
<td><strong>Definició</strong></td>
<td><code>path: ':id'</code></td>
<td><code>[queryParams]</code></td>
<td><code>{ state }</code></td>
</tr>
<tr>
<td><strong>Captura</strong></td>
<td><code>paramMap.get()</code></td>
<td><code>queryParamMap.get()</code></td>
<td><code>getCurrentNavigation()</code></td>
</tr>
<tr>
<td><strong>Ús típic</strong></td>
<td>IDs obligatoris</td>
<td>Filtres opcionals</td>
<td>Dades temporals</td>
</tr>
</tbody>
</table>
{% include success_box.html contingut="<strong>Clau:</strong> Route params per identificadors obligatoris, query params per filtres opcionals, i Router state per dades temporals no visibles. Cada estratègia té casos d'ús específics. Sovint es combinen: route param per l'ID + query params per filtres + Router state per missatges de confirmació." %}
<h4>2.11.5. Resultat esperat</h4>
<p>Domineu les tres estratègies per passar informació entre vistes, sabeu escollir la més adequada segons els requisits (obligatori/opcional, persistent/temporal, visible/no visible), i podeu combinar-les en aplicacions complexes.</p>
  {% endcapture %}
  {% include section-point.html numero="2.11" titol="Resum: estratègies per passar informació entre vistes" contingut=section_point_2_11 %}

  {% capture section_point_2_12 %}
<h4>2.12.1. Mini exemple pràctic: Navegació amb paràmetres completa</h4>
<ol>
<li><strong>Definir ruta amb paràmetre</strong> obligatori a <code>app.routes.ts</code>: <code>path: 'element/:id'</code></li>
<li><strong>Crear component de detall</strong> que captura l'ID amb <code>ActivatedRoute.snapshot.paramMap.get('id')</code></li>
<li><strong>Validar i convertir l'ID</strong> a number, redirigir a error si és invàlid</li>
<li><strong>Carregar dades de l'API</strong> utilitzant l'ID capturat i mostrar-les al template</li>
<li><strong>Afegir enllaços al llistat</strong> amb <code>[routerLink]="['/element', element.id]"</code> per navegar dinàmicament</li>
<li><strong>Implementar filtres amb query params</strong> al catàleg: <code>?categoria=electrònica&ordre=preu</code></li>
<li><strong>Afegir navegació programàtica</strong> després de crear un element: <code>this.router.navigate(['/element', id])</code></li>
<li><strong>Passar dades temporals amb state</strong> a pàgina de confirmació sense exposar-les a la URL</li>
</ol>
<p><strong>Resultat esperat:</strong> Flux complet llistat → detall funcional, filtres persistents a la URL compartibles/marcables, navegació automàtica després d'operacions, i confirmacions amb dades temporals no visibles.</p>
  {% endcapture %}
  {% include section-point.html numero="2.12" titol="Mini exemple pràctic" contingut=section_point_2_12 %}

  {% capture section_point_2_13 %}
<h4>2.13.1. Problemes transversals</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució Windows</th>
<th>Solució macOS/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ruta amb paràmetre retorna 404</td>
<td>Definició incorrecta del path</td>
<td>Verificar <code>path: 'element/:id'</code> (amb dos punts). NO <code>path: 'element/{id}'</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>paramMap.get() retorna null</td>
<td>Nom del paràmetre incorrecte</td>
<td>Assegurar que <code>paramMap.get('id')</code> coincideix amb <code>:id</code> del path</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Component no es recarrega amb nou ID</td>
<td>Usar snapshot en lloc de subscribe</td>
<td>Si Angular reutilitza el component, usar <code>paramMap.subscribe()</code> en lloc de snapshot</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Error "Cannot read property 'id' of null"</td>
<td>ID null passat al servei</td>
<td>Validar que l'ID existeix abans d'usar-lo: <code>if (!id) return;</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Query params no es capturen</td>
<td>Usar paramMap en lloc de queryParamMap</td>
<td>Canviar a <code>queryParamMap.get('categoria')</code> per query params</td>
<td>Igual que Windows</td>
</tr>
</tbody>
</table>
<h4>2.13.2. Problemes de configuració</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució Windows</th>
<th>Solució macOS/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rutes estàtiques mai coincideixen</td>
<td>Ordre incorrecte (dinàmica abans d'estàtica)</td>
<td>Moure rutes estàtiques (<code>element/crear</code>) abans de dinàmiques (<code>element/:id</code>)</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>navigate() no funciona</td>
<td>Router no injectat</td>
<td>Afegir <code>private router: Router</code> al constructor</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>getCurrentNavigation() retorna null</td>
<td>Cridat fora del constructor</td>
<td>Moure codi a constructor. <code>getCurrentNavigation()</code> només funciona allà</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Query params desapareixen després de navegar</td>
<td>No preservats explícitament</td>
<td>Afegir <code>queryParamsHandling: 'merge'</code> a navigate si voleu preservar-los</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Errors de compilació amb ActivatedRoute</td>
<td>Importació incorrecta</td>
<td>Assegurar <code>import { ActivatedRoute } from '@angular/router';</code></td>
<td>Igual que Windows</td>
</tr>
</tbody>
</table>
<h4>2.13.3. Problemes de dependències</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució</th>
</tr>
</thead>
<tbody>
<tr>
<td>Error "NullInjectorError: No provider for ActivatedRoute"</td>
<td>ActivatedRoute no disponible en component standalone</td>
<td>Afegir <code>RouterModule</code> als imports o usar <code>provideRouter()</code> a main.ts</td>
</tr>
<tr>
<td>ID sempre és string '0'</td>
<td>Conversió incorrecta</td>
<td>Usar <code>Number(id)</code> per convertir. Comprovar que <code>isNaN(id)</code> per validar</td>
</tr>
<tr>
<td>Query params no actualitzen component</td>
<td>Component no es subscriu a canvis</td>
<td>Usar <code>queryParamMap.subscribe()</code> en lloc de snapshot si els params canvien sense destruir component</td>
</tr>
<tr>
<td>Estat (state) es perd inesperadament</td>
<td>Accedir fora del constructor</td>
<td><code>getCurrentNavigation()</code> només funciona al constructor. Desar estat en propietat de classe</td>
</tr>
<tr>
<td>Error "Cannot match any routes"</td>
<td>Path mal format</td>
<td>Verificar que NO hi ha barres dobles (<code>//</code>), espais o caràcters especials al path</td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="2.13" titol="Resolució de problemes" contingut=section_point_2_13 %}

  {% capture section_point_2_14 %}
<h4>2.14.1. Prompt 1: Analitzar flux de navegació amb paràmetres</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un arquitecte d'aplicacions Angular expert en sistemes de rutes i navegació.<br><br><strong>Context:</strong> Tinc una aplicació de catàleg d'elements amb les següents rutes [adjuntar app.routes.ts]. Vull implementar navegació del llistat al detall passant l'ID de l'element, i filtres opcionals al llistat amb query params per categoria i ordre.<br><br><strong>Task:</strong> Proposa l'arquitectura completa de navegació:<br>1. Definició de rutes amb route params i query params<br>2. Enllaços HTML amb routerLink per navegar del llistat al detall<br>3. Captura de paràmetres als components (snapshot vs subscribe)<br>4. Navegació programàtica després de crear un element<br>5. Gestió d'errors (ID invàlid, element no trobat)<br><br><strong>Format:</strong> Codi TypeScript complet per app.routes.ts, component de llistat, component de detall i servei. Incloure comentaris explicatius." %}
<h4>2.14.2. Prompt 2: Depurar problema de captura de paràmetres</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un expert en debugging d'aplicacions Angular.<br><br><strong>Context:</strong> He definit una ruta <code>element/:id</code> i intento capturar l'ID al component amb aquest codi [adjuntar codi del component]. Quan navego a <code>/element/42</code>, <code>paramMap.get('id')</code> retorna <code>null</code> i l'aplicació falla amb error \"Cannot read property 'id' of null\".<br><br><strong>Task:</strong> Diagnostica el problema i proposa solucions:<br>1. Verifica la definició de la ruta (sintaxi correcta amb <code>:</code>)<br>2. Comprova la captura al component (nom del paràmetre coincideix)<br>3. Valida que ActivatedRoute s'injecta correctament<br>4. Proposa codi corregit amb validació d'errors robust<br>5. Suggereix tests per verificar que funciona<br><br><strong>Format:</strong> Llista numerada amb cada possible causa, solució proposada i codi corregit." %}
<h4>2.14.3. Prompt 3: Implementar filtratge amb query params</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un desenvolupador Angular expert en experiència d'usuari i navegació.<br><br><strong>Context:</strong> Tinc un component de catàleg que mostra elements. Vull afegir filtres opcionals per categoria i ordenació (data/preu) que persisteixin a la URL com a query params: <code>/cataleg?categoria=electrònica&ordre=preu</code>.<br><br><strong>Task:</strong> Genera el codi complet per implementar filtres amb query params:<br>1. Botons HTML per canviar categoria i ordre<br>2. Navegació programàtica per actualitzar query params<br>3. Captura reactiva de query params amb subscripció<br>4. Aplicació de filtres als resultats<br>5. Indicació visual de filtres actius (botons destacats)<br>6. Reset de filtres (tornar a valors per defecte)<br><br><strong>Format:</strong> Codi TypeScript i HTML complets amb comentaris. Incloure estils SCSS per destacar filtres actius." %}
  {% endcapture %}
  {% include section-point.html numero="2.14" titol="Prompts d'IA" contingut=section_point_2_14 %}

  {% capture section_point_2_15 %}
<h4>2.15.1. Criteris objectius (Definition of Done)</h4>
<p><strong>Funcionalitat:</strong></p>
{% include checklist.html elements="He definit una ruta amb paràmetre obligatori (<code>:id</code>) i funciona correctament|He implementat un component de detall que captura l'ID i carrega dades de l'API|He afegit enllaços al llistat que naveguen al detall passant l'ID dinàmicament|He implementat filtres amb query params que persisteixen a la URL|He implementat navegació programàtica després d'una operació (crear/editar)" %}
<p><strong>Projecte i estructura:</strong></p>
{% include checklist.html elements="He validat els paràmetres capturats (conversió a number, verificació de NaN)|He gestionat errors quan l'ID és invàlid (redirecció o missatge d'error)|He implementat subscripció reactiva quan el component no es destrueix|He documentat a <code>docs/navegacio.md</code> les rutes amb paràmetres i query params" %}
<p><strong>Control de versions:</strong></p>
{% include checklist.html elements="He inicialitzat repositori Git local si no existia|He fet commit amb el missatge \"feat: implementar paràmetres de ruta i navegació programàtica\"|He publicat els canvis a GitHub correctament" %}
<p><strong>Experiència d'usuari:</strong></p>
{% include checklist.html elements="Les URLs són netes, descriptives i compartibles|Els filtres persisten a la URL (puc copiar/enganxar la URL amb filtres)|La navegació és fluida sense recarregues innecessàries|Els errors es gestionen adequadament sense pantalles en blanc" %}
<h4>2.15.2. Competències adquirides</h4>
<p><strong>Paràmetres de ruta:</strong></p>
{% include checklist.html elements="Sé definir rutes amb paràmetres obligatoris (<code>:id</code>) correctament|Sé capturar paràmetres amb <code>ActivatedRoute.snapshot.paramMap.get()</code>|Entenc la diferència entre snapshot i subscribe per capturar paràmetres|Sé validar i convertir paràmetres (són strings, cal convertir-los)" %}
<p><strong>Query params:</strong></p>
{% include checklist.html elements="Sé utilitzar query params per a filtres i opcions opcionals|Sé passar query params amb <code>[queryParams]</code> en enllaços HTML|Sé capturar query params amb <code>queryParamMap.get()</code> i proporcionar valors per defecte|Entenc quan usar query params vs route params" %}
<p><strong>Navegació programàtica:</strong></p>
{% include checklist.html elements="Sé navegar des de codi TypeScript amb <code>Router.navigate()</code>|Sé passar paràmetres i query params en navegació programàtica|Sé implementar navegació després de validacions i operacions asíncrones|Sé passar dades temporals amb Router state sense exposar-les a la URL" %}
<p><strong>Gestió d'errors i casos límit:</strong></p>
{% include checklist.html elements="Sé gestionar IDs invàlids (NaN, negatius, nulls)|Sé redirigir o mostrar errors quan les dades no existeixen|Sé validar paràmetres abans d'usar-los en operacions crítiques|Sé proporcionar fallbacks (valors per defecte) per query params opcionals" %}
<p><strong>Arquitectura i bones pràctiques:</strong></p>
{% include checklist.html elements="Entenc l'ordre d'avaluació de rutes (estàtiques abans de dinàmiques)|Sé quan usar snapshot vs subscribe segons si el component es reutilitza|Sé fer unsubscribe de subscripcions reactives per evitar memory leaks|Sé combinar route params, query params i Router state segons les necessitats" %}
  {% endcapture %}
  {% include section-point.html numero="2.15" titol="Autoavaluació" contingut=section_point_2_15 %}

  {% capture section_point_2_16 %}
<h4>2.16.1. Què hem aconseguit</h4>
<p>Heu implementat un sistema complet de navegació amb paràmetres al projecte <code>catalog-elements</code>, permetent navegació dinàmica entre llistat i detall, filtres persistents i operacions amb feedback automàtic.</p>
<p>Disposeu d'una <strong>aplicació Angular amb navegació avançada</strong> que inclou:</p>
<ol>
<li><strong>Rutes amb paràmetres obligatoris:</strong> Definides amb <code>:id</code> per identificar recursos únics, capturades i validades als components per carregar dades específiques</li>
<li><strong>Navegació dinàmica:</strong> Enllaços HTML amb <code>[routerLink]</code> que passen IDs dinàmicament, permetent navegar del llistat al detall de qualsevol element sense crear rutes manuals</li>
<li><strong>Filtres persistents amb query params:</strong> Categoria i ordenació a la URL (<code>?categoria=3&ordre=preu</code>), compartibles, marcables i persistents amb recàrregues</li>
<li><strong>Navegació programàtica:</strong> Redireccions automàtiques després de crear elements, amb control total sobre el moment i condicions de navegació des de codi TypeScript</li>
<li><strong>Gestió d'errors robusta:</strong> Validació de paràmetres, conversió de tipus, redirecció a error quan l'ID és invàlid, i missatges clars per a l'usuari</li>
</ol>
<h4>2.16.2. Què queda preparat per a la Lectura 4.1.3</h4>
<p>A la <strong>Lectura 4.1.3 (Rutes niades i guàrdies de ruta)</strong> ampliareu el sistema de navegació amb:</p>
<ul>
<li><strong>Rutes niades:</strong> Organitzar jerarquies complexes (pare-fill) per seccions amb sub-navegació, com dashboards amb múltiples vistes o àrees administratives</li>
<li><strong>Guàrdies de ruta:</strong> Protegir rutes sensibles comprovant autenticació, permisos o estat abans de permetre l'accés, redirigint automàticament quan no es compleixen les condicions</li>
<li><strong>Múltiples outlets:</strong> Mostrar diverses vistes simultànies (barra lateral + contingut principal) amb navegació independent</li>
</ul>
<p>Amb paràmetres de ruta i navegació programàtica dominats, esteu preparats per implementar arquitectures de navegació complexes amb control d'accés i jerarquies niades.</p>
<h4>2.16.3. Contracte de sortida</h4>
{% include checklist.html items="Sé definir rutes amb paràmetres obligatoris i opcionals|Sé capturar paràmetres de ruta i query params als components|Sé implementar navegació programàtica amb Router.navigate()|Sé validar paràmetres i gestionar errors adequadament|Entenc quan usar route params, query params o Router state" %}
<p><strong>Les vostres URLs ara són dinàmiques, compartibles i amigables, i la navegació és completament controlada per lògica de negoci!</strong></p>
  {% endcapture %}
  {% include section-point.html numero="2.16" titol="Recapitulació" contingut=section_point_2_16 %}

  {% capture section_point_2_17 %}
<h4>2.17.1. Paràmetres de ruta obligatoris (<code>:id</code>)</h4>
<ul>
<li><strong>Definició:</strong> <code>path: 'element/:id'</code> - El dos punts indica un segment dinàmic obligatori</li>
<li><strong>Captura:</strong> <code>this.route.snapshot.paramMap.get('id')</code> - Retorna un string o null</li>
<li><strong>Validació:</strong> Convertir a number amb <code>Number(id)</code> i verificar amb <code>isNaN()</code></li>
<li><strong>Ús típic:</strong> Identificadors únics de recursos (element, usuari, comanda)</li>
</ul>
<h4>2.17.2. Query params (<code>?clau=valor</code>)</h4>
<ul>
<li><strong>Passar:</strong> <code>[queryParams]="{ categoria: 'electrònica' }"</code> o <code>{ queryParams: { ordre: 'preu' } }</code></li>
<li><strong>Captura:</strong> <code>this.route.snapshot.queryParamMap.get('categoria')</code> - Retorna un string o null</li>
<li><strong>Fallback:</strong> Usar operador <code>??</code> per proporcionar valors per defecte: <code>categoria ?? 'totes'</code></li>
<li><strong>Ús típic:</strong> Filtres, cerca, ordenació, paginació (opcionals)</li>
</ul>
<h4>2.17.3. Navegació programàtica</h4>
<ul>
<li><strong>Sintaxi bàsica:</strong> <code>this.router.navigate(['/cataleg'])</code> - Array de segments</li>
<li><strong>Amb paràmetres:</strong> <code>this.router.navigate(['/element', 42])</code> - Segments concatenats amb <code>/</code></li>
<li><strong>Amb query params:</strong> <code>this.router.navigate(['/cataleg'], { queryParams: { categoria: 3 } })</code></li>
<li><strong>Ús típic:</strong> Després de validacions, operacions asíncrones, redireccions condicionals</li>
</ul>
<h4>2.17.4. Router state (estat temporal)</h4>
<ul>
<li><strong>Passar:</strong> <code>this.router.navigate(['/confirmacio'], { state: { element: {...} } })</code></li>
<li><strong>Captura:</strong> <code>this.router.getCurrentNavigation()?.extras.state</code> - Només al constructor</li>
<li><strong>Limitació:</strong> Es perd amb recàrrega (F5), no compartible ni marcable</li>
<li><strong>Ús típic:</strong> Confirmacions temporals, objectes grans, informació sensible</li>
</ul>
<h4>2.17.5. Snapshot vs Subscribe</h4>
<ul>
<li><strong>Snapshot:</strong> <code>route.snapshot.paramMap.get('id')</code> - Captura instantània, no reactiu, 95% dels casos</li>
<li><strong>Subscribe:</strong> <code>route.paramMap.subscribe(params => ...)</code> - Reactiu, requereix unsubscribe, rutes niades</li>
<li><strong>Quan usar subscribe:</strong> Component reutilitzat amb diferent ID sense destruir-se</li>
</ul>
<h4>2.17.6. Ordre de definició de rutes</h4>
<ul>
<li><strong>Regla:</strong> Rutes estàtiques abans de dinàmiques - Angular avalua de dalt a baix</li>
<li><strong>Correcte:</strong> <code>element/crear</code> abans de <code>element/:id</code></li>
<li><strong>Incorrecte:</strong> <code>element/:id</code> captura <code>/element/crear</code> assignant <code>id = 'crear'</code></li>
</ul>
<h4>2.17.7. Validació i conversió de tipus</h4>
<ul>
<li><strong>Sempre strings:</strong> <code>paramMap.get()</code> i <code>queryParamMap.get()</code> retornen strings o null</li>
<li><strong>Convertir:</strong> <code>Number(id)</code>, <code>parseInt(id, 10)</code>, <code>Boolean(valor)</code></li>
<li><strong>Validar:</strong> <code>isNaN(id)</code>, <code>id <= 0</code>, <code>!id</code> abans d'usar-los</li>
<li><strong>Fallback:</strong> <code>categoria ?? 'totes'</code>, <code>ordre || 'data'</code></li>
</ul>
<h4>2.17.8. Arbre de decisió ràpid</h4>
<pre>
¿Obligatori? → Route param (:id)
¿Compartible/persistent? → Query param (?clau=valor)
¿Temporal/sensible? → Router state ({ state })
</pre>
  {% endcapture %}
  {% include section-point.html numero="2.17" titol="Repàs de conceptes" contingut=section_point_2_17 %}

</div>
<!-- Tanca Secció 2 -->

<!-- ============================================================ -->
<!-- SECCIÓ 3: Rutes niades i guàrdies de ruta -->
<!-- ============================================================ -->
<div class="section" id="Unitat4_Bloc1_Seccio3">
  <h2 id="Unitat4_Bloc1_Seccio3">3. Rutes niades i guàrdies de ruta</h2>

  <!-- MULTIMÈDIA -->
  {% include multimedia-youtube.html unitat=4 bloc=1 seccio=3 %}


  {% include objectius.html llista="Configurar rutes niades (pare-filles) per organitzar jerarquies complexes de pàgines|Utilitzar múltiples outlets per mostrar diverses vistes simultànies|Crear guàrdies d'activació per protegir rutes sensibles comprovant autenticació o permisos|Implementar lògica de redirecció automàtica quan l'accés a una ruta és denegat" %}

  {% include info_box.html contingut="<strong>RA4 · Criteri 3</strong> — Aplica mecanismes per preservar l'estat d'usuari i protegir seccions quan sigui necessari." %}

  {% capture section_point_3_1 %}
<p>Abans de començar, necessiteu:</p>
<ul>
<li><strong>Lectures 4.1.1 i 4.1.2 completades:</strong> Sistema de rutes bàsic amb navegació i paràmetres funcionals</li>
<li><strong>Projecte catalog-elements operatiu:</strong> Aplicació amb almenys 3-4 rutes diferents funcionant correctament</li>
<li><strong>Component de layout o contenidor:</strong> Component pare que pot contenir rutes filles (pot crear-se durant aquesta lectura)</li>
<li><strong>Comprensió bàsica d'autenticació:</strong> Concepte d'usuari autenticat vs no autenticat (simularem l'estat)</li>
</ul>
<p><strong>Verificació ràpida:</strong></p>
{% capture code_134 %}# Windows (PowerShell)
Set-Location $env:USERPROFILE\workspace\catalog-elements
Get-Content .\src\app\navegacio\app.routes.ts | Select-String -Pattern "path"

# macOS/Linux (bash/zsh)
cd ~/workspace/catalog-elements
grep "path" src/app/navegacio/app.routes.ts{% endcapture %}
{% include code-block.html lang="bash" code=code_134 %}
<p><strong>Punt d'autocomprovació:</strong> Heu de veure almenys 3-4 definicions de rutes. Si obriu l'aplicació al navegador (<code>http://localhost:4300</code>), la navegació entre rutes ha de funcionar correctament. Heu de poder navegar a <code>/cataleg</code>, <code>/element/42</code>, etc. sense errors 404.</p>
  {% endcapture %}
  {% include section-point.html numero="3.1" titol="Prerequisits" contingut=section_point_3_1 %}

  {% capture section_point_3_2 %}
<h4>3.2.1. Què són les rutes niades i les guàrdies de ruta</h4>
<p>Les <strong>rutes niades</strong> (nested routes) permeten crear jerarquies pare-fill on una ruta conté altres rutes dins seu. Això és essencial per organitzar aplicacions complexes amb seccions que tenen sub-navegació pròpia. Les <strong>guàrdies de ruta</strong> són mecanismes de protecció que executen lògica abans de permetre la navegació, comprovant condicions com autenticació, permisos o estat de dades.</p>
<h4>3.2.2. Problema sense rutes niades ni guàrdies</h4>
<p><strong>Situació abans:</strong></p>
<p>Imagineu una aplicació amb un panell d'administració que té 5 seccions diferents (usuaris, comandes, estadístiques, configuració, logs). Sense rutes niades, definiu totes les rutes al mateix nivell:</p>
{% capture code_135 %}// src/app/navegacio/app.routes.ts - Sense rutes niades: tot pla
export const routes: Routes = [
  { path: '', component: InicComponent },
  { path: 'cataleg', component: CatalegComponent },
  // PROBLEMA: Admin amb 5 rutes al mateix nivell sense jerarquia
  { path: 'admin-usuaris', component: AdminUsuarisComponent },
  { path: 'admin-comandes', component: AdminComandesComponent },
  { path: 'admin-estadistiques', component: AdminEstadistiquesComponent },
  { path: 'admin-configuracio', component: AdminConfiguracioComponent },
  { path: 'admin-logs', component: AdminLogsComponent },
  // PROBLEMA: Sense guàrdies, qualsevol pot accedir
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_135 %}
<p><strong>Sense guàrdies de ruta:</strong></p>
<p>Totes les rutes són accessibles per qualsevol usuari. No hi ha cap mecanisme per comprovar si l'usuari està autenticat o té permisos d'administrador abans d'accedir a <code>/admin-usuaris</code>:</p>
{% capture code_136 %}{% raw %}// PROBLEMA: Qualsevol pot navegar a l'administració
<a routerLink="/admin-usuaris">Admin Usuaris</a>
// Sense guàrdies, això funciona fins i tot si l'usuari NO és admin{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_136 %}
<p><strong>Problemes que genera:</strong></p>
<p><strong>1. Falta d'estructura jeràrquica i organització confusa</strong></p>
<p>Sense rutes niades, totes les rutes d'administració estan al mateix nivell que les rutes públiques. Això crea confusió sobre quines rutes són sub-seccions d'altres:</p>
<p><strong>Exemple de caos:</strong></p>
<ul>
<li><code>/admin-usuaris</code> - És una sub-secció de <code>/admin</code>? No hi ha manera de saber-ho</li>
<li><code>/admin-comandes</code> - Relacionada amb <code>/admin-usuaris</code>? No és clar</li>
<li><code>/configuracio</code> vs <code>/admin-configuracio</code> - Dos tipus de configuració? Confús</li>
</ul>
<p><strong>Impacte real:</strong> En equips grans, desenvolupadors nous tarden dies a entendre l'estructura de rutes perquè no hi ha jerarquia clara. "On va aquesta ruta? És pública o d'administració? És una sub-secció de què?"</p>
<p><strong>2. Duplicació de layout i components comuns</strong></p>
<p>Cada ruta d'administració necessita reproduir el mateix layout (menú lateral d'admin, capçalera, etc.):</p>
{% capture code_137 %}{% raw %}// admin-usuaris.component.html - Duplicació del layout d'admin
<div class="admin-layout">
  <nav class="admin-sidebar">
    <a routerLink="/admin-usuaris">Usuaris</a>
    <a routerLink="/admin-comandes">Comandes</a>
    <a routerLink="/admin-estadistiques">Estadístiques</a>
    <!-- ... duplicat a tots els components d'admin! -->
  </nav>
  <main>
    <!-- Contingut específic d'usuaris -->
  </main>
</div>

// admin-comandes.component.html - MATEIX layout duplicat!
<div class="admin-layout">
  <nav class="admin-sidebar">
    <a routerLink="/admin-usuaris">Usuaris</a>
    <!-- ... TOT duplicat de nou! -->
  </nav>
  <main>
    <!-- Contingut específic de comandes -->
  </main>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_137 %}
<p><strong>Cost de manteniment:</strong> Si voleu canviar el menú lateral d'admin, heu de modificar 5 fitxers HTML! Canviar l'estil del layout requereix tocar tots els components d'admin.</p>
<p><strong>3. URLs no amigables i falta de context visual</strong></p>
<p>Les URLs planes no reflecteixen la jerarquia real de l'aplicació:</p>
<ul>
<li><code>/admin-usuaris</code> - Prefixe <code>admin-</code> forçat artificialment</li>
<li><code>/admin-comandes</code> - Repetició del prefix en cada ruta</li>
<li><code>/admin-estadistiques</code> - URLs llargues i redundants</li>
</ul>
<p><strong>URLs desitjables amb jerarquia:</strong></p>
<ul>
<li><code>/admin/usuaris</code> - Clar: sub-secció "usuaris" dins d'"admin"</li>
<li><code>/admin/comandes</code> - Jerarquia visual evident</li>
<li><code>/admin/estadistiques</code> - Agrupació natural</li>
</ul>
<p><strong>Problema SEO i usabilitat:</strong> Google penalitza URLs mal estructurades. Els usuaris no poden deduir fàcilment la jerarquia de pàgines només veient la URL.</p>
<p><strong>4. Impossibilitat de compartir layout i estat entre sub-seccions</strong></p>
<p>Sense un component pare comú, no podeu:</p>
<ul>
<li>Compartir l'estat entre totes les sub-seccions d'admin (per exemple, informació de l'usuari administrador)</li>
<li>Aplicar estils o comportaments globals a totes les pàgines d'admin</li>
<li>Carregar dades comunes una sola vegada (en lloc de repetir-ho a cada component)</li>
</ul>
<p><strong>Exemple:</strong> Voleu mostrar "Hola Admin Maria" a totes les pàgines d'admin. Sense layout compartit, heu de:</p>
<ol>
<li>Carregar la informació de l'usuari a cada component d'admin (5 vegades!)</li>
<li>Duplicar el codi de visualització en cada template</li>
</ol>
<p><strong>5. Falta de protecció: rutes sensibles accessibles sense autenticació</strong></p>
<p>Sense guàrdies, qualsevol pot accedir directament a rutes d'administració escrivint la URL al navegador:</p>
{% capture code_138 %}http://localhost:4300/admin-usuaris
→ Carrega la pàgina d'administració d'usuaris
→ Fins i tot si l'usuari NO està autenticat!
→ Fins i tot si l'usuari NO és administrador!{% endcapture %}
{% include code-block.html lang="text" code=code_138 %}
<p><strong>Impacte de seguretat:</strong> Dades sensibles exposades, funcionalitats perilloses accessibles (eliminar usuaris, canviar preus, modificar configuració del sistema). Encara que el backend validi permisos, mostrar la interfície d'admin a usuaris no autoritzats és molt problemàtic (poden veure dades parcials, intenten accions, generen errors confusos).</p>
<p><strong>Exemple real d'incident:</strong></p>
{% capture code_139 %}Usuari normal navega a /admin-estadistiques
→ Veu gràfics d'estadístiques internes (vendes, usuaris actius, errors de sistema)
→ Informació confidencial exposada!
→ L'usuari pot intentar modificar coses (formularis visibles)
→ Genera errors 403 del backend (confusió per a l'usuari)
→ Experiència d'usuari horrible + brecha de seguretat{% endcapture %}
{% include code-block.html lang="text" code=code_139 %}
<p><strong>6. Experiència d'usuari deteriorada: navegació sense validació prèvia</strong></p>
<p>No podeu validar condicions abans de navegar:</p>
<ul>
<li>Usuari intenta navegar a <code>/preferits</code> però no ha iniciat sessió → Veu un error després de carregar la pàgina</li>
<li>Usuari intenta accedir a <code>/editar-perfil</code> però el seu perfil està incomplet → Carrega la pàgina i després veu un error</li>
</ul>
<p><strong>Sense guàrdies:</strong></p>
{% capture code_140 %}1. Usuari clica "Veure preferits"
2. Angular navega a /preferits
3. Component PreferitsComponent es carrega
4. ngOnInit() intenta carregar preferits
5. API retorna 401 Unauthorized
6. Component mostra error "No tens sessió iniciada"{% endcapture %}
{% include code-block.html lang="text" code=code_140 %}
<p><strong>Amb guàrdies:</strong></p>
{% capture code_141 %}1. Usuari clica "Veure preferits"
2. Guàrdia comprova autenticació ABANS de navegar
3. Si NO autenticat → Redirigeix automàticament a /login
4. Usuari veu pàgina de login immediatament (millor experiència){% endcapture %}
{% include code-block.html lang="text" code=code_141 %}
  {% endcapture %}
  {% include section-point.html numero="3.2" titol="Marc conceptual" contingut=section_point_3_2 %}

  {% capture section_point_3_3 %}
<h4>3.3.1. Rutes niades com carpetes dins de carpetes</h4>
<p>Imagina que les rutes són carpetes en un sistema de fitxers. Una ruta pare és una carpeta principal (<code>/admin</code>) que conté subcarpetes (<code>/admin/usuaris</code>, <code>/admin/comandes</code>). El component pare és com l'estructura de la carpeta (icona, color, metadades) que totes les subcarpetes comparteixen.</p>
<h4>3.3.2. Router-outlet com a marc de foto intercanviable</h4>
<p>El <code>&lt;router-outlet&gt;</code> dins d'un component pare és com un marc de foto buit. Les rutes filles són diferents fotos que pots posar al marc. El marc (layout) no canvia, però la foto (contingut) sí. Quan navegues entre rutes filles, només canvies la foto dins del mateix marc.</p>
<h4>3.3.3. Guàrdies com a guardes de seguretat a l'entrada</h4>
<p>Les guàrdies són com guardes de seguretat a l'entrada d'un edifici. Abans de deixar-te entrar (carregar el component), comproven el teu carnet (autenticació), el teu rol (permisos), i decideixen si pots passar o et redirigeixen a un altre lloc (login).</p>
<h4>3.3.4. Herència de guàrdies com a control d'accés a zones</h4>
<p>Si poses un guarda a l'entrada d'una zona restringida (ruta pare), totes les habitacions dins d'aquesta zona (rutes filles) estan protegides automàticament. No cal posar un guarda a cada habitació, el guarda de la zona ja ho controla tot.</p>
<h4>3.3.5. returnUrl com a nota per recordar destinació</h4>
<p>Quan el guarda et redirigeix al login perquè no tens carnet, et dóna una nota amb la destinació on volies anar. Després de fer login, mires la nota i et dirigeixes allà. Sense la nota, després de fer login no recordaries on volies anar originalment.</p>
  {% endcapture %}
  {% include section-point.html numero="3.3" titol="Model mental" contingut=section_point_3_3 %}

  {% capture section_point_3_4 %}
<h4>3.4.1. Objectiu</h4>
<p>Comprendre què són les rutes niades, per què són necessàries i quan utilitzar-les per organitzar aplicacions complexes.</p>
<h4>3.4.2. Què són les rutes niades</h4>
<p>Les <strong>rutes niades</strong> permeten crear jerarquies de rutes on una ruta pare conté rutes filles. Això és essencial per organitzar aplicacions amb seccions que tenen múltiples sub-pàgines relacionades, com ara un panell d'administració, un perfil d'usuari amb configuració, o una vista de producte amb pestanyes.</p>
<h4>3.4.3. Per què necessitem rutes niades</h4>
<p><strong>1. Organització lògica de seccions complexes</strong></p>
<p>Aplicacions grans tenen seccions amb múltiples sub-pàgines. Sense rutes niades, totes les rutes estan al mateix nivell, creant confusió:</p>
{% capture code_142 %}Rutes planes (problema):
/admin-usuaris
/admin-comandes
/admin-estadistiques
/admin-configuracio
/admin-logs
→ No és clar que totes són sub-seccions de "admin"{% endcapture %}
{% include code-block.html lang="text" code=code_142 %}
<p>Amb rutes niades, la jerarquia és evident:</p>
{% capture code_143 %}Rutes niades (solució):
/admin
  ├── /admin/usuaris
  ├── /admin/comandes
  ├── /admin/estadistiques
  ├── /admin/configuracio
  └── /admin/logs
→ Jerarquia clara: totes són filles de "/admin"{% endcapture %}
{% include code-block.html lang="text" code=code_143 %}
<p><strong>2. Compartir layout i estils entre sub-pàgines</strong></p>
<p>Totes les pàgines d'una secció sovint comparteixen elements comuns:</p>
<ul>
<li>Menú lateral amb navegació entre sub-pàgines</li>
<li>Capçalera amb títol de la secció</li>
<li>Estils visuals consistents</li>
</ul>
<p>Sense rutes niades, heu de duplicar aquest layout a cada component. Amb rutes niades, el component pare proporciona el layout una sola vegada:</p>
{% capture code_144 %}{% raw %}<!-- admin-layout.component.html - Layout compartit -->
<div class="admin-layout">
  <nav class="sidebar">
    <a routerLink="/admin/usuaris">Usuaris</a>
    <a routerLink="/admin/comandes">Comandes</a>
  </nav>
  <main>
    <router-outlet></router-outlet>  ← Rutes filles aquí
  </main>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_144 %}
<p><strong>3. URLs semàntiques i amigables</strong></p>
<p>Les rutes niades generen URLs que reflecteixen la jerarquia real:</p>
<ul>
<li><code>/perfil/configuracio</code> - Clar: configuració dins del perfil</li>
<li><code>/perfil/privacitat</code> - Clar: privacitat dins del perfil</li>
<li><code>/producte/42/ressenyes</code> - Clar: ressenyes del producte 42</li>
</ul>
<p>Aquestes URLs són:</p>
<ul>
<li><strong>Comprensibles:</strong> L'usuari entén la jerarquia només veient la URL</li>
<li><strong>Compartibles:</strong> Còpies la URL i altra persona entén on està</li>
<li><strong>SEO-friendly:</strong> Google valora URLs ben estructurades</li>
</ul>
<h4>3.4.4. Quan usar rutes niades</h4>
<p><strong>Usar rutes niades quan:</strong></p>
<ul>
<li>Teniu 3+ sub-pàgines relacionades amb layout comú</li>
<li>Volen URLs amb jerarquia visual (<code>/secció/sub-secció</code>)</li>
<li>Necessiteu compartir estat o dades entre sub-pàgines</li>
<li>Hi ha navegació entre sub-pàgines sense sortir de la secció</li>
</ul>
<p><strong>Exemples típics:</strong></p>
<ul>
<li><strong>Dashboard d'admin:</strong> <code>/admin/usuaris</code>, <code>/admin/comandes</code>, <code>/admin/estadístiques</code></li>
<li><strong>Perfil d'usuari:</strong> <code>/perfil/configuracio</code>, <code>/perfil/privacitat</code>, <code>/perfil/notificacions</code></li>
<li><strong>Producte amb pestanyes:</strong> <code>/producte/42/descripcio</code>, <code>/producte/42/ressenyes</code>, <code>/producte/42/especificacions</code></li>
<li><strong>Curs amb lliçons:</strong> <code>/curs/angular/lliço-1</code>, <code>/curs/angular/lliço-2</code></li>
</ul>
<p><strong>NO usar rutes niades quan:</strong></p>
<ul>
<li>Cada pàgina té layout completament diferent</li>
<li>Hi ha menys de 2-3 pàgines relacionades</li>
<li>Prefereixes URLs planes per simplicitat</li>
</ul>
<h4>3.4.5. Anatomia d'una ruta niada</h4>
{% capture code_145 %}{
  path: 'admin',                      // ← Ruta pare
  component: AdminLayoutComponent,    // ← Component amb layout compartit
  children: [                         // ← Array de rutes filles
    { path: 'usuaris', component: AdminUsuarisComponent },
    { path: 'comandes', component: AdminComandesComponent }
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_145 %}
<p><strong>Components involucrats:</strong></p>
<ol>
<li><strong><code>AdminLayoutComponent</code></strong> - Proporciona layout amb <code>&lt;router-outlet&gt;</code> per renderitzar filles</li>
<li><strong><code>AdminUsuarisComponent</code></strong> - Contingut específic que es renderitza dins del layout</li>
<li><strong><code>AdminComandesComponent</code></strong> - Altre contingut específic dins del mateix layout</li>
</ol>
{% include success_box.html contingut="<strong>Clau:</strong> Les rutes niades organitzen aplicacions complexes en jerarquies clares amb URLs semàntiques, layouts compartits i estat comú entre sub-pàgines relacionades. Són essencials per aplicacions amb seccions que tenen 3+ sub-pàgines." %}
<h4>3.4.6. Resultat esperat</h4>
<p>Compreneu què són les rutes niades, per què són necessàries per organitzar aplicacions complexes, i quan utilitzar-les per millorar l'estructura, la reutilització i la semàntica de les URLs.</p>
  {% endcapture %}
  {% include section-point.html numero="3.4" titol="Rutes niades: organitzar jerarquies de pàgines" contingut=section_point_3_4 %}

  {% capture section_point_3_5 %}
<h4>3.5.1. Objectiu</h4>
<p>Aprendre la sintaxi exacta per definir rutes niades amb la propietat <code>children</code> i entendre com Angular les interpreta.</p>
<h4>3.5.2. Sintaxi bàsica de rutes niades</h4>
<p>Les rutes niades es defineixen amb la propietat <code>children</code> dins d'una ruta pare. Angular renderitza les rutes filles dins del <code>&lt;router-outlet&gt;</code> del component pare.</p>
{% capture code_146 %}// src/app/navegacio/app.routes.ts
import { Routes } from '@angular/router';
import { AdminLayoutComponent } from '../admin/admin-layout.component';
import { AdminUsuarisComponent } from '../admin/usuaris/admin-usuaris.component';
import { AdminComandesComponent } from '../admin/comandes/admin-comandes.component';
export const routes: Routes = [
  { path: '', component: InicComponent },
  { path: 'cataleg', component: CatalegComponent },
  // Ruta niada amb children
  {
    path: 'admin',                      // Ruta pare: /admin
    component: AdminLayoutComponent,    // Component amb layout
    children: [                         // Rutes filles
      {
        path: 'usuaris',                 // Ruta filla: /admin/usuaris
        component: AdminUsuarisComponent
      },
      {
        path: 'comandes',                // Ruta filla: /admin/comandes
        component: AdminComandesComponent
      }
    ]
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_146 %}
<p><strong>URLs generades:</strong></p>
<ul>
<li><code>/admin</code> → Carrega <code>AdminLayoutComponent</code> amb <code>&lt;router-outlet&gt;</code> buit</li>
<li><code>/admin/usuaris</code> → Carrega <code>AdminLayoutComponent</code> + <code>AdminUsuarisComponent</code> dins del outlet</li>
<li><code>/admin/comandes</code> → Carrega <code>AdminLayoutComponent</code> + <code>AdminComandesComponent</code> dins del outlet</li>
</ul>
<h4>3.5.3. Component pare amb router-outlet</h4>
<p>El component pare MUST contenir un <code>&lt;router-outlet&gt;</code> on es renderitzaran les rutes filles:</p>
<p><code>src/app/admin/admin-layout.component.ts</code>:</p>
{% capture code_147 %}import { Component } from '@angular/core';
import { RouterOutlet, RouterLink } from '@angular/router';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-admin-layout',
  standalone: true,
  imports: [CommonModule, RouterOutlet, RouterLink],
  templateUrl: './admin-layout.component.html',
  styleUrls: ['./admin-layout.component.scss']
})
export class AdminLayoutComponent {}{% endcapture %}
{% include code-block.html lang="typescript" code=code_147 %}
<p><code>src/app/admin/admin-layout.component.html</code>:</p>
{% capture code_148 %}{% raw %}<div class="admin-layout">
<header class="admin-header">
<h1>Panell d'administració</h1>
</header>
<nav class="admin-sidebar">
<a routerLink="/admin/usuaris" routerLinkActive="actiu">
Usuaris
</a>
<a routerLink="/admin/comandes" routerLinkActive="actiu">
Comandes
</a>
<a routerLink="/admin/estadistiques" routerLinkActive="actiu">
Estadístiques
</a>
</nav>
<main class="admin-content">
<router-outlet></router-outlet>
</main>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_148 %}
<p><strong>Important:</strong> Sense <code>&lt;router-outlet&gt;</code>, les rutes filles NO es renderitzaran!</p>
<h4>3.5.4. Ruta per defecte dins de children</h4>
<p>Quan l'usuari navega només al pare (<code>/admin</code>), podeu redirigir automàticament a una filla per defecte:</p>
{% capture code_149 %}{
  path: 'admin',
  component: AdminLayoutComponent,
  children: [
    { path: '', redirectTo: 'usuaris', pathMatch: 'full' },  // /admin → /admin/usuaris
    { path: 'usuaris', component: AdminUsuarisComponent },
    { path: 'comandes', component: AdminComandesComponent }
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_149 %}
<p><strong>Resultat:</strong> Navegar a <code>/admin</code> redirigeix automàticament a <code>/admin/usuaris</code>.</p>
<h4>3.5.5. Rutes niades amb paràmetres</h4>
<p>Podeu combinar rutes niades amb paràmetres de ruta:</p>
{% capture code_150 %}{
  path: 'producte/:id',                    // Ruta pare amb paràmetre
  component: ProducteLayoutComponent,
  children: [
    { path: '', redirectTo: 'descripcio', pathMatch: 'full' },
    { path: 'descripcio', component: DescripcioComponent },
    { path: 'ressenyes', component: RessenyesComponent },
    { path: 'especificacions', component: EspecificacionsComponent }
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_150 %}
<p><strong>URLs generades:</strong></p>
<ul>
<li><code>/producte/42</code> → Redirigeix a <code>/producte/42/descripcio</code></li>
<li><code>/producte/42/ressenyes</code> → Producte 42, pestanya de ressenyes</li>
<li><code>/producte/99/especificacions</code> → Producte 99, pestanya d'especificacions</li>
</ul>
<p><strong>Captura del paràmetre al component pare:</strong></p>
{% capture code_151 %}// producte-layout.component.ts
export class ProducteLayoutComponent implements OnInit {
  producteId!: number;
  constructor(private route: ActivatedRoute) {}
  ngOnInit(): void {
    this.producteId = Number(this.route.snapshot.paramMap.get('id'));
    console.log('ID del producte:', this.producteId);
    // Totes les rutes filles també poden accedir a aquest paràmetre
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_151 %}
<h4>3.5.6. Errors comuns en rutes niades</h4>
<p><strong>Error 1: Oblidar router-outlet al component pare</strong></p>
{% capture code_152 %}{% raw %}<!-- PROBLEMA: Component pare sense router-outlet -->
<div class="admin-layout">
<nav>...</nav>
<main>
<!-- NO hi ha <router-outlet> aquí -->
</main>
</div>
<!-- SOLUCIÓ: Amb router-outlet -->
<div class="admin-layout">
<nav>...</nav>
<main>
<router-outlet></router-outlet>
</main>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_152 %}
<p><strong>Error 2: Definir rutes filles amb barra inicial</strong></p>
{% capture code_153 %}// INCORRECTE: Rutes filles amb barra inicial
children: [
  { path: '/usuaris', component: AdminUsuarisComponent }  // NO funciona
]
// CORRECTE: Sense barra inicial
children: [
  { path: 'usuaris', component: AdminUsuarisComponent }  // Funciona
]{% endcapture %}
{% include code-block.html lang="typescript" code=code_153 %}
{% include success_box.html contingut="<strong>Clau:</strong> Les rutes niades es defineixen amb <code>children: []</code> dins d'una ruta pare. El component pare MUST contenir <code>&lt;router-outlet&gt;</code> per renderitzar les filles. Les rutes filles NO porten barra inicial. Angular concatena automàticament <code>pare/filla</code> per generar la URL completa." %}
<h4>3.5.7. Resultat esperat</h4>
<p>Sabeu configurar rutes niades amb la propietat <code>children</code>, crear components pare amb <code>&lt;router-outlet&gt;</code>, definir rutes per defecte, combinar amb paràmetres i evitar errors comuns.</p>
  {% endcapture %}
  {% include section-point.html numero="3.5" titol="Configuració de rutes filles: propietat children" contingut=section_point_3_5 %}

  {% capture section_point_3_6 %}
<h4>3.6.1. Objectiu</h4>
<p>Aprendre a utilitzar outlets amb nom per mostrar múltiples vistes simultànies i crear layouts complexos amb navegació independent.</p>
<h4>3.6.2. Outlet principal i outlets secundaris</h4>
<p>Angular permet definir múltiples <code>&lt;router-outlet&gt;</code> amb noms diferents per mostrar diverses vistes al mateix temps. Això és útil per layouts amb barra lateral, modals persistents o panells auxiliars.</p>
<p><strong>Outlet principal (sense nom):</strong></p>
{% capture code_154 %}{% raw %}<router-outlet></router-outlet>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_154 %}
<p><strong>Outlets secundaris (amb nom):</strong></p>
{% capture code_155 %}{% raw %}<router-outlet name="sidebar"></router-outlet>
<router-outlet name="modal"></router-outlet>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_155 %}
<h4>3.6.3. Definir rutes amb outlets múltiples</h4>
{% capture code_156 %}// Rutes amb outlets múltiples
export const routes: Routes = [
  { path: 'cataleg', component: CatalegComponent },  // Outlet principal
  { path: 'detalls', component: DetallsComponent, outlet: 'sidebar' },  // Outlet lateral
  { path: 'ajuda', component: AjudaComponent, outlet: 'modal' }  // Outlet modal
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_156 %}
<h4>3.6.4. Template amb múltiples outlets</h4>
<p><code>src/app/app.component.html</code>:</p>
{% capture code_157 %}{% raw %}<div class="app-layout">
<main class="main-content">
<router-outlet></router-outlet>
</main>
<aside class="sidebar">
<router-outlet name="sidebar"></router-outlet>
</aside>
<div class="modal-overlay">
<router-outlet name="modal"></router-outlet>
</div>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_157 %}
<h4>3.6.5. Navegació a múltiples outlets</h4>
<p><strong>Sintaxi amb routerLink:</strong></p>
{% capture code_158 %}{% raw %}<!-- Navegar només a outlet principal -->
<a routerLink="/cataleg">Catàleg</a>
<!-- Navegar a outlet lateral -->
<a [routerLink]="[{ outlets: { sidebar: ['detalls'] } }]">
Mostrar detalls lateral
</a>
<!-- Navegar a múltiples outlets simultàniament -->
<a [routerLink]="['/cataleg', { outlets: { sidebar: ['detalls'], modal: ['ajuda'] } }]">
Catàleg + Detalls + Ajuda
</a>
<!-- Tancar outlet lateral -->
<a [routerLink]="[{ outlets: { sidebar: null } }]">
Tancar sidebar
</a>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_158 %}
<p><strong>URLs generades:</strong></p>
<ul>
<li><code>/cataleg</code> - Només outlet principal</li>
<li><code>/cataleg(sidebar:detalls)</code> - Outlet principal + lateral</li>
<li><code>/cataleg(sidebar:detalls//modal:ajuda)</code> - Outlet principal + lateral + modal</li>
</ul>
<h4>3.6.6. Navegació programàtica amb múltiples outlets</h4>
{% capture code_159 %}import { Component } from '@angular/core';
import { Router } from '@angular/router';
@Component({...})
export class CatalegComponent {
  constructor(private router: Router) {}
  mostrarVistaRapida(id: number): void {
    // Navegar mantenint outlet principal i afegint outlet lateral
    this.router.navigate([
      '/cataleg',
      { outlets: { sidebar: ['vista-rapida', id] } }
    ]);
  }
  tancarSidebar(): void {
    // Tancar outlet lateral (tornar a null)
    this.router.navigate([
      { outlets: { sidebar: null } }
    ]);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_159 %}
<h4>3.6.7. Casos d'ús de múltiples outlets</h4>
<p><strong>1. Detalls ràpids sense abandonar la llista</strong></p>
<ul>
<li>Outlet principal: Llista de productes</li>
<li>Outlet lateral: Detalls ràpids del producte seleccionat</li>
<li>Benefici: L'usuari pot veure detalls sense perdre la posició a la llista</li>
</ul>
<p><strong>2. Ajuda contextual persistent</strong></p>
<ul>
<li>Outlet principal: Formulari complex</li>
<li>Outlet lateral: Ajuda específica per a cada secció del formulari</li>
<li>Benefici: L'ajuda està sempre visible mentre es completa el formulari</li>
</ul>
<p><strong>3. Comparació de productes</strong></p>
<ul>
<li>Outlet principal: Catàleg</li>
<li>Outlet lateral: Producte A per comparar</li>
<li>Outlet modal: Producte B per comparar</li>
<li>Benefici: Veure 3 vistes simultànies per comparar</li>
</ul>
<h4>3.6.8. Limitacions i consideracions</h4>
<p><strong>Limitacions:</strong></p>
<ul>
<li>Les URLs amb outlets múltiples són llargues i poc amigables: <code>/cataleg(sidebar:vista-rapida/42)</code></li>
<li>No compartibles fàcilment (copiar URL amb outlets és confús)</li>
<li>Complexitat afegida (més difícil de mantenir)</li>
</ul>
<p><strong>Quan NO usar outlets múltiples:</strong></p>
<ul>
<li>Si podeu resoldre-ho amb components condicionals (<code>*ngIf</code>)</li>
<li>Si la UI secundària és simple (millor usar modals amb serveis)</li>
<li>Si mai necessiteu compartir la URL amb outlets actius</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> Els outlets múltiples permeten mostrar diverses vistes simultànies amb navegació independent. S'utilitzen per layouts complexos amb barres laterals, modals persistents o panells auxiliars. Les rutes amb outlets generen URLs amb notació especial <code>(outlet:ruta)</code>." %}
<h4>3.6.9. Resultat esperat</h4>
<p>Sabeu utilitzar outlets amb nom per mostrar múltiples vistes simultànies, definir rutes amb <code>outlet: 'nom'</code>, navegar amb sintaxi d'outlets i compreneu casos d'ús i limitacions.</p>
  {% endcapture %}
  {% include section-point.html numero="3.6" titol="Múltiples outlets: mostrar diverses vistes simultànies" contingut=section_point_3_6 %}

  {% capture section_point_3_7 %}
<h4>3.7.1. Objectiu</h4>
<p>Comprendre què són les guàrdies de ruta, per què són necessàries i els diferents tipus de guàrdies disponibles.</p>
<h4>3.7.2. Què són les guàrdies de ruta</h4>
<p>Les <strong>guàrdies de ruta</strong> (route guards) són mecanismes de protecció que executen lògica <strong>abans</strong> de permetre la navegació a una ruta. Permeten validar condicions com autenticació, permisos, estat de dades o lògica personalitzada, i redirigir automàticament si les condicions no es compleixen.</p>
<h4>3.7.3. Per què necessitem guàrdies</h4>
<p><strong>Problema sense guàrdies:</strong></p>
<p>Sense guàrdies, qualsevol usuari pot navegar a qualsevol ruta escrivint la URL al navegador:</p>
{% capture code_160 %}http://localhost:4300/admin/usuaris
→ Carrega el component AdminUsuarisComponent
→ Fins i tot si l'usuari NO està autenticat
→ Fins i tot si l'usuari NO és administrador{% endcapture %}
{% include code-block.html lang="text" code=code_160 %}
<p><strong>Conseqüències:</strong></p>
<ul>
<li><strong>Brecha de seguretat:</strong> Dades sensibles exposades visualment (encara que el backend refusi peticions, l'usuari veu la interfície)</li>
<li><strong>Experiència d'usuari horrible:</strong> L'usuari veu errors confusos del backend després de carregar la pàgina</li>
<li><strong>Recursos malgastats:</strong> Components es carreguen sempre, fins i tot si l'accés és denegat</li>
</ul>
<p><strong>Solució amb guàrdies:</strong></p>
<p>Les guàrdies s'executen <strong>abans</strong> de carregar el component. Si la validació falla, el component NO es carrega i l'usuari és redirigit automàticament:</p>
{% capture code_161 %}1. Usuari intenta navegar a /admin/usuaris
2. Guàrdia authGuard s'executa ABANS de carregar component
3. Guàrdia comprova: està autenticat? és admin?
4a. Si SÍ → Permet navegació, carrega component
4b. Si NO → Redirigeix a /login, component NO es carrega{% endcapture %}
{% include code-block.html lang="text" code=code_161 %}
<h4>3.7.4. Tipus de guàrdies disponibles</h4>
<p>Angular proporciona diversos tipus de guàrdies per diferents casos d'ús:</p>
<p><strong>1. CanActivate - Protegir accés a una ruta</strong></p>
<p>Executa lògica abans de <strong>permetre navegació</strong> a una ruta.</p>
<p><strong>Casos d'ús:</strong></p>
<ul>
<li>Comprovar si l'usuari està autenticat</li>
<li>Verificar permisos o rols</li>
<li>Validar que les dades necessàries estan disponibles</li>
</ul>
<p><strong>Exemple:</strong></p>
{% capture code_162 %}{
  path: 'admin',
  component: AdminComponent,
  canActivate: [authGuard, adminGuard]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_162 %}
<p><strong>2. CanDeactivate - Protegir sortida d'una ruta</strong></p>
<p>Executa lògica abans de <strong>permetre abandonar</strong> una ruta.</p>
<p><strong>Casos d'ús:</strong></p>
<ul>
<li>Avisar l'usuari si té canvis sense desar</li>
<li>Confirmar abans de sortir d'un formulari a mig omplir</li>
<li>Guardar estat abans d'abandonar la pàgina</li>
</ul>
<p><strong>3. CanActivateChild - Protegir rutes filles</strong></p>
<p>Similar a <code>CanActivate</code> però s'aplica a totes les rutes filles d'una ruta pare.</p>
{% capture code_163 %}{
  path: 'admin',
  component: AdminLayoutComponent,
  canActivateChild: [adminGuard],
  children: [
    { path: 'usuaris', component: AdminUsuarisComponent },  // Protegida
    { path: 'comandes', component: AdminComandesComponent }  // Protegida
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_163 %}
<p><strong>4. Resolve - Carregar dades abans de navegar</strong></p>
<p>Carrega dades necessàries <strong>abans</strong> de mostrar el component, evitant estats de càrrega intermedis.</p>
{% capture code_164 %}{
  path: 'perfil/:id',
  component: PerfilComponent,
  resolve: { perfil: perfilResolver }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_164 %}
<h4>3.7.5. Guàrdies funcionals vs classes</h4>
<p><strong>Guàrdies funcionals (recomanat - modern):</strong></p>
{% capture code_165 %}import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  if (authService.estaAutenticat()) {
    return true;  // Permet navegació
  }
  // Redirigeix a login
  return router.createUrlTree(['/login'], {
    queryParams: { returnUrl: state.url }
  });
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_165 %}
<p><strong>Guàrdies amb classes (antic - deprecated):</strong></p>
{% capture code_166 %}// Estil antic (deprecated a Angular 15+)
import { Injectable } from '@angular/core';
import { CanActivate } from '@angular/router';
@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  canActivate(): boolean {
    // ...
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_166 %}
<p><strong>Recomanació:</strong> Useu guàrdies funcionals. Són més simples, modernes i preferides per Angular.</p>
<h4>3.7.6. Com funcionen les guàrdies internament</h4>
<p><strong>Flux d'execució:</strong></p>
{% capture code_167 %}1. Usuari clica enllaç o escriu URL
2. Angular Router intercepta la navegació
3. Angular executa guàrdies en aquest ordre:
   a. CanMatch (si existeix)
   b. CanActivate (ruta pare)
   c. CanActivateChild (si hi ha filles)
   d. Resolve (si existeix)
4. Si alguna guàrdia retorna false o UrlTree:
   → Navegació cancel·lada o redirigida
5. Si totes retornen true:
   → Component es carrega i es renderitza{% endcapture %}
{% include code-block.html lang="text" code=code_167 %}
<p><strong>Valors de retorn de guàrdies:</strong></p>
{% capture code_168 %}// 1. Permetre navegació
return true;
// 2. Bloquejar navegació
return false;
// 3. Redirigir a altra ruta
return router.createUrlTree(['/login']);
// 4. Observable (per operacions asíncrones)
return this.authService.validarToken().pipe(
  map(valid => valid ? true : router.createUrlTree(['/login']))
);{% endcapture %}
{% include code-block.html lang="typescript" code=code_168 %}
<h4>3.7.7. Beneficis de les guàrdies</h4>
<p><strong>1. Seguretat millorada</strong></p>
<ul>
<li>Components sensibles NO es carreguen sense autorització</li>
<li>Dades confidencials NO s'exposen visualment</li>
</ul>
<p><strong>2. Experiència d'usuari fluida</strong></p>
<ul>
<li>Redireccions instantànies abans de carregar components</li>
<li>Sense errors confusos del backend</li>
</ul>
<p><strong>3. Centralització de lògica</strong></p>
<ul>
<li>Validació d'autenticació en un sol lloc</li>
<li>No cal repetir codi a cada component</li>
</ul>
<p><strong>4. Mantenibilitat</strong></p>
<ul>
<li>Canvis de lògica de permisos en una sola guàrdia</li>
<li>Reutilització de guàrdies en múltiples rutes</li>
</ul>
{% include success_box.html contingut="<strong>Clau:</strong> Les guàrdies són mecanismes de protecció que s'executen abans de la navegació per validar condicions. Permeten comprovar autenticació, permisos, estat de dades i redirigir automàticament si les condicions fallen. CanActivate és la guàrdia més comuna per protegir rutes." %}
<h4>3.7.8. Resultat esperat</h4>
<p>Compreneu què són les guàrdies, per què són necessàries per protegir rutes sensibles, els diferents tipus de guàrdies disponibles (CanActivate, CanDeactivate, Resolve) i com funcionen internament.</p>
  {% endcapture %}
  {% include section-point.html numero="3.7" titol="Què són les guàrdies: controls d'accés a rutes" contingut=section_point_3_7 %}

  {% capture section_point_3_8 %}
<h4>3.8.1. Objectiu</h4>
<p>Aprendre a crear guàrdies d'activació (CanActivate) per protegir rutes comprovant autenticació o permisos abans de carregar components.</p>
<h4>3.8.2. Què és CanActivate</h4>
<p>La guàrdia <strong>CanActivate</strong> és el tipus més comú. S'executa abans de navegar a una ruta i decideix si permet l'accés o redirigeix l'usuari.</p>
<h4>3.8.3. Crear una guàrdia funcional</h4>
<p><strong>Pas 1: Generar la guàrdia amb Angular CLI</strong></p>
{% capture code_169 %}# Windows (PowerShell)
Set-Location $env:USERPROFILE\workspace\catalog-elements
ng generate guard guards/auth
# macOS/Linux (bash/zsh)
cd ~/workspace/catalog-elements
ng generate guard guards/auth{% endcapture %}
{% include code-block.html lang="bash" code=code_169 %}
<p><strong>CLI preguntarà quin tipus de guàrdia:</strong> Seleccioneu <code>CanActivate</code>.</p>
<p><strong>Pas 2: Implementar la lògica de la guàrdia</strong></p>
<p><code>src/app/guards/auth.guard.ts</code>:</p>
{% capture code_170 %}import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  console.log('authGuard: Comprovant autenticació...');
  // Comprovar si l'usuari està autenticat
  if (authService.estaAutenticat()) {
    console.log('authGuard: Autenticat, accés permès');
    return true;  // Permet navegació
  }
  console.log('authGuard: NO autenticat, redirigint a login');
  // Redirigir a login amb returnUrl per tornar després
  return router.createUrlTree(['/login'], {
    queryParams: { returnUrl: state.url }
  });
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_170 %}
<p><strong>Paràmetres de la guàrdia:</strong></p>
<ul>
<li><strong><code>route: ActivatedRouteSnapshot</code></strong> - Informació de la ruta destinació</li>
<li><strong><code>state: RouterStateSnapshot</code></strong> - Estat actual del router (inclou la URL destinació)</li>
</ul>
<p><strong>Pas 3: Aplicar la guàrdia a rutes</strong></p>
<p><code>src/app/navegacio/app.routes.ts</code>:</p>
{% capture code_171 %}import { Routes } from '@angular/router';
import { authGuard } from '../guards/auth.guard';
export const routes: Routes = [
  { path: '', component: InicComponent },
  { path: 'cataleg', component: CatalegComponent },
  { path: 'login', component: LoginComponent },
  // Ruta protegida amb guàrdia
  {
    path: 'preferits',
    component: PreferitsComponent,
    canActivate: [authGuard]
  },
  // Rutes niades protegides
  {
    path: 'perfil',
    component: PerfilLayoutComponent,
    canActivate: [authGuard],
    children: [
      { path: 'configuracio', component: ConfiguracioComponent },
      { path: 'privacitat', component: PrivacitatComponent }
    ]
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_171 %}
<h4>3.8.4. Guàrdia amb validació de rols</h4>
<p>Creeu una segona guàrdia per comprovar si l'usuari és administrador:</p>
<p><code>src/app/guards/admin.guard.ts</code>:</p>
{% capture code_172 %}import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';
export const adminGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  // Assumeix que authGuard ja va validar autenticació
  if (authService.esAdmin()) {
    return true;  // És admin, accés permès
  }
  // No és admin → Redirigeix a inici
  return router.createUrlTree(['/'], {
    queryParams: { error: 'accés denegat' }
  });
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_172 %}
<p><strong>Aplicar múltiples guàrdies:</strong></p>
{% capture code_173 %}{
  path: 'admin',
  component: AdminLayoutComponent,
  canActivate: [authGuard, adminGuard],
  children: [
    { path: 'usuaris', component: AdminUsuarisComponent }
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_173 %}
<p><strong>Ordre d'execució:</strong> <code>authGuard</code> primer → si passa, <code>adminGuard</code> segon → si passa, carrega component.</p>
<h4>3.8.5. Guàrdies asíncrones amb Observable</h4>
<p>Si la validació requereix operacions asíncrones (per exemple, validar token amb el backend):</p>
{% capture code_174 %}import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';
import { map } from 'rxjs/operators';
export const authGuardAsync: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  // Retornar Observable<boolean | UrlTree>
  return authService.validarToken().pipe(
    map(valid => {
      if (valid) {
        return true;
      }
      return router.createUrlTree(['/login'], {
        queryParams: { returnUrl: state.url }
      });
    })
  );
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_174 %}
{% include success_box.html contingut="<strong>Clau:</strong> Les guàrdies CanActivate s'executen abans de carregar components per validar condicions. Retornen <code>true</code> per permetre navegació, <code>false</code> per bloquejar, o <code>UrlTree</code> per redirigir. Poden ser síncrones o asíncrones (Observable). Múltiples guàrdies s'executen en ordre." %}
<h4>3.8.6. Resultat esperat</h4>
<p>Sabeu crear guàrdies d'activació per protegir rutes, implementar lògica de validació d'autenticació i rols, aplicar guàrdies a rutes i crear guàrdies asíncrones amb Observables.</p>
  {% endcapture %}
  {% include section-point.html numero="3.8" titol="Guàrdia d'activació: comprovar abans d'entrar a una ruta" contingut=section_point_3_8 %}

  {% capture section_point_3_9 %}
<h4>3.9.1. Objectiu</h4>
<p>Implementar un sistema complet de protecció de rutes amb autenticació simulada, login, logout i guàrdies funcionals.</p>
<p>Crearem un flux complet: usuari NO autenticat intenta accedir a <code>/preferits</code> → redirigeix a <code>/login</code> → després de login → retorna a <code>/preferits</code>.</p>
<h4>3.9.2. Pas 1: Crear el servei d'autenticació complet</h4>
<p><code>src/app/services/auth.service.ts</code> (versió completa):</p>
{% capture code_175 %}import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, of, delay } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Usuari {
  id: number;
  nom: string;
  email: string;
  rol: 'usuari' | 'admin';
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private usuariActual$ = new BehaviorSubject<Usuari | null>(null);

  constructor() {
    // Recuperar usuari de localStorage si existeix
    const usuariDesat = localStorage.getItem('usuari');
    if (usuariDesat) {
      this.usuariActual$.next(JSON.parse(usuariDesat));
    }
  }

  estaAutenticat(): boolean {
    return this.usuariActual$.value !== null;
  }

  obtenirUsuari(): Observable<Usuari | null> {
    return this.usuariActual$.asObservable();
  }

  login(email: string, password: string): Observable<boolean> {
    // Simulació d'autenticació asíncrona (API)
    return of(true).pipe(
      delay(500),  // Simular latència
      // En producció, aquí feu una crida a l'API real
      map(() => {
        if (email && password) {
          const usuari: Usuari = {
            id: 1,
            nom: email.split('@')[0],
            email,
            rol: email.includes('admin') ? 'admin' : 'usuari'
          };
          this.usuariActual$.next(usuari);
          localStorage.setItem('usuari', JSON.stringify(usuari));
          return true;
        }
        return false;
      })
    );
  }

  logout(): void {
    this.usuariActual$.next(null);
    localStorage.removeItem('usuari');
  }

  esAdmin(): boolean {
    return this.usuariActual$.value?.rol === 'admin';
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_175 %}
<h4>3.9.3. Pas 2: Crear component de login amb estat de càrrega</h4>
<p><code>src/app/login/login.component.ts</code>:</p>
{% capture code_176 %}import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss']
})
export class LoginComponent {
  email = '';
  password = '';
  error = '';
  carregant = false;

  constructor(
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  login(): void {
    this.error = '';
    this.carregant = true;

    this.authService.login(this.email, this.password).subscribe({
      next: (exit) => {
        if (exit) {
          // Login exitós → Navegar a returnUrl o inici
          const returnUrl = this.route.snapshot.queryParamMap.get('returnUrl') ?? '/';
          this.router.navigateByUrl(returnUrl);
        } else {
          this.error = 'Credencials incorrectes';
          this.carregant = false;
        }
      },
      error: (err) => {
        console.error('Error al fer login:', err);
        this.error = 'Error al connectar amb el servidor';
        this.carregant = false;
      }
    });
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_176 %}
<p><code>src/app/login/login.component.html</code>:</p>
{% capture code_177 %}{% raw %}<div class="login-container">
  <div class="login-card">
    <h1>Iniciar sessió</h1>
    <p class="subtitol">Accedeix al teu compte</p>

    <form (ngSubmit)="login()" #loginForm="ngForm">
      <div class="camp">
        <label for="email">Email:</label>
        <input
          type="email"
          id="email"
          [(ngModel)]="email"
          name="email"
          placeholder="nom@exemple.com"
          required
          [disabled]="carregant">
      </div>

      <div class="camp">
        <label for="password">Contrasenya:</label>
        <input
          type="password"
          id="password"
          [(ngModel)]="password"
          name="password"
          placeholder="••••••••"
          required
          [disabled]="carregant">
      </div>

      <p *ngIf="error" class="error">{{ error }}</p>

      <button
        type="submit"
        [disabled]="loginForm.invalid || carregant"
        class="btn-login">
        {{ carregant ? 'Entrant...' : 'Entrar' }}
      </button>

      <div class="ajuda">
        <p>Per provar, usa qualsevol email i contrasenya</p>
        <p class="hint">Email amb "admin" → Rol d'administrador</p>
      </div>
    </form>
  </div>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_177 %}
<h4>3.9.4. Pas 3: Afegir botó de logout al menú</h4>
<p><code>src/app/app.component.ts</code>:</p>
{% capture code_178 %}import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet, RouterLink, Router } from '@angular/router';
import { AuthService, Usuari } from './services/auth.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, RouterOutlet, RouterLink],
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {
  usuari$!: Observable<Usuari | null>;

  constructor(
    private authService: AuthService,
    private router: Router
  ) {}

  ngOnInit(): void {
    this.usuari$ = this.authService.obtenirUsuari();
  }

  logout(): void {
    this.authService.logout();
    this.router.navigate(['/']);
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_178 %}
<p><code>src/app/app.component.html</code>:</p>
{% capture code_179 %}{% raw %}<div class="app">
  <nav class="menu-principal">
    <a routerLink="/" routerLinkActive="actiu" [routerLinkActiveOptions]="{exact: true}">
      Inici
    </a>
    <a routerLink="/cataleg" routerLinkActive="actiu">
      Catàleg
    </a>
    <a routerLink="/preferits" routerLinkActive="actiu">
      Preferits
    </a>

    <div class="auth-status" *ngIf="usuari$ | async as usuari; else noAutenticat">
      <span class="usuari-nom">Hola, {{ usuari.nom }}</span>
      <button (click)="logout()" class="btn-logout">Sortir</button>
    </div>

    <ng-template #noAutenticat>
      <a routerLink="/login" routerLinkActive="actiu" class="btn-login">
        Iniciar sessió
      </a>
    </ng-template>
  </nav>

  <main class="contingut">
    <router-outlet></router-outlet>
  </main>
</div>{% endraw %}{% endcapture %}
{% include code-block.html lang="html" code=code_179 %}
<h4>3.9.5. Pas 4: Protegir rutes amb la guàrdia</h4>
<p><code>src/app/navegacio/app.routes.ts</code>:</p>
{% capture code_180 %}import { Routes } from '@angular/router';
import { authGuard } from '../guards/auth.guard';

export const routes: Routes = [
  { path: '', component: InicComponent },
  { path: 'cataleg', component: CatalegComponent },
  { path: 'element/:id', component: DetallElementComponent },
  { path: 'login', component: LoginComponent },

  // Ruta protegida
  {
    path: 'preferits',
    component: PreferitsComponent,
    canActivate: [authGuard]
  },

  // Secció protegida amb rutes niades
  {
    path: 'perfil',
    component: PerfilLayoutComponent,
    canActivate: [authGuard],
    children: [
      { path: '', redirectTo: 'configuracio', pathMatch: 'full' },
      { path: 'configuracio', component: ConfiguracioComponent },
      { path: 'privacitat', component: PrivacitatComponent }
    ]
  }
];{% endcapture %}
{% include code-block.html lang="typescript" code=code_180 %}
<h4>3.9.6. Pas 5: Verificació manual del flux complet</h4>
<p><strong>Test 1: Accés sense autenticació</strong></p>
<ol>
<li>Obrir <code>http://localhost:4300/preferits</code></li>
<li>Resultat esperat: Redirigeix a <code>/login?returnUrl=/preferits</code></li>
</ol>
<p><strong>Test 2: Login i returnUrl</strong></p>
<ol>
<li>A <code>/login</code>, introduir email: <code>test@test.com</code>, password: <code>test</code></li>
<li>Clicar "Entrar"</li>
<li>Resultat esperat: Redirigeix automàticament a <code>/preferits</code></li>
</ol>
<p><strong>Test 3: Logout</strong></p>
<ol>
<li>Estant autenticat, clicar "Sortir" al menú</li>
<li>Resultat esperat: Desconnecta i navega a <code>/</code></li>
<li>Intentar accedir a <code>/preferits</code></li>
<li>Resultat esperat: Redirigeix a <code>/login</code></li>
</ol>
<p><strong>Test 4: Persistència amb localStorage</strong></p>
<ol>
<li>Fer login</li>
<li>Recarregar la pàgina (F5)</li>
<li>Resultat esperat: L'usuari continua autenticat (dades a localStorage)</li>
</ol>
<p><strong>Test 5: Navegació directa a ruta protegida</strong></p>
<ol>
<li>Estant NO autenticat, escriure URL <code>/perfil/configuracio</code></li>
<li>Resultat esperat: Redirigeix a <code>/login?returnUrl=/perfil/configuracio</code></li>
<li>Després de login: Retorna a <code>/perfil/configuracio</code></li>
</ol>
{% include success_box.html contingut="<strong>Clau:</strong> Un sistema complet d'autenticació amb guàrdies inclou: servei d'autenticació amb persistència (localStorage), guàrdies per protegir rutes, component de login amb returnUrl, i menú dinàmic que mostra estat d'autenticació amb opció de logout." %}
<h4>3.9.7. Resultat esperat</h4>
<p>Sabeu implementar un sistema complet de protecció de rutes amb autenticació, login/logout, returnUrl per preservar destinació, persistència amb localStorage i menú dinàmic segons l'estat d'autenticació.</p>
  {% endcapture %}
  {% include section-point.html numero="3.9" titol="Exemple pràctic: protegir rutes per a usuaris autenticats" contingut=section_point_3_9 %}

  {% capture section_point_3_10 %}
<h4>3.10.1. Objectiu</h4>
<p>Conèixer altres tipus de guàrdies disponibles (CanDeactivate, Resolve) i els seus casos d'ús.</p>
<p>A més de <code>CanActivate</code>, Angular proporciona altres guàrdies per casos específics:</p>
<h4>3.10.2. CanDeactivate - Protegir sortida de rutes</h4>
<p>Aquesta guàrdia s'executa abans de <strong>sortir</strong> d'una ruta. És útil per avisar l'usuari si té canvis sense desar.</p>
<p><strong>Cas d'ús:</strong> Formulari amb canvis no desats.</p>
<p><code>src/app/guards/canvis-no-desats.guard.ts</code>:</p>
{% capture code_181 %}import { CanDeactivateFn } from '@angular/router';

export interface ComponentAmbCanvis {
  teCanvisNoDesats(): boolean;
}

export const canvisNoDesatsGuard: CanDeactivateFn<ComponentAmbCanvis> = (component) => {
  if (component.teCanvisNoDesats()) {
    return confirm('Tens canvis sense desar. Vols sortir igualment?');
  }
  return true;
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_181 %}
<p><strong>Component que implementa la interfície:</strong></p>
{% capture code_182 %}import { Component } from '@angular/core';
import { ComponentAmbCanvis } from '../guards/canvis-no-desats.guard';

@Component({...})
export class EditarPerfilComponent implements ComponentAmbCanvis {
  formulariModificat = false;

  teCanvisNoDesats(): boolean {
    return this.formulariModificat;
  }

  onInputChange(): void {
    this.formulariModificat = true;
  }

  desar(): void {
    // Desar canvis...
    this.formulariModificat = false;
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_182 %}
<p><strong>Aplicar la guàrdia:</strong></p>
{% capture code_183 %}{
  path: 'editar-perfil',
  component: EditarPerfilComponent,
  canDeactivate: [canvisNoDesatsGuard]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_183 %}
<p><strong>Resultat:</strong> Si l'usuari intenta sortir amb canvis no desats, apareix un diàleg de confirmació.</p>
<h4>3.10.3. Resolve - Carregar dades abans de navegar</h4>
<p>Aquesta guàrdia carrega dades <strong>abans</strong> de mostrar el component, evitant estats de càrrega intermedis.</p>
<p><strong>Cas d'ús:</strong> Pre-carregar dades d'usuari abans de mostrar perfil.</p>
<p><code>src/app/resolvers/perfil.resolver.ts</code>:</p>
{% capture code_184 %}import { inject } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { UsuarisService } from '../services/usuaris.service';
import { Usuari } from '../models/usuari.interface';

export const perfilResolver: ResolveFn<Usuari> = (route, state) => {
  const usuarisService = inject(UsuarisService);
  const id = Number(route.paramMap.get('id'));

  // Retorna Observable: Angular espera que es resolgui abans de navegar
  return usuarisService.obtenirPerID(id);
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_184 %}
<p><strong>Aplicar el resolver:</strong></p>
{% capture code_185 %}{
  path: 'perfil/:id',
  component: PerfilComponent,
  resolve: { perfil: perfilResolver }  // 'perfil' és la clau
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_185 %}
<p><strong>Component accedeix a les dades resueltes:</strong></p>
{% capture code_186 %}import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Usuari } from '../models/usuari.interface';

@Component({...})
export class PerfilComponent implements OnInit {
  perfil!: Usuari;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    // Dades ja carregades pel resolver
    this.perfil = this.route.snapshot.data['perfil'];
    console.log('Perfil carregat:', this.perfil);
    // NO cal mostrar estat de càrrega!
  }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_186 %}
<p><strong>Avantatge:</strong> El component es carrega amb dades ja disponibles. NO cal gestionar estats de càrrega (<code>carregant = true</code>).</p>
<h4>3.10.4. CanActivateChild - Protegir totes les rutes filles</h4>
<p>Similar a <code>CanActivate</code> però s'aplica a totes les rutes filles d'una ruta pare.</p>
{% capture code_187 %}{
  path: 'admin',
  component: AdminLayoutComponent,
  canActivateChild: [adminGuard],  // Protegeix TOTES les filles
  children: [
    { path: 'usuaris', component: AdminUsuarisComponent },     // Protegida
    { path: 'comandes', component: AdminComandesComponent },   // Protegida
    { path: 'logs', component: AdminLogsComponent }            // Protegida
  ]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_187 %}
<p><strong>Diferència amb <code>canActivate</code> al pare:</strong></p>
<ul>
<li><code>canActivate</code>: Protegeix la ruta pare i les filles</li>
<li><code>canActivateChild</code>: Només protegeix les filles, NO el pare</li>
</ul>
<h4>3.10.5. Taula comparativa de guàrdies</h4>
<table>
<thead>
<tr>
<th>Guàrdia</th>
<th>Quan s'executa</th>
<th>Cas d'ús</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CanActivate</strong></td>
<td>Abans d'entrar a una ruta</td>
<td>Comprovar autenticació, permisos</td>
</tr>
<tr>
<td><strong>CanDeactivate</strong></td>
<td>Abans de sortir d'una ruta</td>
<td>Avisar canvis no desats</td>
</tr>
<tr>
<td><strong>CanActivateChild</strong></td>
<td>Abans d'entrar a rutes filles</td>
<td>Protegir tota una secció (admin)</td>
</tr>
<tr>
<td><strong>Resolve</strong></td>
<td>Abans d'entrar, després de guards</td>
<td>Pre-carregar dades necessàries</td>
</tr>
<tr>
<td><strong>CanMatch</strong></td>
<td>Abans de matching de ruta</td>
<td>Decidir si ruta coincideix (avançat)</td>
</tr>
</tbody>
</table>
{% include success_box.html contingut="<strong>Clau:</strong> CanDeactivate protegeix sortides de rutes (avisos de canvis no desats). Resolve pre-carrega dades abans de mostrar components (sense estats de càrrega intermedis). CanActivateChild protegeix totes les rutes filles sense repetir guards." %}
<h4>3.10.6. Resultat esperat</h4>
<p>Coneixeu altres tipus de guàrdies (CanDeactivate, Resolve, CanActivateChild), sabeu quan usar-les i podeu implementar protecció de sortides i pre-càrrega de dades.</p>
  {% endcapture %}
  {% include section-point.html numero="3.10" titol="Altres tipus de guàrdies: sortida, càrrega de dades" contingut=section_point_3_10 %}

  {% capture section_point_3_11 %}
<h4>3.11.1. Objectiu</h4>
<p>Consolidar el coneixement sobre guàrdies amb recomanacions de bones pràctiques i patrons d'ús.</p>
<h4>3.11.2. Quan usar guàrdies</h4>
<p><strong>Usar guàrdies quan:</strong></p>
<ol>
<li><strong>Protegir rutes sensibles</strong> - Admin, configuració, dades privades</li>
<li><strong>Validar autenticació</strong> - Comprovar si l'usuari té sessió abans de carregar components</li>
<li><strong>Verificar permisos/rols</strong> - Assegurar que l'usuari té els permisos necessaris</li>
<li><strong>Avisar canvis no desats</strong> - Evitar pèrdua de dades en formularis</li>
<li><strong>Pre-carregar dades crítiques</strong> - Dades necessàries per renderitzar el component</li>
</ol>
<p><strong>NO usar guàrdies quan:</strong></p>
<ol>
<li><strong>Validacions simples dins del component</strong> - Si la lògica és específica d'un component, millor a <code>ngOnInit</code></li>
<li><strong>Rutes completament públiques</strong> - No cal protecció</li>
<li><strong>Validacions de negoci complexes</strong> - Millor dins del component on teniu accés a tot l'estat</li>
</ol>
<h4>3.11.3. Bones pràctiques</h4>
<p><strong>1. Centralitzar lògica de validació</strong></p>
<p>NO repetir lògica d'autenticació a cada component. Crear una guàrdia reutilitzable:</p>
{% capture code_188 %}// INCORRECTE: Validació duplicada a cada component
export class PreferitsComponent {
  ngOnInit() {
    if (!this.authService.estaAutenticat()) {
      this.router.navigate(['/login']);
    }
  }
}

// CORRECTE: Guàrdia reutilitzable
export const authGuard: CanActivateFn = ...
// Aplicar a múltiples rutes sense duplicar codi{% endcapture %}
{% include code-block.html lang="typescript" code=code_188 %}
<p><strong>2. Retornar UrlTree en lloc de false + navigate</strong></p>
{% capture code_189 %}// INCORRECTE: Navegar manualment + retornar false
export const authGuard: CanActivateFn = (route, state) => {
  if (!authService.estaAutenticat()) {
    router.navigate(['/login']);
    return false;
  }
  return true;
};

// CORRECTE: Retornar UrlTree (més net)
export const authGuard: CanActivateFn = (route, state) => {
  if (!authService.estaAutenticat()) {
    return router.createUrlTree(['/login']);
  }
  return true;
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_189 %}
<p><strong>3. Passar returnUrl per preservar destinació</strong></p>
{% capture code_190 %}// Sempre passar returnUrl
return router.createUrlTree(['/login'], {
  queryParams: { returnUrl: state.url }
});{% endcapture %}
{% include code-block.html lang="typescript" code=code_190 %}
<p><strong>4. Combinar guàrdies per validacions en cadena</strong></p>
{% capture code_191 %}// Separar autenticació i permisos en guàrdies diferents
{
  path: 'admin',
  canActivate: [authGuard, adminGuard]  // Ordre: auth → admin
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_191 %}
<p><strong>5. Usar resolvers per pre-càrrega en lloc de càrrega manual</strong></p>
{% capture code_192 %}// INCORRECTE: Càrrega manual al component
export class PerfilComponent {
  perfil?: Usuari;
  carregant = true;

  ngOnInit() {
    this.service.obtenirPerfil().subscribe(perfil => {
      this.perfil = perfil;
      this.carregant = false;
    });
  }
}

// CORRECTE: Resolver pre-carrega dades
export const perfilResolver: ResolveFn<Usuari> = ...
// Component rep dades ja carregades{% endcapture %}
{% include code-block.html lang="typescript" code=code_192 %}
<p><strong>6. Gestionar errors en guàrdies asíncrones</strong></p>
{% capture code_193 %}// Gestionar errors en validacions asíncrones
export const authGuardAsync: CanActivateFn = (route, state) => {
  return authService.validarToken().pipe(
    map(valid => valid ? true : router.createUrlTree(['/login'])),
    catchError(() => {
      // Error de xarxa → Redirigir a error
      return of(router.createUrlTree(['/error']));
    })
  );
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_193 %}
<p><strong>7. Documentar guards amb comentaris</strong></p>
{% capture code_194 %}/**
 * Guàrdia d'autenticació que comprova si l'usuari té sessió activa.
 * Si NO està autenticat, redirigeix a /login amb returnUrl.
 *
 * @usage
 * { path: 'preferits', canActivate: [authGuard] }
 */
export const authGuard: CanActivateFn = (route, state) => {
  // ...
};{% endcapture %}
{% include code-block.html lang="typescript" code=code_194 %}
<h4>3.11.4. Patrons d'ús comuns</h4>
<p><strong>Patró 1: Protecció d'àrea completa (admin)</strong></p>
{% capture code_195 %}{
  path: 'admin',
  canActivate: [authGuard, adminGuard],
  canActivateChild: [adminGuard],  // Doble protecció
  children: [...]
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_195 %}
<p><strong>Patró 2: Login amb returnUrl</strong></p>
{% capture code_196 %}// Guàrdia
return router.createUrlTree(['/login'], {
  queryParams: { returnUrl: state.url }
});

// Component login
const returnUrl = this.route.snapshot.queryParamMap.get('returnUrl') ?? '/';
this.router.navigateByUrl(returnUrl);{% endcapture %}
{% include code-block.html lang="typescript" code=code_196 %}
<p><strong>Patró 3: Avisos de canvis no desats</strong></p>
{% capture code_197 %}// Guàrdia CanDeactivate amb interfície
export interface ComponentAmbCanvis {
  teCanvisNoDesats(): boolean;
}

// Component implementa interfície
export class FormulariComponent implements ComponentAmbCanvis {
  formulariModificat = false;
  teCanvisNoDesats() { return this.formulariModificat; }
}{% endcapture %}
{% include code-block.html lang="typescript" code=code_197 %}
{% include success_box.html contingut="<strong>Clau:</strong> Usar guàrdies per centralitzar validacions d'autenticació i permisos, retornar UrlTree en lloc de false + navigate, passar returnUrl per preservar destinació, combinar guàrdies per validacions en cadena i usar resolvers per pre-càrrega de dades." %}
<h4>3.11.5. Resultat esperat</h4>
<p>Coneixeu les bones pràctiques per usar guàrdies efectivament: centralització, returnUrl, combinació de guàrdies, gestió d'errors i patrons d'ús comuns.</p>
  {% endcapture %}
  {% include section-point.html numero="3.11" titol="Bones pràctiques: quan i com usar guàrdies" contingut=section_point_3_11 %}

  {% capture section_point_3_12 %}
<h3>Mini exemple pràctic: Rutes niades amb guàrdies</h3>
{% include checklist.html elements="Crear secció de perfil amb layout compartit amb menú lateral de sub-seccions (configuració, privacitat)|Definir rutes niades amb <code>children</code> per <code>/perfil/configuracio</code> i <code>/perfil/privacitat</code>|Implementar component pare amb <code>&lt;router-outlet&gt;</code> per renderitzar rutes filles|Crear guàrdia d'autenticació que comprova si l'usuari està autenticat abans de carregar perfil|Aplicar guàrdia al pare per protegir totes les rutes filles automàticament|Crear component de login amb returnUrl per preservar destinació després d'autenticar|Afegir botó de logout al menú principal que desconnecta i redirigeix a inici|Testejar flux complet sense auth → redirecció login → després login → retorn a destinació" %}
<p><strong>Resultat esperat:</strong> Secció de perfil amb sub-pàgines que comparteixen layout, protegida amb guàrdia que redirigeix a login si NO autenticat, i returnUrl que preserva destinació després de login exitós.</p>
  {% endcapture %}
  {% include section-point.html numero="3.12" titol="Mini exemple pràctic · Rutes niades amb guàrdies" contingut=section_point_3_12 %}

  {% capture section_point_3_13 %}
<h4>3.13.1. Problemes transversals</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució Windows</th>
<th>Solució macOS/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rutes filles NO es renderitzen</td>
<td>Falta <code>&lt;router-outlet&gt;</code> al component pare</td>
<td>Afegir <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> al template del pare</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Error "Cannot match any routes" amb rutes niades</td>
<td>Rutes filles definides amb barra inicial</td>
<td>Eliminar <code>/</code> inicial: <code>path: 'usuaris'</code> en lloc de <code>path: '/usuaris'</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Guàrdia NO s'executa</td>
<td>Guàrdia no aplicada correctament a la ruta</td>
<td>Verificar <code>canActivate: [nomGuardia]</code> a la definició de ruta</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Redirecció infinita amb guàrdies</td>
<td>Guàrdia redirigeix a ruta que també té la guàrdia</td>
<td>Excloure ruta de login de la guàrdia: <code>if (state.url === '/login') return true;</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Component pare es carrega però filles NO</td>
<td><code>children: []</code> buit o mal definit</td>
<td>Verificar sintaxi de <code>children</code> amb array de rutes</td>
<td>Igual que Windows</td>
</tr>
</tbody>
</table>
<h4>3.13.2. Problemes de configuració</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució Windows</th>
<th>Solució macOS/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>Error "No provider for ActivatedRoute" en guàrdia</td>
<td>Intentar injectar ActivatedRoute a guàrdia</td>
<td>Usar paràmetres de guàrdia: <code>route: ActivatedRouteSnapshot</code> en lloc d'injectar</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Guàrdia asíncrona NO espera Observable</td>
<td>Retornar Observable però Angular no espera</td>
<td>Assegurar que la guàrdia retorna <code>Observable&lt;boolean | UrlTree&gt;</code>, NO <code>.subscribe()</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>UrlTree NO redirigeix</td>
<td>Retornar UrlTree però usar també navigate</td>
<td>Eliminar <code>router.navigate()</code>, només retornar <code>router.createUrlTree()</code></td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>Múltiples guàrdies: només s'executa primera</td>
<td>Error a primera guàrdia impedeix execució de següents</td>
<td>Verificar que primera guàrdia retorna valor vàlid (true/UrlTree)</td>
<td>Igual que Windows</td>
</tr>
<tr>
<td>returnUrl NO funciona després de login</td>
<td>NO capturar queryParam correctament</td>
<td>Verificar: <code>this.route.snapshot.queryParamMap.get('returnUrl')</code></td>
<td>Igual que Windows</td>
</tr>
</tbody>
</table>
<h4>3.13.3. Problemes de dependències</h4>
<table>
<thead>
<tr>
<th>Símptoma</th>
<th>Causa probable</th>
<th>Solució</th>
</tr>
</thead>
<tbody>
<tr>
<td>Error "inject() must be called from an injection context"</td>
<td>Usar inject() fora de context d'injecció</td>
<td>Només usar <code>inject()</code> dins del body de guàrdies funcionals, NO dins de callbacks</td>
</tr>
<tr>
<td>RouterOutlet no reconegut en template</td>
<td>NO importat RouterOutlet al component</td>
<td>Afegir <code>RouterOutlet</code> als imports del component standalone</td>
</tr>
<tr>
<td>Guàrdia sempre retorna false</td>
<td>Lògica invertida o servei no injectat</td>
<td>Afegir logs: <code>console.log('Validant...')</code> per debugar el flux</td>
</tr>
<tr>
<td>Rutes niades amb paràmetres NO capturen ID</td>
<td>Capturar a ruta filla en lloc de pare</td>
<td>Capturar a component pare: <code>this.route.snapshot.paramMap.get('id')</code></td>
</tr>
<tr>
<td>CanDeactivate NO funciona</td>
<td>Component no implementa interfície</td>
<td>Assegurar que component implementa <code>ComponentAmbCanvis</code></td>
</tr>
</tbody>
</table>
  {% endcapture %}
  {% include section-point.html numero="3.13" titol="Resolució de problemes" contingut=section_point_3_13 %}

  {% capture section_point_3_14 %}
<h4>3.14.1. Prompt 1: Dissenyar arquitectura de rutes niades</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un arquitecte d'aplicacions Angular expert en organització de rutes i guàrdies.<br><br><strong>Context:</strong> Tinc una aplicació amb les següents seccions: inici (pública), catàleg (pública), perfil d'usuari (privada amb sub-seccions: configuració, privacitat, historial), i administració (només admins, amb sub-seccions: usuaris, comandes, estadístiques).<br><br><strong>Task:</strong> Dissenya l'estructura completa de rutes niades amb guàrdies:<br>1. Definició de rutes amb <code>children</code> per seccions amb sub-pàgines<br>2. Components de layout per compartir estructura entre sub-pàgines<br>3. Guàrdies necessàries (autenticació, rol admin)<br>4. On aplicar cada guàrdia (pare vs filles)<br>5. Estratègia de returnUrl per login<br><br><strong>Format:</strong> Codi TypeScript complet per <code>app.routes.ts</code>, diagrama de jerarquia de rutes i comentaris explicatius." %}
<h4>3.14.2. Prompt 2: Depurar problema de guàrdies</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un expert en debugging d'aplicacions Angular.<br><br><strong>Context:</strong> He creat una guàrdia d'autenticació [adjuntar codi de guàrdia] i l'he aplicat a una ruta [adjuntar app.routes.ts]. Quan intento navegar a la ruta protegida, obtinc una redirecció infinita: <code>/preferits</code> → <code>/login</code> → <code>/preferits</code> → <code>/login</code>...<br><br><strong>Task:</strong> Diagnostica el problema i proposa solucions:<br>1. Analitza el codi de la guàrdia per identificar lògica incorrecta<br>2. Comprova si la ruta <code>/login</code> també té la guàrdia aplicada (error comú)<br>3. Verifica la lògica de returnUrl<br>4. Proposa codi corregit amb validacions per evitar redireccions infinites<br>5. Suggereix tests manuals per verificar el flux<br><br><strong>Format:</strong> Llista numerada amb cada possible causa, solució proposada i codi corregit amb comentaris." %}
<h4>3.14.3. Prompt 3: Implementar sistema complet d'autenticació</h4>
{% include prompt-ai.html contingut="<strong>Role:</strong> Ets un desenvolupador Angular expert en autenticació i guàrdies.<br><br><strong>Context:</strong> Necessito implementar un sistema complet d'autenticació per a l'aplicació <code>catalog-elements</code> amb: servei d'autenticació amb persistència (localStorage), guàrdia per protegir rutes, component de login amb returnUrl, i menú dinàmic que mostra nom d'usuari i botó de logout.<br><br><strong>Task:</strong> Genera el codi complet per:<br>1. Servei AuthService amb login/logout i estat d'usuari (Observable)<br>2. Guàrdia authGuard que comprova autenticació i redirigeix amb returnUrl<br>3. Component LoginComponent amb formulari i gestió de returnUrl<br>4. Modificacions a AppComponent per mostrar estat d'autenticació al menú<br>5. Rutes protegides amb la guàrdia aplicada<br><br><strong>Format:</strong> Codi TypeScript complet per cada fitxer amb comentaris explicatius i instruccions de verificació manual del flux." %}
  {% endcapture %}
  {% include section-point.html numero="3.14" titol="Prompts d'IA" contingut=section_point_3_14 %}

  {% capture section_point_3_15 %}
<h4>3.15.1. Criteris objectius (Definition of Done)</h4>
<p><strong>Funcionalitat:</strong></p>
{% include checklist.html elements="He creat rutes niades amb <code>children</code> i funcionen correctament|He implementat un component pare amb <code>&lt;router-outlet&gt;</code> que renderitza rutes filles|He creat una guàrdia d'autenticació que protegeix rutes sensibles|He implementat redirecció amb returnUrl per preservar destinació|He afegit funcionalitat de login i logout amb persistència (localStorage)" %}
<p><strong>Projecte i estructura:</strong></p>
{% include checklist.html elements="Les rutes niades tenen layout compartit sense duplicació de codi|Les guàrdies centralitzen validacions sense repetir lògica a components|He aplicat guàrdies al pare per protegir totes les rutes filles automàticament|He documentat a <code>docs/navegacio.md</code> les rutes protegides i les guàrdies aplicades" %}
<p><strong>Control de versions:</strong></p>
{% include checklist.html elements="He inicialitzat repositori Git local si no existia|He fet commit amb el missatge \"feat: implementar rutes niades i guàrdies d'autenticació\"|He publicat els canvis a GitHub correctament" %}
<p><strong>Experiència d'usuari:</strong></p>
{% include checklist.html elements="La navegació entre sub-seccions és fluida sense recarregar layout compartit|L'usuari és redirigit immediatament a login si intenta accedir a rutes protegides sense autenticació|Després de login, l'usuari retorna automàticament a la destinació original (returnUrl)|El menú mostra l'estat d'autenticació amb nom d'usuari i opció de logout" %}
<h4>3.15.2. Competències adquirides</h4>
<p><strong>Rutes niades:</strong></p>
{% include checklist.html elements="Sé definir rutes niades amb la propietat <code>children</code>|Sé crear components pare amb <code>&lt;router-outlet&gt;</code> per renderitzar filles|Entenc com Angular concatena paths pare+filla per generar URLs|Sé configurar rutes per defecte dins de <code>children</code> amb redirectTo" %}
<p><strong>Guàrdies de ruta:</strong></p>
{% include checklist.html elements="Sé crear guàrdies funcionals amb <code>CanActivateFn</code>|Sé aplicar guàrdies a rutes amb <code>canActivate: [nomGuardia]</code>|Entenc la diferència entre CanActivate, CanDeactivate i Resolve|Sé retornar UrlTree per redirigir des de guàrdies" %}
<p><strong>Autenticació:</strong></p>
{% include checklist.html elements="Sé implementar un servei d'autenticació amb estat observable|Sé crear una guàrdia que comprova autenticació abans de carregar components|Sé passar returnUrl per preservar destinació després de login|Sé implementar logout que neteja estat i redirigeix a inici" %}
<p><strong>Organització i bones pràctiques:</strong></p>
{% include checklist.html elements="Sé quan usar rutes niades vs planes segons la complexitat de l'aplicació|Sé combinar múltiples guàrdies per validacions en cadena (auth → admin)|Entenc l'herència de guàrdies: rutes filles hereten guàrdies del pare|Sé centralitzar validacions en guàrdies en lloc de repetir-les a components" %}
<p><strong>Debugging i casos límit:</strong></p>
{% include checklist.html elements="Sé diagnosticar problemes de rutes filles que NO es renderitzen (falta router-outlet)|Sé evitar redireccions infinites amb guàrdies (excloure ruta de login)|Sé gestionar errors en guàrdies asíncrones amb catchError|Sé testejar manualment el flux complet d'autenticació amb diferents escenaris" %}
  {% endcapture %}
  {% include section-point.html numero="3.15" titol="Autoavaluació" contingut=section_point_3_15 %}

  {% capture section_point_3_16 %}
<h3>Què hem aconseguit</h3>
<p>Heu implementat rutes niades amb layouts compartits i guàrdies de protecció al projecte <code>catalog-elements</code>, creant una arquitectura escalable i segura per aplicacions complexes.</p>
<p>Disposeu d'una <strong>aplicació Angular amb navegació avançada</strong> que inclou:</p>
<ol>
<li><strong>Rutes niades amb jerarquia clara:</strong> Secció de perfil o administració amb sub-pàgines (<code>/perfil/configuracio</code>, <code>/perfil/privacitat</code>) que comparteixen layout comú sense duplicar codi</li>
<li><strong>Layouts compartits amb router-outlet:</strong> Components pare que proporcionen estructura, menús i estils a totes les rutes filles, renderitzades dinàmicament en <code>&lt;router-outlet&gt;</code></li>
<li><strong>Guàrdies d'autenticació:</strong> Protecció de rutes sensibles que comprova autenticació abans de carregar components, redirigint automàticament a login si l'accés és denegat</li>
<li><strong>Sistema de login amb returnUrl:</strong> Component de login que preserva la destinació original i hi retorna després d'autenticació exitosa, millorant l'experiència d'usuari</li>
<li><strong>Menú dinàmic amb estat d'autenticació:</strong> Interfície que mostra el nom de l'usuari autenticat i opció de logout, amb persistència mitjançant localStorage</li>
</ol>
<h3>Què queda preparat per a la Lliçó 4.2</h3>
<p>A la <strong>Lliçó 4.2 (Arquitectura i patrons)</strong> ampliareu l'arquitectura de l'aplicació amb:</p>
<ul>
<li><strong>Gestió d'estat centralitzada:</strong> Patrons per compartir estat entre components sense acoblament, amb serveis observables o llibreries com NgRx</li>
<li><strong>Modularització i lazy loading:</strong> Organitzar l'aplicació en mòduls funcionals que es carreguen sota demanda, reduint el bundle inicial en 60-80%</li>
<li><strong>Separació de responsabilitats:</strong> Dividir l'aplicació en capes (presentació, lògica, dades) amb components smart/dumb per millorar mantenibilitat</li>
</ul>
<p>Amb rutes niades i guàrdies dominats, esteu preparats per aplicar patrons arquitectònics avançats que facin l'aplicació escalable, mantenible i optimitzada.</p>
<h3>Contracte de sortida</h3>
{% include checklist.html elements="Sé crear rutes niades amb layouts compartits|Sé implementar guàrdies per protegir rutes sensibles|Sé construir sistemes d'autenticació amb login/logout|Sé utilitzar returnUrl per preservar destinació|Entenc l'herència de guàrdies i l'organització jeràrquica" %}
<p><strong>Les vostres aplicacions ara tenen arquitectura escalable amb protecció de seguretat i experiència d'usuari professional!</strong></p>
<h3>Referències ràpides</h3>
<p><strong>Comandes essencials:</strong></p>
{% capture code_198 %}ng generate guard guards/nom-guardia       # Crear guàrdia
ng generate component nom-component        # Crear component
ng serve --port 4300                       # Executar aplicació{% endcapture %}
{% include code-block.html lang="bash" code=code_198 %}
<p><strong>Sintaxi de rutes niades:</strong></p>
{% capture code_199 %}// Ruta niada
{
  path: 'admin',
  component: AdminLayoutComponent,
  canActivate: [authGuard],  // Protegir pare i filles
  children: [
    { path: 'usuaris', component: AdminUsuarisComponent },
    { path: 'comandes', component: AdminComandesComponent }
  ]
}

// Component pare amb outlet
<router-outlet></router-outlet>{% endcapture %}
{% include code-block.html lang="typescript" code=code_199 %}
<p><strong>Sintaxi de guàrdies:</strong></p>
{% capture code_200 %}// Crear guàrdia
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.estaAutenticat()) {
    return true;  // Permet navegació
  }

  // Redirigeix amb returnUrl
  return router.createUrlTree(['/login'], {
    queryParams: { returnUrl: state.url }
  });
};

// Aplicar guàrdia
{ path: 'preferits', canActivate: [authGuard] }{% endcapture %}
{% include code-block.html lang="typescript" code=code_200 %}
<p><strong>Troubleshooting ràpid:</strong></p>
<ul>
<li>Rutes filles NO es renderitzen → Afegir <code>&lt;router-outlet&gt;</code> al component pare</li>
<li>Guàrdia NO s'executa → Verificar <code>canActivate: [nomGuardia]</code> a la ruta</li>
<li>Redirecció infinita → Excloure <code>/login</code> de la guàrdia</li>
<li>returnUrl NO funciona → Verificar captura amb <code>queryParamMap.get('returnUrl')</code></li>
</ul>
<p><strong>Resolució de problemes detallada:</strong> Vegeu secció 3.13</p>
  {% endcapture %}
  {% include section-point.html numero="3.16" titol="Recapitulació" contingut=section_point_3_16 %}

  {% capture section_point_3_17 %}
<h3>Conceptes clau</h3>
<ul>
<li><strong>Rutes niades (nested routes):</strong> Jerarquia de rutes on una ruta pare conté rutes filles definides amb <code>children: []</code>, generant URLs com <code>/pare/filla</code></li>
<li><strong>children:</strong> Propietat d'una ruta que defineix l'array de rutes filles que es renderitzen dins del component pare</li>
<li><strong>router-outlet niat:</strong> <code>&lt;router-outlet&gt;</code> dins d'un component pare on es renderitzen les rutes filles dinàmicament</li>
<li><strong>Component layout:</strong> Component pare que proporciona estructura, menús i estils compartits a totes les rutes filles</li>
<li><strong>Guàrdia de ruta (route guard):</strong> Funció que s'executa abans de la navegació per validar condicions i decidir si permet accés o redirigeix</li>
<li><strong>CanActivateFn:</strong> Tipus TypeScript per guàrdies funcionals modernes que validen accés abans d'activar una ruta</li>
<li><strong>CanActivate:</strong> Guàrdia que s'executa abans de navegar a una ruta per comprovar autenticació, permisos o altres condicions</li>
<li><strong>CanDeactivate:</strong> Guàrdia que s'executa abans de sortir d'una ruta per avisar l'usuari de canvis no desats</li>
<li><strong>Resolve:</strong> Guàrdia que pre-carrega dades abans de mostrar el component, evitant estats de càrrega intermedis</li>
<li><strong>inject():</strong> Funció per injectar serveis dins de guàrdies funcionals, substituint la injecció per constructor</li>
<li><strong>createUrlTree:</strong> Mètode del Router per crear redirecció des d'una guàrdia retornant un UrlTree en lloc de navegar manualment</li>
<li><strong>returnUrl:</strong> Query param que preserva la destinació original quan l'usuari és redirigit a login, permetent retornar-hi després d'autenticar</li>
<li><strong>Herència de guàrdies:</strong> Les rutes filles hereten automàticament les guàrdies del pare sense necessitat de repetir-les</li>
<li><strong>Outlets múltiples:</strong> Múltiples <code>&lt;router-outlet name="nom"&gt;</code> per mostrar diverses vistes simultànies amb navegació independent</li>
<li><strong>canActivateChild:</strong> Guàrdia que protegeix totes les rutes filles d'una ruta pare sense afectar el pare mateix</li>
</ul>
  {% endcapture %}
  {% include section-point.html numero="3.17" titol="Repàs de conceptes" contingut=section_point_3_17 %}

</div>
